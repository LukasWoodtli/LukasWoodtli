<!DOCTYPE html>
<html lang="en">
<head>
          <title>Lukas Woodtli</title>
        <meta charset="utf-8" />



    <meta name="tags" content="Computer Science" />
    <meta name="tags" content="C++" />
    <meta name="tags" content="Embedded Systems" />

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://lukaswoodtli.github.io/">Lukas Woodtli <strong></strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/index.html">Home</a></li>
            <li><a href="/pages/resume.html">Resume</a></li>
            <li><a href="[(u'Hard Skills', u'/pages/skills.html'), (u'Courses', u'/pages/courses.html'), (u'Books', u'/pages/books.html'), (u'Projects', u'/pages/projects.html')]">Skills</a></li>
            <li><a href="[(u'Blog Index', u'/pages/blog.html'), (u'Categories', u'/categories.html'), (u'Tags', u'/tags.html'), (u'Chronological', u'/archives.html')]">Blog</a></li>
            <li><a href="/pages/contact.html">Contact</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/blog.html">Blog</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/books.html">Books</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/contact.html">Contact</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/courses.html">Courses</a></li>
            <li><a href="http://lukaswoodtli.github.io/">Welcome to my Site</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/projects.html">Projects</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/note_to_recruiters_and_headhunters.html">Note to Recruiters and Headhunters</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/resume.html">Resume</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/skills.html">Skills</a></li>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="http://lukaswoodtli.github.io/systemc.html" rel="bookmark"
         title="Permalink to SystemC">SystemC</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2016-02-15T00:00:00+01:00">
      Mon 15 February 2016
    </abbr>
    <abbr class="modified" title="2016-02-19T00:00:00+01:00">
      Fri 19 February 2016
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="http://lukaswoodtli.github.io/author/lukas_woodtli.html">Lukas Woodtli</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>SystemC is a system-level modeling language. It's implemented as a C++ library.</p>
<p>The library is open source and platform independent.</p>
<p>It contains an event-driven simulation kernel for executing models.</p>
<p><a href="http://accellera.org/">Accellera</a> is the main resource for SystemC.</p>
<h1>Simulation</h1>
<p>SystemC contains a kernel for discrete-event driven simulation.
The main purpose of the kernel is to ensure to model concurrent activities (parallelism) correctly.</p>
<p>The simulation clock represents the current value of the simulation time.</p>
<p><img alt="Simulation Engine" src="/images/systemc_simulation_engine.svg" style="float:right" /></p>
<ul>
<li>Initialization of simulation model<ul>
<li>Set initial states of subsystem modules</li>
<li>Fill event queue with initial events</li>
</ul>
</li>
<li>Timing routine<ul>
<li>Determine <em>next</em> event from event queue</li>
<li>Advance simulation clock to the time when the event is to occur</li>
</ul>
</li>
<li>Event routine<ul>
<li>Update the system state when a particular type of event occurs</li>
</ul>
</li>
</ul>
<p>A more detailed description can be found on the <a href="https://www.doulos.com/knowhow/systemc/tutorial/primitive_channels/">Doulos tutorial</a>:</p>
<ol>
<li>Initialization: execute all processes (except <code>SC_CTHREAD</code>s) in any (undefined) order</li>
<li>Evaluation: select a process (ready to run) and resume its execution<ul>
<li>This may cause immediate event notifications to occur</li>
<li>which may result in additional processes being made ready to run in this same phase</li>
</ul>
</li>
<li>Repeat step 2. until there are no processes ready to run</li>
<li>Update: execute all pending calls to <code>update()</code> resulting from calls to <code>request_update()</code> made in step 2.</li>
<li>If there were any delta event notifications made during steps 2. or 4.<ul>
<li>determine which processes are ready to run due to all those events and go back to step 2.</li>
</ul>
</li>
<li>If there are no timed events: simulation is finished</li>
<li>Advance the simulation time to the time of the earliest pending timed event notification</li>
<li>Determine which processes are ready to run due to all the timed events at what is now the current time<ul>
<li>go back to step 2.</li>
</ul>
</li>
</ol>
<p>(note: the list above is taken mostly from the Doulos tutorial)</p>
<h2>Delta Cycle</h2>
<p>Within the same simulation cycle <em>cause</em> and <em>effect</em> events may share the same time of occurrence.</p>
<p>The simulator uses a zero duration <em>virtual time interval</em>: delta cycle</p>
<p>The delta cycle is the smallest simulated time slot. It consist of two phases:</p>
<ol>
<li>Evaluation phase</li>
<li>Update phase</li>
</ol>
<p>Separating the two phases makes it possible to guarantee deterministic behavior.
A channel will not change it's value until the update phase occurs.
It cannot change the value during the evaluation phase.</p>
<p>It's possible to run a process without the update phase (without the delta cycle) with <code>notify()</code>.</p>
<h1>Constructs</h1>
<h2>Modules</h2>
<p>Building blocks of SystemC models.</p>
<ul>
<li>Hierarchy (subsystems)</li>
<li>Abstraction</li>
<li>IP reuse</li>
</ul>
<p>Modules are called by the simulation engine if an relevant event is scheduled.</p>
<p>Modules process events, manipulate the event queue and contain (and manipulate) the system state.</p>
<h2>Processes</h2>
<p>Processes must be contained in a module.</p>
<ul>
<li><code>SC_THREAD</code><ul>
<li>Typically called once, run in an endless loop</li>
<li>Can be suspended with <code>wait()</code></li>
<li>Keep the state of execution implicitly</li>
</ul>
</li>
<li><code>SC_METHOD</code><ul>
<li>Execute repeatedly form beginning to end</li>
<li>Simulate <em>faster</em></li>
<li>Do <em>not</em> keep state of execution implicitly</li>
</ul>
</li>
</ul>
<h3>Wait and Notify</h3>
<ul>
<li>wait: halt process execution until an event is raised<ul>
<li><code>wait()</code></li>
<li>wait with arguments: dynamic sensitivity<ul>
<li><code>wait(sc_event)</code></li>
<li><code>wait(time)</code></li>
<li><code>wait(time_out, sc_event)</code></li>
</ul>
</li>
</ul>
</li>
<li>notify: raise an event (method of <code>sc_event</code> class)<ul>
<li><code>my_event.notify()</code>: immediate notification. Processes sensitive to the event will run during current evaluation phase</li>
<li>notify with arguments: delayed notification<ul>
<li><code>my_event.notify(SC_ZERO_TIME)</code>: notify during evaluation phase of next delta cycle</li>
<li><code>my_event.notify(time)</code>: notify after <em>time</em> (in evaluation phase of that delta cycle)</li>
</ul>
</li>
<li>notify allows non-deterministic behavior</li>
</ul>
</li>
</ul>
<h2>Communication</h2>
<ul>
<li>Event<ul>
<li>Flexible</li>
<li>low-level synchronization primitive</li>
</ul>
</li>
<li>Channel<ul>
<li>Container for<ul>
<li>Communication and</li>
<li>Synchronization</li>
</ul>
</li>
<li>Can have state (private data), transport data/events</li>
<li>Implement one or more <em>interfaces</em></li>
</ul>
</li>
<li>Interface<ul>
<li>Set of access methods to channel</li>
<li>Interface methods need to be implemented (pure virtual)</li>
</ul>
</li>
</ul>
<p>Other communication and synchronization models can be built
based on these primitives.</p>
<h3>Channels</h3>
<ul>
<li>Separating communication from behavior</li>
<li>Interfaces define access to channel</li>
<li>Ports are used to access the channel</li>
</ul>
<h1>Non-Determinism</h1>
<p>SystemC allows for non-determinism. This might not be acceptable for hardware modeling.
But it can be needed for software system modeling.</p>
<p>An example of non-determinism can be found here: <a href="https://www.doulos.com/knowhow/systemc/tutorial/primitive_channels/">Doulos: Primitive Channels and the Kernel</a>.</p>
<p>It shows two threads (<code>SC_THREAD</code>s) in a module that both access the same variable. It's not known in
which order the variable is accessed.</p>
<p>In software systems a mutex might be needed to control the access to the variable.</p>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>