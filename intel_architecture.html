<!DOCTYPE html>
<html lang="en">
<head>
          <title>Lukas Woodtli</title>
        <meta charset="utf-8" />



    <meta name="tags" content="Computer Science" />
    <meta name="tags" content="Assembler" />

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://lukaswoodtli.github.io/">Lukas Woodtli <strong></strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/index.html">Home</a></li>
            <li><a href="/pages/resume.html">Resume</a></li>
            <li><a href="[(u'Hard Skills', u'/pages/skills.html'), (u'Courses', u'/pages/courses.html'), (u'Books', u'/pages/books.html'), (u'Projects', u'/pages/projects.html')]">Skills</a></li>
            <li><a href="[(u'Blog Index', u'/pages/blog.html'), (u'Categories', u'/categories.html'), (u'Tags', u'/tags.html'), (u'Chronological', u'/archives.html')]">Blog</a></li>
            <li><a href="/pages/contact.html">Contact</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/blog.html">Blog</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/books.html">Books</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/contact.html">Contact</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/courses.html">Courses</a></li>
            <li><a href="http://lukaswoodtli.github.io/">Welcome to my Site</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/projects.html">Projects</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/note_to_recruiters_and_headhunters.html">Note to Recruiters and Headhunters</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/resume.html">Resume</a></li>
            <li><a href="http://lukaswoodtli.github.io/pages/skills.html">Skills</a></li>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="http://lukaswoodtli.github.io/intel_architecture.html" rel="bookmark"
         title="Permalink to Intel Architecture">Intel Architecture</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2015-06-22T00:00:00+02:00">
      Mon 22 June 2015
    </abbr>
    <abbr class="modified" title="2015-07-20T00:00:00+02:00">
      Mon 20 July 2015
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="http://lukaswoodtli.github.io/author/lukas_woodtli.html">Lukas Woodtli</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>On this page I write down some notes about the Intel architecture (x86). I learned most of it in <a href="http://www.vdf.ethz.ch/info/showDetails.asp?isbnNr=3255">school</a> few years ago.</p>
<p>It's mainly for Intel 80186. But I'll extend it with information about modern <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel processors</a> (<a href="https://en.wikipedia.org/wiki/IA-32">IA-32</a>, <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a>).</p>
<p>I'm trying to keep all code examples in <a href="http://www.nasm.us">NASM</a> syntax.</p>
<p>There is a good overview of the <a href="https://en.wikipedia.org/wiki/X86_instruction_listings">x86 instructions</a> on Wikipedia.</p>
<p>[TOC]</p>
<h1>General</h1>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU Design</td>
<td><a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computing">CISC</a></td>
</tr>
<tr>
<td>Endianness</td>
<td><a href="https://en.wikipedia.org/wiki/Endianness">little</a></td>
</tr>
<tr>
<td>Type</td>
<td><a href="https://en.wikipedia.org/wiki/Register_memory_architecture">Register-memory</a></td>
</tr>
</tbody>
</table>
<h1>Operation Modes</h1>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Introduced in</th>
</tr>
</thead>
<tbody>
<tr>
<td>Real Mode</td>
<td>8086</td>
</tr>
<tr>
<td>Protected Mode</td>
<td>80286</td>
</tr>
<tr>
<td>Virtual 8086 mode</td>
<td>80386</td>
</tr>
<tr>
<td>Long Mode</td>
<td>x86-64</td>
</tr>
</tbody>
</table>
<h1>Memory Models</h1>
<p>The memory models define how data and code is manged in memory.</p>
<p>Most information in this section is from
<a href="http://www.agner.org/optimize/#manuals">Calling conventions for different C++ compilers and operating systems</a>.</p>
<p>There is also a good <a href="https://en.m.wikipedia.org/wiki/Intel_Memory_Model">Wikipedia page</a>.</p>
<h2>Real Mode Memory Models (16-bit)</h2>
<p>This memory models are used in DOS for example.</p>
<h3>Tiny</h3>
<p>Code and data in the same segment (64 kB). Code starts at
<code>0x100</code> relative to segment.</p>
<p>Executable has ending <em>.com</em> (instead of <em>.exe</em>).</p>
<h3>Small</h3>
<p>One segment for code and one segment for data and stack.
Both segments have max. size of 64 kB.</p>
<h3>Medium</h3>
<p>The code can exceed 64 kB (multiple segments). <em>Far</em> function calls are needed.</p>
<p>One segment (of max. 64 kB) for data and stack.</p>
<h3>Compact</h3>
<p>Code is limited to one segment (64 kB).</p>
<p>Stack is limited to one segment (64 kB).</p>
<p>Data can exceed 64 kB. <em>Far</em> pointers are needed for data.</p>
<h3>Large</h3>
<p>Code can exceed 64 kB.</p>
<p>Data can exceed 64 kB.</p>
<p>Stack is limited to one segment (64 kB).</p>
<p><em>Far</em> pointers are needed for code and data.</p>
<h3>Huge</h3>
<p>Same as large. A data structure can exceed 64 kB by
modifying segment and offset when a pointer is incremented.</p>
<h2>Protected Mode Memory Models (16-bit)</h2>
<p>Win 3.x uses <em>Protected Mode</em> and similar memory models as in Real Mode.</p>
<p>Segment registers contain <em>Segment Selectors</em> instead of physical 
addresses.</p>
<p>To access data structures bigger than 64 kB the <em>8</em> has to be 
added to the segment descriptor for each 64 kB increment.</p>
<p>On a 32-bit processor a 32-bit offset is used.</p>
<h2>32-bit Memory Models</h2>
<p>32-bit OS's (Windows, Linux, BSD, Intel-Mac) use the <em>Flat</em> memory
model. Application code uses only one (max. 2 GB) segment.</p>
<p>Pointers are 32-bit <em>signed</em> addresses. Negative addresses are
reseved for kernel and drivers.</p>
<h2>64-bit Memory Models</h2>
<h3>Windows</h3>
<p>The size of code and static data together is limited to 2 GB.
So it's possible to use RIP-relative addresses.
The image base of an executable binary is usually below <span class="math">\(2^{31}\)</span>.
Absolute 32-bit addresses are not often used.</p>
<p>Stack and dynamically allocated data (data on heap) can exceed 2 GB.</p>
<p>Pointers are usually 64 bits (sometimes 32 bits).</p>
<p>Negative addresses are reserved for the kernel.</p>
<h3>Linux snd BSD</h3>
<h4>Small</h4>
<p>Code an static data is limited to 2 GB and stored at addresses below <span class="math">\(2^{31}\)</span>.
The compiler can use absolte signed 32-bit addresses.</p>
<p>Stack and dynamically allocated data can exceed 2 GB.</p>
<p>Pointers are 64 bits.</p>
<p>Default memory model in Linux (x64) and BSD.</p>
<h4>Medium</h4>
<p>Static data bigger than the 'large-data-threshold' is stored in a
data section that can exceed 2 GB.</p>
<p>Code and smaller static data are limited to addresses below 
<span class="math">\(2^{31}\)</span>.</p>
<h4>Large</h4>
<p>Code and data can exceed 2 GB. Addresses are 64 bits.</p>
<h4>Kernel</h4>
<p>Used to compile the kernel and device drivers.</p>
<p>Addresses must be negative between <span class="math">\(-2^{31}\)</span> and <span class="math">\(0\)</span>.</p>
<h3>OS X (Darwin)</h3>
<p>The defaukt memory model of the intel-based darwin kernel 
limits code and static data together to 2 GB.
So 32-bit RIP-relative addresses can be used.</p>
<p>Code is loaded to addresses above <span class="math">\(2^{32}\)</span> by default.
Addresses below <span class="math">\(2^{32}\)</span> are blocked (pagezero).</p>
<p>Stack and dynamically allocated data can exceed 2 GB.</p>
<p>Pointers are 64 bits. Pointer tables can use 32-bit
signed addresses relative to any reference point.</p>
<p>Certain system functions can be accessed in the <em>commpage</em>.</p>
<p>It's possible to reduce the size of <em>pagezero</em> to place
code below <span class="math">\(2^{31}\)</span> so that absolute 32-bit addresses can be used.</p>
<h1>Registers</h1>
<p>This are the 16-bit registers of Intel 8086, 8088,  80186 and 80188.</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>Purpose</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX</td>
<td>General-Purpose Register (GPR)</td>
<td>Accumulator for <code>IN</code>/<code>OUT</code> (AX or AL). Can be used as 8-bit registers (AH/AL).</td>
</tr>
<tr>
<td>BX</td>
<td>General-Purpose Register (GPR)</td>
<td>Base index (array). Can be used as 8-bit registers (BH/BL).</td>
</tr>
<tr>
<td>CX</td>
<td>General-Purpose Register (GPR)</td>
<td>Only register that can be used for <code>LOOP</code>. Can be used as 8-bit registers (CH/CL).</td>
</tr>
<tr>
<td>DX</td>
<td>General-Purpose Register (GPR)</td>
<td>Needs to contain port address for <code>IN</code>/<code>OUT</code>. Extend precision of accumulator. Can be used as 8-bit registers (DH/DL).</td>
</tr>
<tr>
<td>DI</td>
<td>Destination Index</td>
<td>Destination for string operations.</td>
</tr>
<tr>
<td>SI</td>
<td>Source Index</td>
<td>Source for string operations.</td>
</tr>
<tr>
<td>BP</td>
<td>Base Pointer</td>
<td>Often used as Frame Pointer (pointing to current stack frame).</td>
</tr>
<tr>
<td>SP</td>
<td>Stack Pointer</td>
<td>Points to the top of the stack.</td>
</tr>
<tr>
<td>CS</td>
<td>Segment Register</td>
<td>Code Segment.</td>
</tr>
<tr>
<td>DS</td>
<td>Segment Register</td>
<td>Data Segment.</td>
</tr>
<tr>
<td>SS</td>
<td>Segment Register</td>
<td>Stack Segment.</td>
</tr>
<tr>
<td>ES</td>
<td>Segment Register</td>
<td>Extra Segment.</td>
</tr>
<tr>
<td>FLAGS</td>
<td>Status Register</td>
<td>Carry Flag, Overflow Flag, Zero flag...</td>
</tr>
<tr>
<td>IP</td>
<td>Instruction Pointer</td>
<td>Points to the <em>next</em> instruction (cannot be directly accessed).</td>
</tr>
</tbody>
</table>
<h2>8-bit Registers</h2>
<p>Each of the <em>GPRs</em> can be accessed as two 8 bit registers. i. e:
<em>BX's</em> high byte can be accessed as <em>BH</em> and low byte as <em>BL</em>.</p>
<h2>Values after Reset</h2>
<table>
<thead>
<tr>
<th>Register</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP</td>
<td><code>0x0000</code></td>
</tr>
<tr>
<td>CS</td>
<td><code>0xffff</code></td>
</tr>
<tr>
<td>DS</td>
<td><code>0x0000</code></td>
</tr>
<tr>
<td>ES</td>
<td><code>0x0000</code></td>
</tr>
<tr>
<td>SS</td>
<td><code>0x0000</code></td>
</tr>
</tbody>
</table>
<p>All other registers have a random value after reset.</p>
<h2>FLAGS Register</h2>
<table>
<thead>
<tr>
<th>Bit</th>
<th>Mnemonic</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>-</td>
<td>Reserved</td>
</tr>
<tr>
<td>14</td>
<td>NT</td>
<td>Nested Task Flag (286+)</td>
</tr>
<tr>
<td>13 and 12</td>
<td>IOPL</td>
<td>I/O Privilege Level (286+)</td>
</tr>
<tr>
<td>11</td>
<td>OF</td>
<td>Overflow Flag</td>
</tr>
<tr>
<td>10</td>
<td>DF</td>
<td>Direction Flag</td>
</tr>
<tr>
<td>9</td>
<td>IF</td>
<td>Interrupt Enable Flag</td>
</tr>
<tr>
<td>8</td>
<td>TF</td>
<td>Trap Flag (single step)</td>
</tr>
<tr>
<td>7</td>
<td>SF</td>
<td>Sign Flag</td>
</tr>
<tr>
<td>6</td>
<td>ZF</td>
<td>Zero Flag</td>
</tr>
<tr>
<td>5</td>
<td>-</td>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>AF</td>
<td>Adjust Flag</td>
</tr>
<tr>
<td>3</td>
<td>-</td>
<td>Reserved</td>
</tr>
<tr>
<td>2</td>
<td>PF</td>
<td>Parity Flag</td>
</tr>
<tr>
<td>1</td>
<td>-</td>
<td>Reserved</td>
</tr>
<tr>
<td>0</td>
<td>CF</td>
<td>Carry Flag</td>
</tr>
</tbody>
</table>
<h1>Segmentation</h1>
<p>To allow access to 20-bit addresses with 16-bit registers the 8086 uses segmentation.</p>
<div class="math">$$physical\_ address = segment\_ register \times 10_{hex} + offset$$</div>
<ul>
<li><span class="math">\(\times 10_{hex}\)</span> means a 4-bit shift to left</li>
<li>Each addressable segment is 64 kB big.</li>
<li>20-bit address bus: Total <span class="math">\(2^{20}\)</span> bytes addressable (1'048'576 bytes = 1 MB).</li>
<li>16-bit offset: <span class="math">\(2^{16}\)</span> bytes addressable (65'536 bytes = 64 kB) per segment.</li>
<li>Needed segments: <span class="math">\(2^{20}/2^{16} = 2^4 = 16\)</span> segments needed to access complete address space.</li>
<li>Segments can overlap or there can be gaps between them.</li>
</ul>
<h1>Addressing</h1>
<p>Intel processors have 5 different addressing modes.</p>
<h2>Immediate</h2>
<p>The operand (constant) is given with the command. i.e:</p>
<pre>MOV CL, <strong>42</strong>; move the value 42 to register CL</pre>

<h2>Implicit</h2>
<p>Some commands work always with the same register/address. i.e:</p>
<p><code>PUSH</code>/<code>POP</code> work always with SP register.</p>
<h2>Register</h2>
<p>The operand is held in a register</p>
<pre>INC <strong>CH</strong>; Increment value in CH register</pre>

<h2>Direct</h2>
<p>The address of the operand value comes directly after the command. i. e:</p>
<pre>MOV CX, <strong>counter</strong>; counter holds the address of the value</pre>

<h2>Register-Indirect</h2>
<p>The operand is given indirectly by one or two registers. A segment register and a constant offset value can be supplied.</p>
<p>The calculated value acts as a pointer (address to a memory location).</p>
<p>i.e:</p>
<pre>MOV <strong>[BX + DI]</strong>, CH; calculate the operand with the values from BX and DI</pre>

<h3>Address</h3>
<p>To calculate an address the following scheme is used:</p>
<div class="math">$$Offset := \begin{Bmatrix}-\\CS:\\DS:\\SS:\\ES:\end{Bmatrix}\begin{Bmatrix}-\\BX\\BP\end{Bmatrix} +\begin{Bmatrix}-\\SI\\DI\end{Bmatrix} + \begin{Bmatrix}-\\displacement_8\\displacement_{16}\end{Bmatrix}$$</div>
<p><span class="math">\(-\)</span> means that this element is not used.</p>
<p>The three possible address parts are:</p>
<ol>
<li>Basis Register (BX or BP): Contains usually the start address of a data structure. A segment prefix can be given.</li>
<li>Index Register (SI or DI): Can contain an index (i.e Array index) that can be calculated at run-time. It's 16-bit unsigned.</li>
<li>Displacement: A <em>signed</em> constant value (8-bit or 16-bit) that gives an offset.</li>
</ol>
<p>This addressing scheme gives a total of 27 addressing combinations. But only <em>24</em> combinations are allowed. The following three are <strong>not allowed</strong>:</p>
<ul>
<li>No address at all: <pre><strike>MOV AX, [];</strike></pre> or <pre><strike>MOV AX, ;</strike></pre></li>
<li>Only 8-bit displacement: Only memory 0-255 could be addressed.</li>
<li>Only BP: BP points to stack. No practical use. <pre><strike>MOV AX, [BP];</strike></pre></li>
</ul>
<h4>Segment Prefix</h4>
<p>A segment prefix (<strong>CS:</strong>, <strong>DS:</strong>, <strong>ES:</strong> or <strong>SS:</strong>) defines which segment register will be used for calculating the address.
Default for most registers is DS. But for BP the default is SS.</p>
<h4>Operand Size (<code>WORD</code>, <code>DWORD</code>...)</h4>
<p>In some cases the size of an operand can be given (for some cases it is even mandatory). Size types:</p>
<p><code>BYTE</code>, <code>WORD</code>, <code>DWORD</code>, <code>QWORD</code>, <code>TBYTE</code>, <code>FAR</code>...</p>
<h4>Examples</h4>
<div class="highlight"><pre><span class="nf">MOV</span> <span class="nb">DX</span><span class="p">,</span> <span class="p">[</span><span class="nb">BX</span><span class="p">]</span><span class="c1">;</span>
<span class="nf">MOV</span> <span class="nb">AL</span><span class="p">,</span> <span class="p">[</span><span class="nb">BX</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span><span class="c1">;</span>
<span class="nf">MOV</span> <span class="nb">CX</span><span class="p">,</span> <span class="p">[</span><span class="nb">CS</span><span class="p">:</span><span class="nb">BX</span><span class="o">+</span><span class="nb">SI</span><span class="p">]</span><span class="c1">;</span>
<span class="nf">MOV</span> <span class="nb">ES</span><span class="p">,</span> <span class="p">[</span><span class="nb">BX</span><span class="o">+</span><span class="nb">DI</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="c1">;</span>
<span class="nf">MOV</span> <span class="kt">WORD</span> <span class="p">[</span><span class="nb">ES</span><span class="p">:</span><span class="nb">BX</span><span class="o">+</span><span class="nb">DI</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="nb">AX</span><span class="c1">;</span>
</pre></div>


<h2>Addressing Memory</h2>
<p>For addressing the memory the immediate, direct and indirect method can be used.</p>
<h1>Data Transfer Commands</h1>
<h2>Move Command (<code>MOV</code>)</h2>
<p>Moves (copies) a value from a source to a destination.</p>
<div class="highlight"><pre><span class="nf">MOV</span> <span class="nv">dest</span><span class="p">,</span> <span class="nv">src</span><span class="c1">;</span>
</pre></div>


<ul>
<li><code>dest</code> can be a memory variable or a register (but not CS or IP).</li>
<li><code>src</code> can be a memory variable, a register or a constant.</li>
<li>Only one memory operand can be used. Then the other one needs to be a register or a constant.</li>
</ul>
<h2>Exchange Command (<code>XCHG</code>)</h2>
<p>Exchanges the values of the two operands (memory/registers).</p>
<div class="highlight"><pre><span class="nf">XCHG</span> <span class="nv">op1</span><span class="p">,</span> <span class="nv">op2</span>
</pre></div>


<ul>
<li>Addressing memory/register is same as with <code>MOV</code>.</li>
<li>Segment Register and Immediate addressing is not possible.</li>
</ul>
<h2>Input-/Output Commands (<code>IN</code>/<code>OUT</code>)</h2>
<p>For reading and writing data to/from ports</p>
<p>Input/Output can only be done with accumulator register (AX/AL).</p>
<p>Port address needs to be written to DX before calling the IN-/OUT-Command. As special case a 8-bit port address can be given directly.</p>
<div class="highlight"><pre><span class="nf">IN</span> <span class="nb">AL</span><span class="p">,</span> <span class="nb">DX</span><span class="c1">;</span>
<span class="nf">OUT</span> <span class="nb">DX</span><span class="p">,</span> <span class="nb">AX</span><span class="c1">;</span>
<span class="nf">IN</span> <span class="nb">AX</span><span class="p">,</span> <span class="mh">42h</span><span class="c1">;</span>
<span class="nf">OUT</span> <span class="mh">16h</span><span class="p">,</span> <span class="nb">AL</span><span class="c1">;</span>
</pre></div>


<p>It's not possible communicate directly between memory and ports. For this a DMA (Direct Memory Access) Hardware would be needed.</p>
<h1>Arithmetic Commands</h1>
<ul>
<li>The result of arithmetic commands is written to the first operand (the original value is lost).</li>
<li>Both operands (of binary arithmetic commands) need to be of same size.</li>
<li>Only one operand is allowed to be a memory operand.</li>
</ul>
<h2>Addition (<code>ADD</code>)</h2>
<p>Adds the two operands and writes the result into the first one. The first operand can not be a constant.</p>
<h3>Affected Flags</h3>
<ul>
<li>Carry: with unsigned operands</li>
<li>Overflow: with signed operands</li>
<li>Zero: if result is zero</li>
<li>Sign: if signed result is negative</li>
<li>Parity: if parity is even</li>
</ul>
<h2>Addition with Carry (<code>ADC</code>)</h2>
<p>Adds the two operands and the carry flag. The result is written into the first operand. The first operand can not be a constant.</p>
<blockquote>
<p>Addition of big signed operands can be splitted into several <code>ADC</code> commands.</p>
</blockquote>
<h3>Affected Flags</h3>
<ul>
<li>Carry: with unsigned operands</li>
<li>Overflow: with signed operands</li>
<li>Zero: if result is zero</li>
<li>Sign: if signed result is negative</li>
<li>Parity: if parity is even</li>
</ul>
<h2>Increment (<code>INC</code>)</h2>
<p>Adds one to the operand. The result is saved in the given operand.</p>
<h3>Affected Flags</h3>
<ul>
<li>Overflow: with signed operands</li>
<li>Zero: if result is zero</li>
<li>Sign: if signed result is negative</li>
<li>Parity: if parity is even</li>
</ul>
<blockquote>
<p>The carry-flag is not affected! An overflow can be recognized with the zero-flag.</p>
<p><code>INC</code> can be used to increment a control variable in a loop without affecting the carry-flag.</p>
</blockquote>
<h2>Subtraction (<code>SUB</code>)</h2>
<p>Subtracts the second operand from the first. The result is written into the first operand. The first operand can not be a constant.</p>
<h3>Affected Flags</h3>
<ul>
<li>Carry: with unsigned operands</li>
<li>Overflow: with signed operands</li>
<li>Zero: if result is zero</li>
<li>Sign: if signed result is negative</li>
<li>Parity: if parity is even</li>
</ul>
<h2>Subtraction with Borrow (<code>SBB</code>)</h2>
<p>Subtracts the second operand and the carry-flag (borrow) from the first operand. The result is written into the first operand. The first operand can not be a constant.</p>
<h3>Affected Flags</h3>
<ul>
<li>Carry: with unsigned operands</li>
<li>Overflow: with signed operands</li>
<li>Zero: if result is zero</li>
<li>Sign: if signed result is negative</li>
<li>Parity: if parity is even</li>
</ul>
<blockquote>
<p>Subtraction of big signed operands can be splitted into several <code>SBB</code> commands.</p>
</blockquote>
<h2>Decrement (<code>DEC</code>)</h2>
<p>Subtracts one from the given operand.</p>
<h3>Affected Flags</h3>
<ul>
<li>Overflow: with signed operands</li>
<li>Zero: if result is zero</li>
<li>Sign: if signed result is negative</li>
<li>Parity: if parity is even</li>
</ul>
<blockquote>
<p>The carry-flag is not affected! An overflow can be only recognized with checking the result for 0xFF.</p>
<p><code>DEC</code> can be used to decrement a control variable in a loop without affecting the carry-flag.</p>
</blockquote>
<h2>Negate a signed Number (<code>NEG</code>)</h2>
<p>Changes a negative into a positive number and vice versa. It's basically subtracting the operand from zero (0).</p>
<h3>Affected Flags</h3>
<ul>
<li>Carry: set if operand wasn't zero (not very useful)</li>
<li>Overflow: if no positive representation exist (operand was biggest negative number)</li>
<li>Zero: if result is zero</li>
<li>Sign: if signed result is negative</li>
<li>Parity: if parity is even</li>
</ul>
<h2>Multiplication (<code>MUL</code>, <code>IMUL</code>)</h2>
<p>Multiplicates unsigned (<code>MUL</code>) or signed (<code>IMUL</code>) numbers.</p>
<p>There is a explicit operand given after the command and an implicit operand in the AX or AL register.</p>
<p>The explicit operand sets the size and defines the used implicit register. It can be either a register or a memory location.</p>
<p>The result is always twice as big as the operands. It's either the accumulator (<em>AX</em>)
or the <strong>extended accumulator</strong> (<em>DX/AX</em>).</p>
<p><img alt="The x86 MUL/IMUL commands" src="/images/intel_mul.svg" /></p>
<div class="highlight"><pre><span class="nf">MUL</span> <span class="mh">0x0</span> <span class="c1">; Use AL as implicit operand. Result is saved in AX.</span>
<span class="nf">IMUL</span> <span class="nb">BX</span> <span class="c1">; Use AX as implicit operand. Result is saved in DX/AX.</span>
</pre></div>


<h3>Affected Flags</h3>
<ul>
<li>Carry: set if operand extended accumulator is needed for saving result (<em>DX/AX</em>)</li>
<li>Zero: changed (undefined)</li>
<li>Sign: changed (undefined)</li>
<li>Parity: changed (undefined)</li>
</ul>
<blockquote>
<p>The 8086 can not multiply with constants (immediate).</p>
</blockquote>
<h2>Division (<code>DIV</code>, <code>IDIV</code>)</h2>
<p>There are different division operations for unsigned (<code>DIV</code>) and signed (<code>IDIV</code>) numbers.</p>
<p>The explicit operand (given directly after the command) defines the size of the operands.
It can be a register or a memory location.</p>
<p>The implicit operand is the accumulator (<em>AX</em>) or the extended accumulator (<em>DX/AX</em>), dependant on
the size of the explicit operator.</p>
<p>The result (quotient) is saved either in <em>AX</em> or <em>AL</em>. The remainder is saved in either <em>DX</em> or <em>AH</em>.</p>
<p><img alt="The x86 MUL/IMUL commands" src="/images/intel_div.svg" /></p>
<div class="highlight"><pre><span class="nf">DIV</span> <span class="nb">BX</span> <span class="c1">; Use DX/AX  as implicit operand. Result is saved in AX. Remainder is saved in DX.</span>
<span class="nf">IDIV</span> <span class="mh">0x34</span> <span class="c1">; Use AX as implicit operand. Result is saved in AL. Remainder is saved in AH.</span>
</pre></div>


<h3>Affected Flags</h3>
<ul>
<li><strong>All</strong> flags are changed to <em>undefined</em>!</li>
</ul>
<blockquote>
<p>If the result is too big for the register <em>AL</em> resp. <em>AX</em> a interrupt (<em>division error</em>) is caused.
If it is not handled the <strong>program can crash</strong> (undefined behaviour).</p>
</blockquote>
<h2>Convert Operand Size (<code>CBW</code>, <code>CWD</code>)</h2>
<p>The commands <em>convert byte to word</em> (<code>CBW</code>) and <em>convert word to double-word</em> (<code>CWD</code>) convert a <em>signed</em>
number to a number of the same value but twice the size. This is needed to keep the
<a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a> format.</p>
<h1>Logical Commands</h1>
<h2>And, Or and Xor (<code>AND</code>, <code>OR</code>, <code>XOR</code>)</h2>
<p>Bit-wise <strong>and</strong>, <strong>or</strong> or <strong>xor</strong>  operation. The first operand can be a register or a memory address. The second operand can
be a register, a memory address or a constant.</p>
<p>The first operand is overwritten with the result.</p>
<h3>Affected Flags</h3>
<ul>
<li>Carry and Overflow: are always reset (0)</li>
<li>Zero and Sign: are set according to the result</li>
</ul>
<h2>Not (<code>NOT</code>)</h2>
<p>Bit-wise <strong>not</strong> (inverse) operation. The operand can be a register or a memory address.</p>
<p>The operand is overwritten with the result.</p>
<h3>Affected Flags</h3>
<ul>
<li><strong>No</strong> flags are changed</li>
</ul>
<h1>Rotation Commands</h1>
<h2>Rotate (<code>ROL</code>, <code>ROR</code>)</h2>
<p>Rotate left (<code>ROL</code>) or right (<code>ROR</code>).</p>
<p>Rotates the first operand (memory or register) by the constant <strong>1</strong> (immediate) or by the value given in <em>CL</em>.</p>
<div class="highlight"><pre><span class="nf">ROL</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mi">1</span><span class="c1">; Rotate by one.</span>
<span class="nf">ROR</span> <span class="nb">AX</span><span class="p">,</span> <span class="nb">CL</span><span class="c1">; Rotate by value in CL.</span>
</pre></div>


<h3>Affected Flags</h3>
<ul>
<li>Overflow:<ul>
<li>For one-bit rotation: Overflow set if MSB is changed by the rotation. Otherwise it's not set.</li>
<li>For other cases: Overflow is undefined</li>
</ul>
</li>
<li>Carry has the value of the bit that was shifted from one end to the other.</li>
</ul>
<h2>Rotate with Carry (<code>RCL</code>, <code>RCR</code>)</h2>
<p>Rotate left (<code>RCL</code>) or right (<code>RCR</code>) with carry as MSB.</p>
<p>The first operand (memory or register) is extended with the carry bit as the MSB.
It is then rotated by the constant <strong>1</strong> (immediate) or by the value given in <em>CL</em>.</p>
<h3>Affected Flags</h3>
<ul>
<li>Overflow:<ul>
<li>For one-bit rotation: Overflow set if MSB is changed by the rotation. Otherwise it's not set.</li>
<li>For other cases: Overflow is undefined</li>
</ul>
</li>
<li>Carry has the value of the bit that was shifted from one end to the other.</li>
</ul>
<h1>Manipulate the Carry Flag (<code>CLC</code>, <code>STC</code>, <code>CMC</code>)</h1>
<p>Clear Carry Flag (<code>CLC</code>): CF = 0.</p>
<p>Set Carry Flag (<code>STC</code>): CF = 1.</p>
<p>Complement Carry Flag (<code>CMC</code>): CF = !CF.</p>
<h1>Shift Commands</h1>
<p>The shift commands can be used to multiply with or divide by a
power of two (2, 5, 8, ...).</p>
<p>For a multiplication or a division of a <em>unsigned</em> number the <em>logical
shift operators</em> need to be used.</p>
<p>For a multiplication or a division of a <em>signed</em> number the <em>arithmetic
shift operators</em> need to be used.</p>
<h2>Left Shift Commands (<code>SHL</code>, <code>SAL</code>)</h2>
<p>Both left shift operators are functional identical. They muliplicate
the operator by <em>2</em> or by <span class="math">\(2^{CL}\)</span>.</p>
<p>Shifts the given operator (memory or register) left by
the constant <strong>1</strong> (immediate) or by the value given in <em>CL</em>.</p>
<h3>Affected Flags</h3>
<ul>
<li>Zero</li>
<li>Sign</li>
<li>Offset</li>
<li>For one-bit shift:<ul>
<li>Carry: For unsigned Operands a set carry flag means <em>overflow</em></li>
<li>Overflow: For signed Operands a set overflow flag means <em>overflow</em></li>
</ul>
</li>
</ul>
<h2>Right  Shift Commands (<code>SHR</code>, <code>SAR</code>)</h2>
<p>The <em>logical shift right</em> (<code>SHR</code>) divides a unsigned value by <em>2</em> or by <span class="math">\(2^{CL}\)</span>.</p>
<p>The <em>arithmetic shift right</em> (<code>SHR</code>) divides a unsigned value by <em>2</em> or by <span class="math">\(2^{CL}\)</span>.
The sign stays unchanged.</p>
<p>The first operand is a memory location or a register. The second operand is the
constant <strong>1</strong> or the register <em>CL</em>.</p>
<h3>Affected Flags</h3>
<ul>
<li>CF: For one-bit shifts the carry flag holds the remainder of the division</li>
<li>ZF</li>
<li>SF</li>
<li>(OF)</li>
</ul>
<h1>Jump Commands</h1>
<p>Jump commands can be divided by different topics.</p>
<h2>Conditional/Unconditional Jumps</h2>
<p>Unconditional jumps are always performed. Conditional jumps are only
performed if a check gives an expected result (i.e flags).</p>
<h2>Short, Near and Far Jumps</h2>
<ul>
<li>Short: signed 8-bit distance</li>
<li>Near: unsigned 16-bit distance</li>
<li>Far: 32-bit (Segment and Offset)</li>
</ul>
<h2>Direct and Indirect Jumps</h2>
<ul>
<li>Direct: The target address is given directly after the command</li>
<li>Indirect: The position is given indirectly by a register or a memory position</li>
</ul>
<h2>Absolute and Relative Jumps</h2>
<ul>
<li>Absolute jumps: The target address is an absolute address</li>
<li>Relative jumps: The target address is given relative to the actual position (<em>IP</em>)</li>
</ul>
<p>The 8086 has following possible jump commands:</p>
<p><img alt="The Intel x86 jump commands" src="/images/intel_architecture_jump.svg" /></p>
<h2>Intra- and Inter-Segment Jumps</h2>
<p>All jumps change the <em>IP</em> register.</p>
<p>Far jumps also change the <em>CS</em> register.</p>
<h3>Intra-Segment Jump</h3>
<p>Short- and Near-Jumps change only the <em>IP</em> register. The target
is always inside the actual code segment (<em>CS</em>).</p>
<h4>Near Jump</h4>
<ul>
<li>Direct Near-Jumps are always relative to <em>IP</em>.</li>
<li>Indirect Near-Jumps are always absolute to the actual code segment.</li>
</ul>
<h4>Short Jump</h4>
<p>Short Jumps are always relative to <em>IP</em>.</p>
<h3>Inter-Segment Jump</h3>
<p>Far jumps change <em>CS</em> and <em>IP</em>.</p>
<p>All far jumps are absolute.</p>
<h2>Unconditional Jumps</h2>
<ul>
<li>8-bit displacement is added to <em>IP</em> as signed number:<pre><strong>JMP</strong> displ8</pre></li>
<li>16-bit displacement is added to <em>IP</em> as unsigned number:<pre><strong>JMP</strong> displ16</pre></li>
<li>The constant is the absolute 32-bit FAR-addressed:<pre><strong>JMP</strong> const32</pre></li>
<li><em>IP</em> is loaded with the value of the register:<pre><strong>JMP</strong> reg16</pre></li>
<li><em>IP</em> is loaded with the value given by the memory position:<pre><strong>JMP</strong> mem16</pre></li>
<li><em>CS</em> and <em>IP</em> are loaded with the value at the memory position:<pre><strong>JMP</strong> mem32</pre></li>
</ul>
<h2>Conditional Jumps</h2>
<p>Conditional jumps check one or more flags and jump to a given address if a condition is met.</p>
<p>Before the jump can be performed the flags need to be set by a logical or arithmetic command.
Alternatively the commands <code>CMP</code> and <code>TEST</code> can be used.</p>
<p>Conditional jumps can be divided into following groups:</p>
<ul>
<li>Arithmetic jumps: The jump depends on size difference of two operands. The two operands have to be <em>divided</em> in advance.
                    One or more flags have to be checked.</li>
<li>Flag oriented jumps: A jump is performed if <em>one</em> given flag is set or deleted.</li>
</ul>
<h3>Arithmetic Jumps</h3>
<p>The jump is performed if the size relation between two given operands is as expected.</p>
<p>The relation is expressed differently for signed and unsigned operands:</p>
<table>
<thead>
<tr>
<th>Relation</th>
<th>unsigned</th>
<th>signed</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math">\(=\)</span></td>
<td>equal</td>
<td>equal</td>
</tr>
<tr>
<td><span class="math">\(&lt;\)</span></td>
<td>below</td>
<td>less</td>
</tr>
<tr>
<td><span class="math">\(&gt;\)</span></td>
<td>above</td>
<td>greater</td>
</tr>
</tbody>
</table>
<h4>Arithmetic <em>"unsigned"</em> Jumps</h4>
<table>
<thead>
<tr>
<th>Relation</th>
<th>Command</th>
<th>Explanation</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math">\(=\)</span></td>
<td><code>JE</code></td>
<td>Jump if equal</td>
<td>ZF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><span class="math">\(\neq\)</span></td>
<td><code>JNE</code></td>
<td>Jump if not equal</td>
<td>ZF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><span class="math">\(&lt;\)</span></td>
<td><code>JB</code></td>
<td>Jump if below</td>
<td>CF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><span class="math">\(\ngeq\)</span></td>
<td><code>JNAE</code></td>
<td>Jump if not above or equal</td>
<td>CF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><span class="math">\(\ge\)</span></td>
<td><code>JAE</code></td>
<td>Jump if above or equal</td>
<td>CF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><span class="math">\(\not&lt;\)</span></td>
<td><code>JNB</code></td>
<td>Jump if not below</td>
<td>CF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><span class="math">\(\le\)</span></td>
<td><code>JBE</code></td>
<td>Jump if below or equal</td>
<td>CF <span class="math">\(=\)</span> 1 or ZF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><span class="math">\(\not&gt;\)</span></td>
<td><code>JNA</code></td>
<td>Jump if not above</td>
<td>CF <span class="math">\(=\)</span> 1 or ZF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><span class="math">\(&gt;\)</span></td>
<td><code>JA</code></td>
<td>Jump if above</td>
<td>CF <span class="math">\(=\)</span> 0 and ZF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><span class="math">\(\not\le\)</span></td>
<td><code>JNBE</code></td>
<td>Jump if not below or equal</td>
<td>CF <span class="math">\(=\)</span> 0 and ZF <span class="math">\(=\)</span> 0</td>
</tr>
</tbody>
</table>
<h4>Arithmetic <em>"signed"</em> Jumps</h4>
<table>
<thead>
<tr>
<th>Relation</th>
<th>Command</th>
<th>Explanation</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math">\(=\)</span></td>
<td><code>JE</code></td>
<td>Jump if equal</td>
<td>ZF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><span class="math">\(\neq\)</span></td>
<td><code>JNE</code></td>
<td>Jump if not equal</td>
<td>ZF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><span class="math">\(&lt;\)</span></td>
<td><code>JL</code></td>
<td>Jump if less</td>
<td>OF <span class="math">\(\neq\)</span> SF</td>
</tr>
<tr>
<td><span class="math">\(\ngeq\)</span></td>
<td><code>JNGE</code></td>
<td>Jump if not greater or equal</td>
<td>OF <span class="math">\(\neq\)</span> SF</td>
</tr>
<tr>
<td><span class="math">\(\ge\)</span></td>
<td><code>JGE</code></td>
<td>Jump if greater or equal</td>
<td>OF <span class="math">\(=\)</span> SF</td>
</tr>
<tr>
<td><span class="math">\(\not&lt;\)</span></td>
<td><code>JNL</code></td>
<td>Jump if not less</td>
<td>OF <span class="math">\(=\)</span> SF</td>
</tr>
<tr>
<td><span class="math">\(\le\)</span></td>
<td><code>JLE</code></td>
<td>Jump if less or equal</td>
<td>OF <span class="math">\(\neq\)</span> SF or ZF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><span class="math">\(\not&gt;\)</span></td>
<td><code>JNG</code></td>
<td>Jump if not greater</td>
<td>OF <span class="math">\(\neq\)</span> SF or ZF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><span class="math">\(&gt;\)</span></td>
<td><code>JG</code></td>
<td>Jump if greater</td>
<td>OF <span class="math">\(=\)</span> SF and ZF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><span class="math">\(\not\le\)</span></td>
<td><code>JNLE</code></td>
<td>Jump if not less or equal</td>
<td>OF <span class="math">\(=\)</span> SF and ZF <span class="math">\(=\)</span> 0</td>
</tr>
</tbody>
</table>
<h3>Flag oriented Jumps</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Explanation</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>JZ</code></td>
<td>Jump if zero</td>
<td>ZF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><code>JNZ</code></td>
<td>Jump if not zero</td>
<td>ZF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><code>JC</code></td>
<td>Jump if carry</td>
<td>CF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><code>JNC</code></td>
<td>Jump if no carry</td>
<td>CF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><code>JS</code></td>
<td>Jump if sign</td>
<td>SF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><code>JNS</code></td>
<td>Jump if no sign</td>
<td>SF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><code>JO</code></td>
<td>Jump if overflow</td>
<td>OF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><code>JNO</code></td>
<td>Jump if no overflow</td>
<td>OF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><code>JP</code></td>
<td>Jump if parity</td>
<td>PF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><code>JNP</code></td>
<td>Jump if no parity</td>
<td>PF <span class="math">\(=\)</span> 0</td>
</tr>
<tr>
<td><code>JPE</code></td>
<td>Jump if parity even</td>
<td>PF <span class="math">\(=\)</span> 1</td>
</tr>
<tr>
<td><code>JPO</code></td>
<td>Jump if parity odd</td>
<td>PF <span class="math">\(=\)</span> 0</td>
</tr>
</tbody>
</table>
<h2>Comparing Commands (<code>CMP</code>, <code>TEST</code>)</h2>
<p>Since the different jump commands depend on flags set or not there
are special commands that only affect the flags.</p>
<ul>
<li><code>CMP</code> is a subtraction of the operands (8-bit or 16-bit) but it only changes the flags.
   The result is not written anywhere.</li>
<li><code>TEST</code> is a <em>AND</em> operation of the operands (8-bit or 16-bit) that only changes the flags.
   The result is not written anywhere.</li>
</ul>
<p>Both commands accept a register or a memory location as first operand and a register, a memory location
or a constant as second operator.</p>
<h1>Loop Commands (<code>LOOPx</code>, <code>JCXZ</code>)</h1>
<p>All loop commands accept an displacement operator (8-bit).</p>
<p>None of the loop commands affects any flags!</p>
<h2>Loop (<code>LOOP</code>)</h2>
<p>Decrements <em>CX</em> by one (1). If <em>CX</em> is not zero (<em>CX</em> <span class="math">\(\neq\)</span> 0) it performs the jump.</p>
<h2>Loop while equal and Loop while zero (<code>LOOPE</code>, <code>LOOPZ</code>)</h2>
<p><code>LOOPE</code> and <code>LOOPZ</code> are different mnemonics for the same command.</p>
<p>Decrements <em>CX</em> by one (1). Performs the jump if if Zero Flag is set and <em>CX</em> is not zero (0).</p>
<p>Jump if: ZF <span class="math">\(=\)</span> 1 and CX <span class="math">\(\neq\)</span> 0</p>
<h2>Loop while not equal and Loop while not zero (<code>LOOPNE</code>, <code>LOOPNZ</code>)</h2>
<p><code>LOOPNE</code> and <code>LOOPNZ</code> are different mnemonics for the same command.</p>
<p>Decrements <em>CX</em> by one (1). Performs the jump if if Zero Flag is not set and <em>CX</em> is not zero (0).</p>
<p>Jump if: ZF <span class="math">\(=\)</span> 0 and CX <span class="math">\(\neq\)</span> 0</p>
<h2>Jump if <em>CX</em> zero (<code>JCXZ</code>)</h2>
<p>Performs the jump if <em>CX</em> is zero.</p>
<p>Jump if: CX <span class="math">\(=\)</span> 0</p>
<h1>Stack and Function calls</h1>
<p>The stack on x86 is always addressed by the Stack Segment (<em>SS</em>).</p>
<p>Stack operations are word aligned (16-bit). So <code>PUSH</code> decrements <em>SP</em> by <em>2</em> and
<code>POP</code> increments <em>SP</em> by <em>2</em>.</p>
<p><em>SP</em> points to the <em>last written</em> word.</p>
<h2>Push and Pop (<code>PUSH</code>, <code>PUSHF</code>, <code>PUSHA</code>, <code>POP</code>, <code>POPF</code>, <code>POPA</code>)</h2>
<p>The different push and pop commands save/restore 16-bit words to/from the stack.</p>
<h3><code>PUSH</code></h3>
<p><code>PUSH</code> can be called with all registers as as operands or a memory operand. Immediate addressing
is not possible with <code>PUSH</code>.</p>
<p>The registers that can be pushed are: <em>AX</em>, <em>BX</em>, <em>CX</em>, <em>DX</em>, <em>SP</em>, <em>BP</em>, <em>SI</em>, <em>DI</em>, <em>ES</em>, <em>SS</em>, <em>DS</em> and <em>CS</em>.</p>
<h3><code>POP</code></h3>
<p><code>POP</code> can use the same operands as <code>PUSH</code> with the exception of <em>CS</em>. Memory operands are also possible.</p>
<p>The registers that can be poped are: <em>AX</em>, <em>BX</em>, <em>CX</em>, <em>DX</em>, <em>SP</em>, <em>BP</em>, <em>SI</em>, <em>DI</em>, <em>ES</em>, <em>SS</em> and <em>DS</em>.</p>
<h3><code>PUSHA</code> and <code>POPA</code></h3>
<p>With the commands <code>PUSHA</code> and <code>POPA</code> (introduced with 80186) the 8 working registers are pushed to the stack and
poped in the reversed order:</p>
<p><em>AX</em>, <em>CX</em>, <em>DX</em>, <em>BX</em>, <em>SP+</em>, <em>BP</em>, <em>SI</em>, <em>DI</em></p>
<p><em>SP+</em> is the <em>SP</em> before the first push to the stack. With <code>POPA</code> <em>SP</em> is not poped. Is is just decremented (by 2) at
the end of all the pop operations.</p>
<h3><code>PUSHF</code> and <code>POPF</code></h3>
<p><code>PUSHF</code> and <code>POPF</code> push and pop the flag register to/from the stack.</p>
<h3>Examples</h3>
<div class="highlight"><pre><span class="nf">PUSH</span> <span class="nv">result</span>   <span class="c1">; variable result</span>
<span class="nf">PUSH</span> <span class="p">[</span><span class="nb">BX</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span>   <span class="c1">; memory word at address [BX+7]</span>
<span class="nf">PUSH</span> <span class="nv">tab</span><span class="p">[</span><span class="nb">SI</span><span class="p">]</span>  <span class="c1">; memory word at address tab[SI]</span>
<span class="nf">POP</span> <span class="nb">AX</span>        <span class="c1">; value from stack to AX</span>
</pre></div>


<h2><code>CALL</code> and <code>RET</code></h2>
<p><code>CALL</code> stores the return address (address of the instruction after <code>CALL</code>) on the stack, increments <em>SP</em> (by 2)
and calls the function.</p>
<p><code>RET</code> returns from the function by loading the stored address in to <em>IP</em> and decrements <em>SP</em> (by 2).</p>
<h2>Defining a Function</h2>
<p>In <a href="http://left404.com/2011/01/04/converting-x86-assembly-from-masm-to-nasm-3/">NASM</a> a function is defined as follows:</p>
<div class="highlight"><pre><span class="nl">my_func:</span>

<span class="c1">; code of the function...</span>

<span class="nf">ret</span>
</pre></div>


<p>For calling the function:</p>
<div class="highlight"><pre><span class="nf">call</span> <span class="nv">far</span> <span class="nv">my_func</span> <span class="c1">;</span>
</pre></div>


<p>The pseudo commands <code>PROC and</code>ENDP` (as in MASM/TASM) are not supported by NASM.</p>
<h3>Function Prologue</h3>
<p>At the beginning of each function some registers have to be saved. This code is called
<a href="https://en.wikipedia.org/wiki/Function_prologue">function prologue</a>.</p>
<p>The usual tasks in a function prologue are:</p>
<ul>
<li>Save old <em>BP</em> (push it on the stack).</li>
<li>Assign <em>SP</em> to <em>BP</em> (<em>PB</em> = <em>SP</em>). So the <em>BP</em> points the the old <em>BP</em>.</li>
<li>Save register contents to stack. So the registers can be used in the function.</li>
<li>Allocate memory on stack for use in function.</li>
</ul>
<p>The the actual code of the function can run.</p>
<p>Before the function ends it has to undo most of the things that were done in the prologue (i.e restoring registers,
adjusting <em>SP</em>...).
This code is called function epilogue.</p>
<h1>String Operations</h1>
<p>The x86 architecture contains some commands that can be executed on consecutive memory location (strings, arrays...).</p>
<p>This commands are powerful but not so easy to understand. <a href="http://www.oocities.org/codeteacher/x86asm/asml1013.html">Here</a> is a good explanation.</p>
<h2>Commands</h2>
<p>Mostly <em>SI</em> is used for addressing the source operator and <em>DI</em> is used for addressing the destination operator. Hence the names.
For some commands the accumulator (<em>AL</em>/<em>AX</em>) is used as operator.
<em>SI</em> is <em>DS</em>-relative by default. But the segment can be overridden.
<em>DI</em> is <em>ES</em>-relative by default. The segment can <strong>not</strong> be overridden.</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOVSx</code></td>
<td>Move (copy) data addressed by <em>SI</em> to position addressed by <em>DI</em>.</td>
</tr>
<tr>
<td><code>STOSx</code></td>
<td>Load data from accumulator to position addressed by <em>DI</em>.</td>
</tr>
<tr>
<td><code>LODSx</code></td>
<td>Load data addressed by <em>SI</em> into accumulator.</td>
</tr>
<tr>
<td><code>CMPSx</code></td>
<td>Compare data addressed by <em>SI</em> with data addressed by <em>DI</em>. Flags are set according to result of [<em>SI</em>] - [<em>DI</em>].</td>
</tr>
<tr>
<td><code>SCASx</code></td>
<td>Compare data from accumulator  with data addressed by <em>DI</em>. Flags are set according to result of accumulator - [<em>DI</em>].</td>
</tr>
</tbody>
</table>
<p>In the commands listed above <em>x</em> can be <em>B</em> for operation on bytes or <em>W</em> for operation on words (16-bit).</p>
<p>Processors 80186 and newer have also the commands: <code>INS</code> and <code>OUTS</code> for string input and output from/to ports.</p>
<h2>Direction</h2>
<p>The direction of the string commands can be controlled by the direction flag:</p>
<ul>
<li><code>CLD</code>: Clear direction flag. Index registers are incremented.</li>
<li><code>STD</code>: Set direction flag. Index registers are decremented.</li>
</ul>
<h2>Repeat Prefix</h2>
<ul>
<li><code>REP</code>: Repeat the string command as long as <em>CX</em> <span class="math">\(\neq\)</span> 0. Decrement <em>CX</em> in each iteration.</li>
<li><code>REPE</code>: Repeat while operands are equal.</li>
<li><code>REPZ</code>: Repeat while zero (ZF = 1).</li>
<li><code>REPNE</code>: Repeat while operands are <em>not</em> equal.</li>
<li><code>REPNZ</code>: Repeat while <em>not</em> zero (ZF = 0).</li>
</ul>
<blockquote>
<p>There is now practical use for <code>LODSx</code> with <code>REP</code>.</p>
</blockquote>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>