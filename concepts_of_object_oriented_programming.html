<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta name="description" content="Lukas Woodtli">
    <meta name="author" content="Lukas Woodtli">

        <title>Concepts of Object Oriented Programming · Lukas Woodtli</title>


    <!-- Bootstrap core CSS -->
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css">

    <link rel="stylesheet" href="http://bootswatch.com/yeti/bootstrap.min.css" type="text/css">

    <link rel="stylesheet" href="http://lukaswoodtli.github.io/theme/css/main.css">

    <link rel="stylesheet" href="http://lukaswoodtli.github.io/theme/css/solarized-light.css">


    <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>

    <script src="http://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>

    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

</head>

<body>
  <div class="container" id="wrap">
      <nav id="navbar" class="navbar navbar-default" role="navigation">
    <div class="container">

      <!--navbar-header-->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://lukaswoodtli.github.io">Lukas Woodtli</a>
      </div> <!--navbar-header-->

      <!-- Search Box -->

      <!--Menuitems, collapable-->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav navbar-right" id="menuitem-list">
                <li >
                  <a href="http://lukaswoodtli.github.io/index.html">Home</a>
                </li>

                <li >
                  <a href="http://lukaswoodtli.github.io/pages/cv.html">CV</a>
                </li>

              <li class="btn-group">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Skills<b class="caret"></b>
                </a>
                <ul class="dropdown-menu" role="menu">
                  <li >
                    <a href="http://lukaswoodtli.github.io/pages/skills.html">Hard Skills</a>
                  </li>
                  <li >
                    <a href="http://lukaswoodtli.github.io/pages/courses.html">Courses</a>
                  </li>
                  <li >
                    <a href="http://lukaswoodtli.github.io/pages/books.html">Books</a>
                  </li>
                  <li >
                    <a href="http://lukaswoodtli.github.io/pages/projects.html">Projects</a>
                  </li>
                </ul>
              </li>
              <li class="btn-group">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Blog<b class="caret"></b>
                </a>
                <ul class="dropdown-menu" role="menu">
                  <li >
                    <a href="http://lukaswoodtli.github.io/pages/blog.html">Blog Index</a>
                  </li>
                  <li >
                    <a href="http://lukaswoodtli.github.io/categories.html">Categories</a>
                  </li>
                  <li >
                    <a href="http://lukaswoodtli.github.io/tags.html">Tags</a>
                  </li>
                  <li >
                    <a href="http://lukaswoodtli.github.io/archives.html">Chronological</a>
                  </li>
                </ul>
              </li>
                <li >
                  <a href="http://lukaswoodtli.github.io/pages/contact.html">Contact</a>
                </li>

        </ul>
      </div><!-- /.navbar-collapse -->

    </div> <!--container-->
  </nav>


    <div class="container">
      <div class="col-md-2">
      </div>

      <div class="col-md-8">
        <div class="row">
              <div class="page-header">
        <h1><a href="http://lukaswoodtli.github.io/concepts_of_object_oriented_programming.html">Concepts of Object Oriented Programming</a></h1>
    </div>

        </div>

        <div class="row">

    <span id="article_info">
    <a class="label label-primary" 
      href="http://lukaswoodtli.github.io/category/programming.html">Programming</a>
      <b> · </b>
        <a class="label label-primary" 
          href="http://lukaswoodtli.github.io/tag/cpp.html">C++</a>
        <a class="label label-primary" 
          href="http://lukaswoodtli.github.io/tag/python.html">Python</a>
        <a class="label label-primary" 
          href="http://lukaswoodtli.github.io/tag/oop.html">OOP</a>
        <a class="label label-primary" 
          href="http://lukaswoodtli.github.io/tag/eth.html">ETH</a>
    <!--<span class="glyphicon glyphicon-calendar"></span>-->
      <b> · </b>
      <a href="http://lukaswoodtli.github.io/archives.html#Year2015">2015</a>-<a href="http://lukaswoodtli.github.io/archives.html#Year2015Month07">07</a>-<a href="http://lukaswoodtli.github.io/archives.html#Year2015Month07">27</a>

    <!--<span class="glyphicon glyphicon-user"></span>-->
      <b> · </b>
    <a href="http://lukaswoodtli.github.io/author/lukas_woodtli.html">Lukas Woodtli</a>
  </span>

  <hr/>

  <div id="article_content">
    <div class="toc">
<ul>
<li><a href="#the-object-model">The Object Model</a><ul>
<li><a href="#interfaces-and-encapsulation">Interfaces and Encapsulation</a></li>
<li><a href="#classification-and-polymorphism">Classification and Polymorphism</a><ul>
<li><a href="#classification">Classification</a></li>
<li><a href="#polymorphism">Polymorphism</a><ul>
<li><a href="#subtype-polymorphism">Subtype Polymorphism</a></li>
<li><a href="#parametric-polymorphism">Parametric Polymorphism</a></li>
<li><a href="#method-overloading">Method Overloading</a></li>
</ul>
</li>
<li><a href="#spezialization">Spezialization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#types-and-subtyping">Types and Subtyping</a><ul>
<li><a href="#types">Types</a><ul>
<li><a href="#weak-and-strong-type-systems">Weak and Strong Type Systems</a><ul>
<li><a href="#untyped-languages">Untyped Languages</a></li>
<li><a href="#weakly-typed-languages">Weakly Typed Languages</a></li>
<li><a href="#strongly-typed-languages">Strongly Typed Languages</a></li>
</ul>
</li>
<li><a href="#nominal-and-structural-types">Nominal and Structural Types</a><ul>
<li><a href="#nominal-types">Nominal Types</a></li>
<li><a href="#structural-types">Structural Types</a></li>
</ul>
</li>
<li><a href="#type-checking">Type Checking</a><ul>
<li><a href="#static-type-checking">Static Type Checking</a></li>
<li><a href="#dynamic-type-checking">Dynamic Type Checking</a></li>
</ul>
</li>
<li><a href="#overview-of-type-systems-in-oo-languages">Overview of Type Systems in OO-Languages</a></li>
</ul>
</li>
<li><a href="#subtyping">Subtyping</a><ul>
<li><a href="#variance-covariance-contravariance-and-invariance">Variance (Covariance, Contravariance and Invariance)</a><ul>
<li><a href="#covariance">Covariance</a></li>
<li><a href="#contravariance">Contravariance</a></li>
<li><a href="#variance-for-oop">Variance for OOP</a></li>
</ul>
</li>
<li><a href="#behavioral-subtyping-contracts">Behavioral Subtyping (Contracts)</a><ul>
<li><a href="#subtyping-and-contracs">Subtyping and Contracs</a></li>
</ul>
</li>
<li><a href="#types-as-contracts">Types as Contracts</a></li>
</ul>
</li>
<li><a href="#inheritance">Inheritance</a><ul>
<li><a href="#difference-between-inheritance-and-subtyping">Difference between inheritance and subtyping</a></li>
</ul>
</li>
<li><a href="#aggregation-vs-private-inheritance-c">Aggregation vs. Private Inheritance (C++)</a></li>
<li><a href="#static-and-dynamic-method-binding">Static and Dynamic Method Binding</a><ul>
<li><a href="#static-method-binding-in-java">Static Method binding in Java</a></li>
</ul>
</li>
<li><a href="#rules-for-proper-subclassing">Rules for proper Subclassing</a></li>
</ul>
</li>
<li><a href="#binary-methods">Binary Methods</a></li>
<li><a href="#multiple-inheritance">Multiple Inheritance</a><ul>
<li><a href="#problems-with-multiple-inheritance">Problems with multiple inheritance</a></li>
</ul>
</li>
<li><a href="#mixins-and-traits">Mixins and Traits</a></li>
<li><a href="#parametric-polymorphism_1">Parametric Polymorphism</a><ul>
<li><a href="#java-c">Java, C#, ...</a><ul>
<li><a href="#wildcards">Wildcards</a></li>
</ul>
</li>
<li><a href="#c-templates">C++ Templates</a></li>
</ul>
</li>
<li><a href="#information-hiding-and-encapsulation">Information Hiding and Encapsulation</a><ul>
<li><a href="#information-hiding">Information Hiding</a><ul>
<li><a href="#client-interface-of-a-class">Client Interface of a Class</a></li>
<li><a href="#other-interfaces">Other Interfaces</a></li>
<li><a href="#java-access-modifiers">Java Access Modifiers</a></li>
<li><a href="#safe-changes">Safe Changes</a></li>
<li><a href="#exchanging-implementation">Exchanging Implementation</a></li>
<li><a href="#bug-method-selection-in-java">Bug: Method Selection in Java</a></li>
</ul>
</li>
<li><a href="#encapsulation">Encapsulation</a><ul>
<li><a href="#levels-of-encapsulation">Levels of Encapsulation</a></li>
<li><a href="#achieving-consistency-of-objects">Achieving Consistency of Objects</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#object-structures">Object Structures</a><ul>
<li><a href="#examples">Examples</a></li>
<li><a href="#aliasing">Aliasing</a><ul>
<li><a href="#intended-aliasing">Intended Aliasing</a></li>
<li><a href="#unintended-aliasing">Unintended Aliasing</a><ul>
<li><a href="#capturing">Capturing</a></li>
<li><a href="#leaking">Leaking</a></li>
<li><a href="#problems-with-aliasing">Problems with Aliasing</a></li>
<li><a href="#consistency-of-object-structures">Consistency of Object Structures</a></li>
<li><a href="#other-problems-with-aliasing">Other Problems with Aliasing</a></li>
</ul>
</li>
<li><a href="#alias-control-in-java">Alias Control in Java</a><ul>
<li><a href="#linkedlist">LinkedList:</a></li>
<li><a href="#string">String</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#readonly-types">Readonly Types</a><ul>
<li><a href="#requirements-for-readonly-access">Requirements for Readonly Access</a></li>
<li><a href="#pure-methods">Pure Methods</a></li>
<li><a href="#readwrite-and-readonly-types">Readwrite and Readonly Types</a></li>
<li><a href="#transitivity-of-readonly-types">Transitivity of Readonly Types</a><ul>
<li><a href="#type-rules-readonly-access">Type Rules: Readonly Access</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#initialization-and-null-references">Initialization and Null-References</a><ul>
<li><a href="#object-initialization">Object Initialization</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="the-object-model">The Object Model</h1>
<ul>
<li>A software system is a set of cooperating objects</li>
<li>Objects have state (fields) and processing ability (methods)</li>
<li>Objects exchange messages (methods)</li>
</ul>
<p>Objects have:</p>
<ul>
<li>State</li>
<li>Identity</li>
<li>Lifecycle</li>
<li>Location</li>
<li>Behavior</li>
</ul>
<h2 id="interfaces-and-encapsulation">Interfaces and Encapsulation</h2>
<ul>
<li>Objects have well-defined interfaces<ul>
<li>Publicly accessible fields</li>
<li>Publicly accessible methods</li>
</ul>
</li>
<li>Implementation is hidden behind interface<ul>
<li>Encapsulation</li>
<li>Information hiding</li>
</ul>
</li>
<li>Interfaces are the basis for describing behavior</li>
</ul>
<h2 id="classification-and-polymorphism">Classification and Polymorphism</h2>
<ul>
<li>Classification: Hierarchical structuring of objects</li>
<li>Objects belong to different classes simultaneously</li>
<li><em>Substitution principle</em>: Subtype objects can be used wherever supertype objects are expected</li>
</ul>
<h3 id="classification">Classification</h3>
<ul>
<li>We can classify objects or fields (?)</li>
<li>Classifications can be <em>trees</em> or <em>DAGs</em></li>
<li>Classifications of objects form “is-a” relation</li>
<li>Classes can be abstract or concrete</li>
</ul>
<blockquote>
<p>Substitution Principle: Objects of subtypes can be used wherever
objects of supertypes are expected</p>
</blockquote>
<h3 id="polymorphism">Polymorphism</h3>
<h4 id="subtype-polymorphism">Subtype Polymorphism</h4>
<ul>
<li>Direct consequence of substitution principle</li>
<li>Run-time (dynamic) Polymorphism</li>
<li>Dynamic (late) binding</li>
</ul>
<h4 id="parametric-polymorphism">Parametric Polymorphism</h4>
<ul>
<li>Generic types</li>
<li>Uses <em>type parameters</em></li>
<li>One implementation can be used for different types</li>
<li>Type missmatch detected at compile time</li>
<li>i.e C++ Templates</li>
</ul>
<h4 id="method-overloading">Method Overloading</h4>
<ul>
<li>Ad-Hoc Polymorphism</li>
<li>Methods with same name but different arguments</li>
</ul>
<h3 id="spezialization">Spezialization</h3>
<ul>
<li>Start from general objects/types</li>
<li>Extend these objecs (fields and methods)</li>
<li>Behaviour of specialized objects need to be compliant to more general objects! (Substitution Principle)</li>
<li>Progam parts that work for the genral objects work also for specialized objects</li>
</ul>
<h1 id="types-and-subtyping">Types and Subtyping</h1>
<h2 id="types">Types</h2>
<p>Type systems can be analyzed in three dimensions:</p>
<ol>
<li>Weak and Strong Type Systems</li>
<li>Nominal and Structural Types</li>
<li>Static and Dynamic Type Checking</li>
</ol>
<h3 id="weak-and-strong-type-systems">Weak and Strong Type Systems</h3>
<p>How strongly or weakly typed a language is concerns casting (implicit and explicit).
It's mainly used to compare languages to each other about the possible castings, type safety and information loss.</p>
<h4 id="untyped-languages">Untyped Languages</h4>
<ul>
<li>Not classifying values into types</li>
<li>i.e. Assembler</li>
</ul>
<h4 id="weakly-typed-languages">Weakly Typed Languages</h4>
<ul>
<li>Classifying values into types</li>
<li>No strict enforcement of restrictions</li>
<li>i.e. C, C++</li>
</ul>
<h4 id="strongly-typed-languages">Strongly Typed Languages</h4>
<ul>
<li>Enforcing that all operations are applied to values of appropriate type</li>
<li>Strongly-typed languages prevent certain erroneous or undesirable program behavior</li>
<li>i.e. Java, Python, Scala, Smalltalk, Eiffel, C#</li>
</ul>
<h3 id="nominal-and-structural-types">Nominal and Structural Types</h3>
<h4 id="nominal-types">Nominal Types</h4>
<ul>
<li>Based on type names</li>
<li>i.e. C++, Java, Eiffel, Scala</li>
</ul>
<h4 id="structural-types">Structural Types</h4>
<ul>
<li>Based on available methods and fields</li>
<li>i.e. Python, Ruby, Smalltals</li>
</ul>
<h3 id="type-checking">Type Checking</h3>
<h4 id="static-type-checking">Static Type Checking</h4>
<ul>
<li>Types of variables and methods are declared explicitly or inferred</li>
<li>Types of expressions can be derived from the types of their constituents</li>
<li>Type rules are used at compile time to check whether a program is correctly typed</li>
</ul>
<blockquote>
<p>A programming language is called type-safe if its design prevents type errors</p>
</blockquote>
<h4 id="dynamic-type-checking">Dynamic Type Checking</h4>
<ul>
<li>Variables, methods, and expressions of a program are typically not typed</li>
<li>Every object and value has a type</li>
<li>Run-time system checks that operations are applied to expected arguments</li>
<li>Static languages need to performe some checks dynamically at run-time (i.e type-casting)</li>
</ul>
<h3 id="overview-of-type-systems-in-oo-languages">Overview of Type Systems in OO-Languages</h3>
<table class="table table-hover table-striped">
<thead>
<tr>
<th></th>
<th>Static</th>
<th>Dynamic</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nominal</td>
<td>C++, Java, Eiffel, Scala, C#</td>
<td>certain features of statically-typed languages</td>
</tr>
<tr>
<td>Structural</td>
<td>Research languages: O'Caml, Moby...</td>
<td>Python, JavaScript, Ruby, Smalltalk</td>
</tr>
</tbody>
</table>
<p>Dynamic and Structural is often called "duck typing".</p>
<h2 id="subtyping">Subtyping</h2>
<blockquote>
<p>Substitution  principle Objects of subtypes can be used wherever objects of supertypes are expected</p>
</blockquote>
<ul>
<li>
<p>Syntactic classification: Subtypes understand <em>at least the messages</em> of their supertypes.</p>
</li>
<li>
<p>Semantic classification: Subtypes provide <em>at least the behaviour</em> of their supertypes.</p>
</li>
</ul>
<h3 id="variance-covariance-contravariance-and-invariance">Variance (Covariance, Contravariance and Invariance)</h3>
<p>Based on substitution principle.</p>
<h4 id="covariance">Covariance</h4>
<p>Ordering of types from more specific to more generic (in direction of inheritance hierarchy)</p>
<p><img alt="Covariance" class="img-responsive" src="/images/covariance.svg"/></p>
<h4 id="contravariance">Contravariance</h4>
<p>Ordering of types from more generic to more specific (in oposite direction of inheritance hierarchy)</p>
<p><img alt="Contravariance" class="img-responsive" src="/images/contravariance.svg"/></p>
<h4 id="variance-for-oop">Variance for OOP</h4>
<p><a href="https://class.coursera.org/progfun-005/lecture/83">Coursera:Scala</a></p>
<table class="table table-hover table-striped">
<thead>
<tr>
<th></th>
<th>Variance</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input Arguments</td>
<td>Contravariant</td>
</tr>
<tr>
<td>Return Values and Exceptions</td>
<td>Covariant</td>
</tr>
<tr>
<td>In- and Output Arguments (Mutable Reference Arguments)</td>
<td>Invariant</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span class="n">SuperReturnType</span> <span class="n">Super</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="n">SubParamType</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// |         ^ contra-</span>
<span class="c1">//  ..                        ^             // |         | variant</span>
<span class="c1">//   v                        ..            // | co-     |</span>
<span class="n">SubReturnType</span>   <span class="n">Sub</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="n">SuperParamType</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// v variant |</span>
</pre></div>
<p><em>Super</em> is more <strong>general</strong> than <em>Sub</em>.</p>
<p><em>Sub</em> is more <strong>specific</strong> than <em>Super</em>.</p>
<table class="table table-hover table-striped">
<thead>
<tr>
<th>Programming Language</th>
<th>Argument Type</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++, Java, Scala, D...</td>
<td>Invariant</td>
<td>Covariant</td>
</tr>
<tr>
<td>Eiffel</td>
<td>Covariant</td>
<td>Covariant</td>
</tr>
<tr>
<td>C#</td>
<td>Invariant</td>
<td>Invariant</td>
</tr>
</tbody>
</table>
<p>In Java and C# arrays are covariant!</p>
<h3 id="behavioral-subtyping-contracts">Behavioral Subtyping (Contracts)</h3>
<p>What are the <em>properties</em> shared by the values of a type?</p>
<p><em>Properties</em> should also include the behavior of the object.
This is expressed as interface specifications (contracts)</p>
<ul>
<li>Precondition: Have to hold before the method is executed</li>
<li>Postcondition: Have to hold after the method has terminated</li>
<li>Old-expressons: Can be used to refer to prestate values from the postcondition</li>
<li>Invariant: Have to hold in al states in which an object can be accessed by other objects</li>
</ul>
<h4 id="subtyping-and-contracs">Subtyping and Contracs</h4>
<ul>
<li>Subtypes must fulfill contracts of supertypes</li>
<li>Overriding method of subtypes may have <em>weaker preconditions</em> than the supertype method</li>
<li>Overriding method of subtypes may have <em>stronger postconditions</em> than the supertype method</li>
<li>Subtypes may have <em>stronger invariants</em> than supertypes</li>
<li>Subtypes may have <em>stronger history constrains</em> than supertype</li>
</ul>
<h3 id="types-as-contracts">Types as Contracts</h3>
<p>Types can be seen as a kind of contracts.</p>
<p>Overriding Methods must:</p>
<table class="table table-hover table-striped">
<thead>
<tr>
<th>Behavioral Subtyping (contracts)</th>
<th>Nominal/Structural Subtyping (variance)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Weaker Preconditions</td>
<td>Covariant Parameters</td>
</tr>
<tr>
<td>Stronger Postconditions</td>
<td>Covariant Results</td>
</tr>
<tr>
<td>Stronger Invariants</td>
<td>Invariant fields</td>
</tr>
</tbody>
</table>
<p>This doesn't apply exactly to:</p>
<ul>
<li>Invariants/Fields</li>
<li>History constraints</li>
</ul>
<h2 id="inheritance">Inheritance</h2>
<h3 id="difference-between-inheritance-and-subtyping">Difference between inheritance and subtyping</h3>
<p>Inheritance allows to reuse the code (specialization) inside a class
(member variables and method definitions).</p>
<p>Subtyping supports reuse externally. It's used for polymorphism
in form of the substitution principle.</p>
<p>Subtyping expresses classification.</p>
<p>Subtypeing depends only on the interface of objects and not on their
implementations.</p>
<p>In most existing OOP languages inheritance also is subtyping.
C++ allows private (or protected) inheritance which does not result
in subtyping.
With interfaces (Java, C++...) it's possible to create subtypes
without inheritance (no reuse of code from parent class).
Usually the term "inherit from an interface" is used even if it's
not correct.</p>
<blockquote>
<p>Subclassing = Subtyping + Inheritance</p>
</blockquote>
<p>Inheritance is <em>not</em> a core concept of OOP.</p>
<p>OOP can do without inheritance, but not without subtyping!</p>
<h2 id="aggregation-vs-private-inheritance-c">Aggregation vs. Private Inheritance (C++)</h2>
<ul>
<li>Both solutions allow code reuse without establishing a subtype relation</li>
<li>No subtype polymorphism</li>
<li>No behavioral subtyping  equirements</li>
</ul>
<p>Aggregation causes more overhead</p>
<ul>
<li>Two objects at run-time</li>
<li>Boilerplate code for delegation</li>
<li>Access methods for protected fields</li>
</ul>
<p>Private inheritance may lead to unnecessary multiple inheritance</p>
<h2 id="static-and-dynamic-method-binding">Static and Dynamic Method Binding</h2>
<ul>
<li>Static binding: Methods are selected based on the <em>static type</em> of the
receiver <em>at compile time</em></li>
<li>Dynamic binding: Methods are selected based on the <em>dynamic type</em> of the
receiver object <em>at run time</em></li>
</ul>
<p>Dynamic method binding enables specialization and subtype polymorphism</p>
<p>Drawbacks</p>
<ul>
<li>Performance: Overhead of method look-up at run-time</li>
<li>Versioning: Dynamic binding makes it harder to evolve code
 without breaking subclasses</li>
</ul>
<p>Defaults</p>
<ul>
<li>Dynamic binding: Eiffel, Java, Scala, dynamically-typed languages</li>
<li>Static  binding: C++, C#</li>
</ul>
<h3 id="static-method-binding-in-java">Static Method binding in Java</h3>
<p>Java binds methods statically in 3 cases:</p>
<ol>
<li>Static Methods</li>
<li>Private Methods</li>
<li>Method calls on <code>super</code></li>
</ol>
<h2 id="rules-for-proper-subclassing">Rules for proper Subclassing</h2>
<ul>
<li>Use subclassing only if there is an <em>'is-a'</em> relation<ul>
<li>Syntactic and behavioral subtypes</li>
</ul>
</li>
<li>Do not rely on implementation details</li>
<li>Use precise documentation (<em>contracts</em> where possible)</li>
<li>When evolving superclasses, <em>do not mess around with dynamically-bound methods</em></li>
<li>Do not add or remove calls, or change order of calls</li>
<li>Do not specialize superclasses that are expected to change often</li>
</ul>
<h1 id="binary-methods">Binary Methods</h1>
<p>Binary methods take one explicit argument and receiver (this)</p>
<p>Often behavior should be specialized depending on the dynamic types
of <em>both</em> arguments.</p>
<p>Recall that covariant parameter types are not statically type-safe! (?)</p>
<ul>
<li>Dynamic binding for specialization based on dynamic type of <em>receiver</em></li>
<li>How to specialize on the dynamic type of the <em>explicit argument</em>?</li>
<li>Visitor Pattern: tedious to write, requires modification of superclass</li>
</ul>
<p>Some Languages Support Multiple Dispatch:</p>
<p>Method calls are bound on dynamic types of several arguments.</p>
<ul>
<li>Performance overhead</li>
<li>Extra requirements are needed to ensure there is a “unique best method” for every call</li>
</ul>
<h1 id="multiple-inheritance">Multiple Inheritance</h1>
<p>All OOP languages support multiple subtyping:</p>
<ul>
<li>One type can have several supertypes</li>
<li>Subtype relation forms a DAG</li>
</ul>
<p>Some languages support multiple inheritance.</p>
<h2 id="problems-with-multiple-inheritance">Problems with multiple inheritance</h2>
<p>Ambiguities:</p>
<ul>
<li>Superclasses may contain fields and methods with identical names and signatures</li>
<li>Which version should be available in the subclass?</li>
</ul>
<p>Repeated inheritance (diamonds):</p>
<ul>
<li>A class may inherit from a superclass more than once</li>
<li>How many copies of the superclass members are there?</li>
<li>How are the superclass fields initialized?</li>
</ul>
<h1 id="mixins-and-traits">Mixins and Traits</h1>
<p>TODO</p>
<p>...</p>
<!-- Beginning of Slides 4.2 Parametric Polymorphism p. 61 (29) -->
<!-- Beginning of Notes Week 7 p. 8 -->
<h1 id="parametric-polymorphism_1">Parametric Polymorphism</h1>
<h2 id="java-c">Java, C#, ...</h2>
<ul>
<li>Subtype relation not always desiderable</li>
<li>Generics (Java, Scala, C#)</li>
<li>Upper bounds (<code>extends</code>): Subtype of upper bound required<ul>
<li>Guarantees that a specific method can be called</li>
<li>Modular check of implementation of Generic code</li>
</ul>
</li>
<li>Generics (in Java, C#) are non-variant<ul>
<li>Covariance is unsafe when client <strong>writes</strong> to generic type argument ('input')<ul>
<li>Mutable fields</li>
<li>Method arguments</li>
</ul>
</li>
<li>Contravariance is unsafe when client <strong>reads</strong> from generic type argument ('output')<ul>
<li>Fields</li>
<li>Method results</li>
</ul>
</li>
<li>Non-variance is sometimes too restrictive</li>
</ul>
</li>
<li>Scala allows variance-annotation<ul>
<li>Positive positions ('output', <em>covariant</em>): <code>+</code><ul>
<li>Result type</li>
<li>Type of immutable fields</li>
</ul>
</li>
<li>Negative positions ('input', <em>contravariant</em>): <code>-</code><ul>
<li>Parameter type</li>
</ul>
</li>
<li>C# uses keywords <code>in</code> and <code>out</code></li>
</ul>
</li>
</ul>
<!-- End of Notes Week 7 -->
<!-- Beginning of Notes Week 8 -->
<ul>
<li>Methods can also have type arguments (i.e <code>static &lt;T&gt; void printAll(Collection&lt;T&gt; c) {...}</code>)</li>
</ul>
<h3 id="wildcards">Wildcards</h3>
<p>Wildcards can be seen as an <a href="https://en.wikipedia.org/wiki/Type_system#Existential_types">Existential Type</a>:</p>
<div class="highlight"><pre><span class="kd">static</span> <span class="kt">void</span> <span class="nf">printAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">e</span> <span class="o">:</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<blockquote>
<p>There exits a type argument <code>T</code> such that <code>c</code> has type <code>collection&lt;T&gt;</code></p>
</blockquote>
<ul>
<li>
<p>Wildcards can have a <em>upper bounds</em> and <em>lower bounds</em> (correspond to <em>co- and contravariance</em>)</p>
<ul>
<li>upper bound for <em>reading</em> and method invocation: <code>extends</code></li>
<li>lower bound <em>writing</em>: <code>super</code></li>
</ul>
</li>
<li>
<p>lower bounds are not supported on type parameters (only on wildcards) in Java</p>
</li>
</ul>
<p>Instantiation of wildcards can change over time:</p>
<div class="highlight"><pre><span class="kd">class</span> <span class="nc">Wrapper</span> <span class="o">{</span>
    <span class="n">Cell</span><span class="o">&lt;?&gt;</span> <span class="n">data</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// client code:</span>
<span class="n">Wrapper</span> <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Wrapper</span><span class="o">();</span>
<span class="n">w</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span> <span class="c1">// w.data has type Cell&lt;String&gt;</span>
<span class="n">w</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Call</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;();</span> <span class="c1">// now w.data has type Cell&lt;Object&gt;!</span>
</pre></div>
<ul>
<li>
<p>Generics with wildcards (and possibly with bounds) have a subtype relation if the type parameters have a relation</p>
<ul>
<li>See <a href="https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html">Java documentation</a></li>
</ul>
</li>
<li>
<p>Type Erasure (Java, Scala)</p>
<ul>
<li>For backwards compatibility (in JVM)</li>
<li>Generic type information is erased in compiler (not available in bytecode anymore)<ul>
<li><code>C&lt;T&gt;</code> is translated to <code>C</code></li>
<li><code>T</code> is translated to its <em>upper bound</em></li>
<li>Casts are added wher nessecary (i.e reading values from generic type)</li>
<li>Only one classfile and one class object for all instantiations of a generic class</li>
<li>Run-time type information (<code>instanceof</code>, <code>List&lt;String&gt;.class</code>) is <em>missing</em></li>
<li>Arrays of generic types are <em>not possible</em> (<code>new List&lt;String&gt;[10]</code>)</li>
<li>Static fields are shared by all instantiations of a generic class</li>
<li>Lower bounds for type parameters would require support in JVM (bytecode verification)</li>
</ul>
</li>
</ul>
</li>
<li>No Type Erasure in C#<ul>
<li>Run-type type information is available</li>
<li>Arrays of generic types are possible</li>
</ul>
</li>
</ul>
<h2 id="c-templates">C++ Templates</h2>
<ul>
<li>Classes and Methods (Functions) can be parametrized</li>
<li>Also value types can be used as templates paramters</li>
<li>Instantiation generates (internally) a new class</li>
<li>Type checking is done on of the generated class, not on the template (different to Java, C#, ...)<ul>
<li>Type check only of the parts of code that are used</li>
<li>Type errors are not detectes before instantination</li>
<li>No bounds needed</li>
</ul>
</li>
<li>No subtype releation between instantiations of a template</li>
<li>No run-time support needed (templates are a compilation concept)</li>
<li>Templates can be specialized</li>
<li>Improvement for feature C++ standard (C++17): <a href="https://en.wikipedia.org/wiki/Concepts_%28C%2B%2B%29">Concepts Lite</a><ul>
<li><em>Structural</em> upper bounds (C++ type system is nominal)</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Template_metaprogramming">Template Meta Programming</a><ul>
<li>Is touring-complete!</li>
</ul>
</li>
</ul>
<!-- End of Slides 4.2 -->
<!-- End of Notes Week 8 -->
<h1 id="information-hiding-and-encapsulation">Information Hiding and Encapsulation</h1>
<p><!-- Beginning of Slides 5 -->
<!-- Beginning of Notes Week 9 --></p>
<p>In the literature Information Hiding and Encapsulation are often used synonymously.
But they are distinct but related.</p>
<h2 id="information-hiding">Information Hiding</h2>
<blockquote>
<p>Information hiding is used to reduce dependencies between modules. The client is
provided only the information needed.</p>
</blockquote>
<ul>
<li>Concerns static parts of program (code)</li>
<li>Syntactic and semantic: Contracts are part of the exported interfaces</li>
<li>Reduce dependencies<ul>
<li>Classes can be studied in isolation</li>
<li>Classes only interact in well-defined ways</li>
</ul>
</li>
</ul>
<h3 id="client-interface-of-a-class">Client Interface of a Class</h3>
<ul>
<li>Class Name</li>
<li>Type parameters (Generics) and their bounds</li>
<li>Super-interfaces</li>
<li>Signatures of exported methonds and fields</li>
<li>Client interface of <em>direct</em> superclass</li>
</ul>
<h3 id="other-interfaces">Other Interfaces</h3>
<ul>
<li>Subclass interface (i.e <code>protected</code>)</li>
<li>Friend interface (<code>friend</code> in C++, default access in Java)</li>
<li>Inner classes</li>
<li>...</li>
</ul>
<h3 id="java-access-modifiers">Java Access Modifiers</h3>
<ul>
<li><code>public</code>: client interface</li>
<li><code>protected</code>: subclass and <em>friend</em> interface</li>
<li>default access: friend interface</li>
<li><code>private</code>: implementation</li>
</ul>
<h3 id="safe-changes">Safe Changes</h3>
<ul>
<li>Renaming of hidden elements</li>
<li>Modification of hidden implementation (functionally needs to be preserved)</li>
<li>Access modifiers specify what classes might be affected by a change</li>
</ul>
<h3 id="exchanging-implementation">Exchanging Implementation</h3>
<ul>
<li>Behaviour needs to be preserved</li>
<li>Exported fields limit modification<ul>
<li>Use getters and setters</li>
<li>Uniform access (Eiffel, Scala)</li>
</ul>
</li>
<li>Modification is critical: Fragile baseclass problem!</li>
<li>Object structures</li>
</ul>
<h3 id="bug-method-selection-in-java">Bug: Method Selection in Java</h3>
<ul>
<li>
<p>Bug was present in JSL1. It's fixed now!</p>
</li>
<li>
<p>Compile time:</p>
<ol>
<li>Determin static declaration (find the method in the receiver class, method can be inherited)</li>
<li>Check accessibility</li>
<li>Determine invocation mode (virtual / non-virtual)</li>
</ol>
</li>
<li>
<p>At run-time:</p>
<ol>
<li>Compute receiver reference</li>
<li>Locate method to invoke (based on dynamic type of receiver object) that overwrites </li>
</ol>
</li>
<li>
<p>Rules for overriding</p>
<ul>
<li>Access modifier of overriding method must provide at least as much access as the overridden method</li>
<li>default access → <code>protected</code> → <code>public</code></li>
<li><code>private</code> methods can't be overridden: Hiding</li>
</ul>
</li>
</ul>
<h2 id="encapsulation">Encapsulation</h2>
<blockquote>
<p>Encapsulation is used to guarantee that data and structural consistency by capsules with well defined interfaces.</p>
</blockquote>
<ul>
<li>Data consistency: i.e value is not negatice, ...</li>
<li>
<p>Structural consistency: i.e tree is balanced, list is doubly linked, ...</p>
</li>
<li>
<p>Concerns dynamic parts of code (execution)</p>
</li>
<li>Context of a module can be changed but module behaves same</li>
</ul>
<h3 id="levels-of-encapsulation">Levels of Encapsulation</h3>
<p>Capsules can be:</p>
<ul>
<li>Individual objects</li>
<li>Object structures: i.e doubly-linked list</li>
<li>A class (with all its objects): i.e all threads in Java</li>
<li>All classes of a subtype hierarchy</li>
<li>A package with all of its classes and their objects)</li>
<li>Several packages</li>
</ul>
<p>Internal representation of capsule that needs to be proteced:</p>
<ul>
<li>invariant</li>
<li>or history constraint</li>
</ul>
<p>Hiding fields are useful for:</p>
<ul>
<li>Information Hiding</li>
<li>Encapsulation</li>
</ul>
<h3 id="achieving-consistency-of-objects">Achieving Consistency of Objects</h3>
<ol>
<li>Apply information hiding wherever possible</li>
<li>Make consistency criteria explicit<ul>
<li>Contracts</li>
<li>Informal documentation</li>
</ul>
</li>
<li>Check interfaces (also subclass methods, i.e <code>protected</code>)<ul>
<li>Make sure they preserve documented consistency criteria</li>
</ul>
</li>
</ol>
<!-- End of Slides 5 -->
<h1 id="object-structures">Object Structures</h1>
<!-- Beginnning of Slides 6 -->
<blockquote>
<p>An object structure is a set of objects that are connected via references.</p>
</blockquote>
<h2 id="examples">Examples</h2>
<ul>
<li>Array-Based Lists</li>
<li>Doubly-Linked Lists (<code>java.util</code>)</li>
</ul>
<h2 id="aliasing">Aliasing</h2>
<ul>
<li>
<p>A reference to memory location</p>
<ul>
<li>Aliasing occures if more than one variable allows access to the same memory location</li>
</ul>
</li>
<li>
<p>Static/Dynamic Aliases</p>
<ul>
<li>Static alias: all involved variables are in the heap</li>
<li>Dynamic aliasing: some involved variables are stack-allocated (others can be in the heap)</li>
</ul>
</li>
</ul>
<h3 id="intended-aliasing">Intended Aliasing</h3>
<ul>
<li>Efficiency<ul>
<li>Objects need not to be copied, when passed or modified</li>
</ul>
</li>
<li>Sharing<ul>
<li>Share the same object between different places</li>
<li>Consequence of objects identity</li>
</ul>
</li>
</ul>
<h3 id="unintended-aliasing">Unintended Aliasing</h3>
<h4 id="capturing">Capturing</h4>
<ul>
<li>Get a reference from outside and store it<ul>
<li>Often in constructors that take reference arguments</li>
</ul>
</li>
</ul>
<h4 id="leaking">Leaking</h4>
<ul>
<li>
<p>Passing a reference to an (internal) data structure to the outside</p>
</li>
<li>
<p>More frequent then capturing</p>
</li>
</ul>
<h4 id="problems-with-aliasing">Problems with Aliasing</h4>
<ul>
<li>Aliases can be used to by-pass interface</li>
<li>Interfaces and contracts remains unchanged but observable behaviour can change!</li>
</ul>
<h4 id="consistency-of-object-structures">Consistency of Object Structures</h4>
<ul>
<li>Consistency of object structures debend on several fields (not only one)</li>
<li>Checking invariance on beginning and end of method is not enough<ul>
<li>State can be changed in between by an alias</li>
</ul>
</li>
</ul>
<h4 id="other-problems-with-aliasing">Other Problems with Aliasing</h4>
<ul>
<li>Synchronization in concurrent programs<ul>
<li>Lock protects data structure</li>
<li>Locking a reference dosen't lock aliases</li>
</ul>
</li>
<li>Distributed programming<ul>
<li>i.e Remote Method Invocation</li>
<li>References (intended aliases) are lost</li>
</ul>
</li>
<li>Optimizations<ul>
<li>i.e Inlining is not possible for aliased objects</li>
</ul>
</li>
</ul>
<h3 id="alias-control-in-java">Alias Control in Java</h3>
<h4 id="linkedlist"><code>LinkedList</code>:</h4>
<ul>
<li>All fields are <code>private</code></li>
<li><code>Entry</code> is <em>private inner class</em> of <code>LinkedList</code><ul>
<li>References are not passed out</li>
<li>Subclasses cannot manipulate or leak <code>Entry</code> objects</li>
</ul>
</li>
<li><code>ListItr</code> is <em>private inner class</em> of <code>LinkedList</code><ul>
<li>Interface <code>ListIterator</code> provides controlled access to <code>ListItr</code> objects</li>
<li><code>ListItr</code>objects are passed out in a controlled way</li>
<li>Subclasses cannot manipulate or lead <code>ListItr</code> objects</li>
</ul>
</li>
<li>Subclassing is restricted!</li>
</ul>
<h4 id="string"><code>String</code></h4>
<ul>
<li>All fields are <code>private</code></li>
<li>References to internal char-array are not passed out</li>
<li>Subclassing is prohibited (<code>final</code>)</li>
</ul>
<!-- End Notes Week 9 -->
<h2 id="readonly-types">Readonly Types</h2>
<!-- Beginning of Notes Week 10 -->
<ul>
<li>Restrict access to shared objects</li>
<li>Common: grant read-only access</li>
<li>Cloning can prevent aliasing in some cases (but is inefficient)</li>
</ul>
<h3 id="requirements-for-readonly-access">Requirements for Readonly Access</h3>
<ul>
<li>Mutabla objects<ul>
<li>Only some clients can mutate object</li>
<li>Access restrictions apply to references (not whole objects)</li>
</ul>
</li>
<li>Prevent field updates, calls of mutating objects</li>
<li>
<p>Transitivity</p>
</li>
<li>
<p>Possible solution: wrap objects in readonly objects or use a readonly interface</p>
<ul>
<li>Not practical</li>
<li>Not safe: no compiler checks, readwrite alias can still occur, ...</li>
</ul>
</li>
</ul>
<blockquote>
<p>Readonly access in C++ is not transitive</p>
</blockquote>
<h3 id="pure-methods">Pure Methods</h3>
<p>Pure methods are side-effect free.</p>
<ul>
<li>Must not contain field updates</li>
<li>Must not invoke non-pure methods</li>
<li>Must not create objects (on heap)</li>
<li>Can be only overridden by pure methods</li>
<li>Stronger constraints than const methods in C++</li>
</ul>
<p>Pure methods are very restrictive:</p>
<ol>
<li>Not possible to get an iterator (which is created on heap) to iterate over collection</li>
<li>Caches can't be implemented</li>
<li>Lazy initialization is not possible</li>
</ol>
<h3 id="readwrite-and-readonly-types">Readwrite and Readonly Types</h3>
<ul>
<li>Concerns only reference type (object type is always mutable)</li>
<li>Readwrite type: <code>T</code></li>
<li>Readonly type: <code>readonly T</code></li>
<li>Subtype relation: <code>T</code> &lt;: <code>readonly T</code></li>
<li>Not same as relation between mutable and non-mutable types (which have no relation)</li>
<li>Readonly is transitive</li>
</ul>
<h3 id="transitivity-of-readonly-types">Transitivity of Readonly Types</h3>
<p>The type of</p>
<ul>
<li>Field access</li>
<li>Array access</li>
<li>Method invocation</li>
</ul>
<p>is determined by type combinator: ►</p>
<table class="table table-hover table-striped">
<thead>
<tr>
<th>►</th>
<th>rw T</th>
<th>ro T</th>
</tr>
</thead>
<tbody>
<tr>
<td>rw S</td>
<td>rw T</td>
<td>ro T</td>
</tr>
<tr>
<td>r0 S</td>
<td>r0 T</td>
<td>ro T</td>
</tr>
</tbody>
</table>
<h4 id="type-rules-readonly-access">Type Rules: Readonly Access</h4>
<p>....</p>
<!-- Beginning of Slides 7 -->
<!-- Beginning of Notes Week 11 p. 6 -->
<h1 id="initialization-and-null-references">Initialization and Null-References</h1>
<ul>
<li>Main Usages of Null-References<ul>
<li>Terminate recursion, list, ...</li>
<li>Initialization (i.e lazy initialization)</li>
<li>'Result not found' as a return value of a function (absence of an object)</li>
</ul>
</li>
<li>Most (80%) of all variables in an OOP programm are <em>non-null</em> after initalization</li>
<li>Real need for null value is rare</li>
<li>Theoretical type system:<ul>
<li>Non-null tye: <code>T!</code> (references to <code>T</code>-Object)</li>
<li>Possibly-null type: <code>T?</code> (references to <code>T</code>-Object plus <strong>null</strong>)</li>
<li>Subtype relations (S &lt;: T)<ul>
<li>S! &lt;: T!</li>
<li>S? &lt;: T?</li>
<li>T! &lt;: T?</li>
<li>Dereferencing only possible with non-null type (<code>T!</code>)</li>
<li>Possible casts:<ul>
<li>Implicit: From non-null to possibly-null (<code>T! nn = ...; T? pn = nn;</code>)</li>
<li>Downcasts (explicit) are possible but need <em>run-time</em> checks (<code>T? pn = ...; T! nn = (T!)pn;</code> Shortcut for <code>(T!)</code>: <code>(!)</code>)</li>
<li>Additional type rules (compared to Java): Expressions whose value gets dereferenced need <em>non-null</em> type<ul>
<li>Receiver of: field access, array access, method call</li>
<li>Expressions of a <code>throw</code> statement</li>
</ul>
</li>
<li>Dataflow Analysis<ul>
<li>Check if a value at a given position in code can or can't be <em>null</em></li>
<li>Tracks values of local variables but not of objects on the <em>heap</em><ul>
<li>Tracking heap locations is non-moduler</li>
<li>Other threads could modify heap locations</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="object-initialization">Object Initialization</h2>
<ul>
<li>All fields are initialized to null (Java, C#, ...)</li>
<li>Invariant of non-null types is violated at beginning of constructor (it's initialized to <code>null</code> by default)<ul>
<li>Make sure that all non-null fields are initialized when constructor terminates<ul>
<li>Similar to <em>Definite Assignment Rule</em> that check that local variables are assigned before first use (Java, C#)</li>
<li>Needes checks:<ul>
<li>Dereferces</li>
<li>non-null fields have non-null types</li>
<li>non-null arguments are passed non-null method parameters</li>
</ul>
</li>
<li>Not possible to check for all cases: <em>escaping the constructor</em><ul>
<li>The simple <em>Definite Assignement Rule</em> is only sound if <em>partly-initialized object do not escape</em> from constructor</li>
<li>Overly restrictive: on <em>partly-initialzed objects</em><ul>
<li>Dont call methods</li>
<li>Don't pass as argument to methods</li>
<li>Dont's store in fields or an array</li>
</ul>
</li>
</ul>
</li>
<li>Better type-system: track initialization<ul>
<li>Initialization Phases (3 types per class/interface)<ul>
<li><em>free type</em>: objects under construction (free to violate invariants, free to have null in non-null variables)</li>
<li><em>committed type</em>: object construction is completed (type of object is chaged at run-time when object is fully constructed)</li>
<li><em>unclassified type</em>: super-type of <em>free type</em> and <em>committed type</em></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!--
Initialization Phases:

    :::
    Object created          Object constructed completely
        |                     |
        v                     v
        |---------------------|----------------->
<div class="highlight"><pre>                                    time
    \--------------------/\-----------------...
         free type             committed type
    \---------------------------------------...
                     unclassified type
</pre></div>
<p>--&gt;</p>
<!-- End Notes Week 11 -->
<!-- Slides 7.2 p. 71 -->
  </div>

  <hr/>

      <ul class="pager">
        <li class="previous">
          <a href="http://lukaswoodtli.github.io/preprocessor_defines.html">
          &laquo; Newer</a>
        </li>
        <li class="next">
          <a href="http://lukaswoodtli.github.io/arrays_in_c_and_cpp.html">
          Older &raquo;</a>
        </li>
      </ul>


        </div>

        <div class="row">
        </div>

      </div>

      <div class="col-md-2">
      </div>
    </div>


  </div>

    <nav id="footer" class="navbar navbar-default">
    <div class="container">
        <p id="footer-text" class="navbar-text text-center">
          <span id="engine">
            Compiled using
            <a href="http://docs.getpelican.com">Pelican</a>
          </span>
          <span id="theme">
            with theme
            <a href="http://github.com/yuex/pelican-chameleon">Chameleon</a>
          </span>
          <span id="bootstrap">
            on top of
            <a href="http://getbootstrap.com/">Bootstrap</a>
          </span>
        </p>
      </div>
    </div>
  </nav>


</body>
</html>