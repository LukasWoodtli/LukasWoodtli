<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Lukas Woodtli" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="Embedded Systems, OS, Linux, Unix, Programming, " />

<meta property="og:title" content="Mastering Embedded Linux Programming"/>
<meta property="og:url" content="./mastering_embedded_linux_programming.html" />
<meta property="og:description" content="Notes to the book Mastering Embedded Linux Programming My code examples can be found here: GitHub “The versions of the main packages […] are U-Boot 2015.07, Linux 4.1, Yocto Project 1.8 “Fido”, and Buildroot 2015.08” Chapter 1. Starting Out “At the heart of most embedded devices is …" />
<meta property="og:site_name" content="Lukas Woodtli" />
<meta property="og:article:author" content="Lukas Woodtli" />
<meta property="og:article:published_time" content="2018-01-20T21:39:58+01:00" />
<meta property="og:article:modified_time" content="2019-02-12T21:00:00+01:00" />
<meta name="twitter:title" content="Mastering Embedded Linux Programming">
<meta name="twitter:description" content="Notes to the book Mastering Embedded Linux Programming My code examples can be found here: GitHub “The versions of the main packages […] are U-Boot 2015.07, Linux 4.1, Yocto Project 1.8 “Fido”, and Buildroot 2015.08” Chapter 1. Starting Out “At the heart of most embedded devices is …">

        <title>Mastering Embedded Linux Programming · Lukas Woodtli
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/admonition.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/custom.css" media="screen">



    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="./"><span class=site-name>Lukas Woodtli</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href=".">Home</a></li>
                            <li><a href="./pages/resume.html">Resume</a></li>
                            <li><a href="./pages/skills.html">Skills</a></li>
                            <li><a href="./pages/books.html">Books</a></li>
                            <li><a href="./pages/courses.html">Courses</a></li>
                            <li><a href="./pages/projects.html">Projects</a></li>
                            <li><a href="./pages/blog.html">Blog</a></li>
                            <li><a href="./pages/contact.html">Contact</a></li>
                            <!-- <li ><a href="./categories">Categories</a></li> -->
                            <!-- <li ><a href="./tags">Tags</a></li> -->
                            <!-- <li ><a href="./archives">Archives</a></li> -->

                            <li><form class="navbar-search" action="./search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="./mastering_embedded_linux_programming.html"> Mastering Embedded Linux&nbsp;Programming </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#chapter-1-starting-out">Chapter 1. Starting Out</a><ul>
<li><a href="#selecting-the-right-operating-system">Selecting the right operating system</a></li>
<li><a href="#project-lifecycle">Project lifecycle</a><ul>
<li><a href="#the-four-elements-of-embedded-linux">The four elements of embedded Linux</a></li>
</ul>
</li>
<li><a href="#hardware-for-embedded-linux">Hardware for embedded Linux</a></li>
</ul>
</li>
<li><a href="#chapter-2-learning-about-toolchains">Chapter 2. Learning About Toolchains</a><ul>
<li><a href="#what-is-a-toolchain">What is a toolchain?</a><ul>
<li><a href="#types-of-toolchain-native-versus-cross-toolchain">Types of toolchain - native versus cross toolchain</a></li>
<li><a href="#cpu-architectures"><span class="caps">CPU</span> architectures</a><ul>
<li><a href="#arm-oabi-eabi-and-eabihf"><span class="caps">ARM</span> <span class="caps">OABI</span>, <span class="caps">EABI</span> and <span class="caps">EABIHF</span></a></li>
<li><a href="#gnu-prefix-tuple"><span class="caps">GNU</span> prefix tuple</a></li>
</ul>
</li>
<li><a href="#choosing-the-c-library">Choosing the C library</a></li>
</ul>
</li>
<li><a href="#finding-a-toolchain">Finding a toolchain</a></li>
<li><a href="#finding-out-about-your-cross-compiler">Finding out about your cross compiler</a></li>
<li><a href="#the-sysroot-library-and-header-files">The sysroot, library, and header files</a></li>
<li><a href="#other-tools-in-the-toolchain">Other tools in the toolchain</a></li>
<li><a href="#looking-at-the-components-of-the-c-library">Looking at the components of the C library</a></li>
<li><a href="#linking-with-libraries-static-and-dynamic-linking">Linking with libraries: static and dynamic linking</a><ul>
<li><a href="#static-libraries">Static libraries</a></li>
<li><a href="#shared-libraries">Shared libraries</a></li>
<li><a href="#understanding-shared-library-version-numbers">Understanding shared library version numbers</a></li>
</ul>
</li>
<li><a href="#the-art-of-cross-compiling">The art of cross compiling</a><ul>
<li><a href="#simple-makefiles">Simple makefiles</a></li>
<li><a href="#autotools">Autotools</a></li>
</ul>
</li>
<li><a href="#package-configuration">Package configuration</a></li>
<li><a href="#problems-with-cross-compiling">Problems with cross compiling</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
</li>
<li><a href="#chapter-3-all-about-bootloaders">Chapter 3. All About Bootloaders</a><ul>
<li><a href="#what-does-a-bootloader-do">What does a bootloader do?</a></li>
<li><a href="#the-boot-sequence">The boot sequence</a><ul>
<li><a href="#phase-1-rom-code">Phase 1: <span class="caps">ROM</span> code</a></li>
<li><a href="#phase-2-spl">Phase 2: <span class="caps">SPL</span></a></li>
<li><a href="#phase-3-tpl">Phase 3: <span class="caps">TPL</span></a></li>
</ul>
</li>
<li><a href="#booting-with-uefi-firmware">Booting with <span class="caps">UEFI</span> firmware</a><ul>
<li><a href="#phase-1">Phase 1:</a></li>
<li><a href="#phase-2">Phase 2:</a></li>
<li><a href="#phase-3">Phase 3:</a></li>
</ul>
</li>
<li><a href="#moving-from-bootloader-to-kernel">Moving from bootloader to kernel</a></li>
<li><a href="#introducing-device-trees">Introducing device trees</a><ul>
<li><a href="#device-tree-basics">Device tree basics</a></li>
<li><a href="#phandles-and-interrupts">Phandles and interrupts</a></li>
<li><a href="#compiling-a-device-tree">Compiling a device tree</a></li>
</ul>
</li>
<li><a href="#u-boot">U-Boot</a><ul>
<li><a href="#building-u-boot">Building U-Boot</a></li>
<li><a href="#installing-u-boot">Installing U-Boot</a></li>
<li><a href="#boot-image-format">Boot image format</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-4-configuring-and-building-the-kernel">Chapter 4. Configuring and Building the Kernel</a><ul>
<li><a href="#what-does-the-kernel-do">What does the kernel do?</a></li>
<li><a href="#choosing-a-kernel">Choosing a kernel</a><ul>
<li><a href="#stable-and-long-term-support-releases">Stable and long term support releases</a></li>
<li><a href="#vendor-support">Vendor support</a></li>
<li><a href="#licensing">Licensing</a></li>
</ul>
</li>
<li><a href="#building-the-kernel">Building the kernel</a><ul>
<li><a href="#getting-the-source">Getting the source</a></li>
<li><a href="#understanding-kernel-configuration-kconfig">Understanding kernel configuration - Kconfig</a></li>
<li><a href="#using-localversion-to-identify-your-kernel">Using <span class="caps">LOCALVERSION</span> to identify your kernel</a></li>
<li><a href="#kernel-modules">Kernel modules</a></li>
</ul>
</li>
<li><a href="#compiling-kbuild">Compiling - Kbuild</a><ul>
<li><a href="#finding-out-which-kernel-target-to-build">Finding out which kernel target to build</a></li>
<li><a href="#build-artifacts">Build artifacts</a></li>
<li><a href="#compiling-device-trees">Compiling device trees</a></li>
<li><a href="#compiling-modules">Compiling modules</a></li>
<li><a href="#cleaning-kernel-sources">Cleaning kernel sources</a></li>
</ul>
</li>
<li><a href="#booting-the-kernel">Booting the kernel</a><ul>
<li><a href="#early-user-space">Early user space</a></li>
<li><a href="#kernel-messages">Kernel messages</a></li>
<li><a href="#kernel-command-line">Kernel command line</a></li>
</ul>
</li>
<li><a href="#porting-linux-to-a-new-board">Porting Linux to a new board</a></li>
<li><a href="#summary_1">Summary</a></li>
</ul>
</li>
<li><a href="#chapter-5-building-a-root-filesystem">Chapter 5. Building a Root Filesystem</a><ul>
<li><a href="#what-should-be-in-the-root-filesystem">What should be in the root filesystem?</a><ul>
<li><a href="#the-directory-layout">The directory layout</a></li>
<li><a href="#posix-file-access-permissions"><span class="caps">POSIX</span> file access permissions</a></li>
<li><a href="#programs-for-the-root-filesystem">Programs for the root filesystem</a><ul>
<li><a href="#busybox-to-the-rescue">BusyBox to the rescue!</a></li>
<li><a href="#toybox-an-alternative-to-busybox">ToyBox - an alternative to BusyBox</a></li>
</ul>
</li>
<li><a href="#libraries-for-the-root-filesystem">Libraries for the root filesystem</a><ul>
<li><a href="#reducing-the-size-by-stripping">Reducing the size by stripping</a></li>
</ul>
</li>
<li><a href="#device-nodes">Device nodes</a></li>
<li><a href="#the-proc-and-sysfs-filesystems">The proc and sysfs filesystems</a><ul>
<li><a href="#mounting-filesystems">Mounting filesystems</a></li>
</ul>
</li>
<li><a href="#kernel-modules_1">Kernel modules</a></li>
</ul>
</li>
<li><a href="#transferring-the-root-filesystem-to-the-target">Transferring the root filesystem to the target</a></li>
<li><a href="#creating-a-boot-initramfs">Creating a boot initramfs</a><ul>
<li><a href="#booting-with-qemu">Booting with <span class="caps">QEMU</span></a></li>
<li><a href="#building-an-initramfs-into-the-kernel-image">Building an initramfs into the kernel image</a></li>
<li><a href="#building-an-initramfs-using-a-device-table">Building an initramfs using a device table</a></li>
<li><a href="#the-old-initrd-format">The old initrd format</a></li>
</ul>
</li>
<li><a href="#the-init-program">The init program</a><ul>
<li><a href="#adding-user-accounts-to-the-root-filesystem">Adding user accounts to the root filesystem</a></li>
</ul>
</li>
<li><a href="#a-better-way-of-managing-device-nodes">A better way of managing device nodes</a><ul>
<li><a href="#an-example-using-devtmpfs">An example using devtmpfs</a></li>
<li><a href="#an-example-using-mdev">An example using mdev</a></li>
</ul>
</li>
<li><a href="#additional-reading">Additional reading</a></li>
</ul>
</li>
<li><a href="#chapter-6-selecting-a-build-system">Chapter 6. Selecting a Build System</a><ul>
<li><a href="#build-systems">Build systems</a></li>
<li><a href="#the-yocto-project">The Yocto Project</a><ul>
<li><a href="#background">Background</a></li>
<li><a href="#configuring">Configuring</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#running-the-qemu-target">Running the <span class="caps">QEMU</span> target</a></li>
<li><a href="#layers">Layers</a><ul>
<li><a href="#bitbake-and-recipes">BitBake and recipes</a></li>
</ul>
</li>
<li><a href="#writing-an-image-recipe">Writing an image recipe</a></li>
<li><a href="#creating-an-sdk">Creating an <span class="caps">SDK</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-7-creating-a-storage-strategy">Chapter 7. Creating a Storage Strategy</a><ul>
<li><a href="#storage-options">Storage options</a><ul>
<li><a href="#nor-flash"><span class="caps">NOR</span> flash</a></li>
<li><a href="#nand-flash"><span class="caps">NAND</span> flash</a></li>
<li><a href="#managed-flash">Managed flash</a><ul>
<li><a href="#multimediacard-and-secure-digital-cards">MultiMediaCard and Secure Digital cards</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#accessing-flash-memory-from-the-bootloader">Accessing flash memory from the bootloader</a><ul>
<li><a href="#u-boot-and-nor-flash">U-Boot and <span class="caps">NOR</span> flash</a></li>
<li><a href="#u-boot-and-nand-flash">U-Boot and <span class="caps">NAND</span> flash</a></li>
<li><a href="#u-boot-and-mmc-sd-and-emmc">U-Boot and <span class="caps">MMC</span>, <span class="caps">SD</span>, and eMMC</a></li>
</ul>
</li>
<li><a href="#accessing-flash-memory-from-linux">Accessing flash memory from Linux</a><ul>
<li><a href="#memory-technology-devices">Memory technology devices</a><ul>
<li><a href="#mtd-partitions"><span class="caps">MTD</span> partitions</a></li>
<li><a href="#mtd-device-drivers"><span class="caps">MTD</span> device drivers</a></li>
<li><a href="#the-mtd-character-device-mtd">The <span class="caps">MTD</span> character device, mtd</a></li>
<li><a href="#logging-kernel-oops-to-mtd">Logging kernel oops to <span class="caps">MTD</span></a></li>
<li><a href="#simulating-nand-memory">Simulating <span class="caps">NAND</span> memory</a></li>
</ul>
</li>
<li><a href="#the-mmc-block-driver">The <span class="caps">MMC</span> block driver</a></li>
</ul>
</li>
<li><a href="#filesystems-for-flash-memory">Filesystems for flash memory</a></li>
<li><a href="#filesystems-for-nor-and-nand-flash-memory">Filesystems for <span class="caps">NOR</span> and <span class="caps">NAND</span> flash memory</a><ul>
<li><a href="#jffs2"><span class="caps">JFFS2</span></a><ul>
<li><a href="#creating-a-jffs2-filesystem">Creating a <span class="caps">JFFS2</span> filesystem</a></li>
</ul>
</li>
<li><a href="#yaffs2"><span class="caps">YAFFS2</span></a><ul>
<li><a href="#creating-a-yaffs2-filesystem">Creating a <span class="caps">YAFFS2</span> filesystem</a></li>
</ul>
</li>
<li><a href="#ubi-and-ubifs"><span class="caps">UBI</span> and <span class="caps">UBIFS</span></a><ul>
<li><a href="#ubi"><span class="caps">UBI</span></a></li>
<li><a href="#ubifs"><span class="caps">UBIFS</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#filesystems-for-managed-flash">Filesystems for managed flash</a><ul>
<li><a href="#flashbench">Flashbench</a></li>
<li><a href="#ext4">Ext4</a></li>
</ul>
</li>
<li><a href="#read-only-compressed-filesystems">Read-only compressed filesystems</a><ul>
<li><a href="#squashfs">squashfs</a></li>
</ul>
</li>
<li><a href="#temporary-filesystems">Temporary filesystems</a></li>
<li><a href="#making-the-root-filesystem-read-only">Making the root filesystem read-only</a></li>
</ul>
</li>
<li><a href="#chapter-8-updating-software-in-the-field">Chapter 8. Updating Software in the Field</a><ul>
<li><a href="#what-to-update">What to update?</a><ul>
<li><a href="#bootloader">Bootloader</a></li>
</ul>
</li>
<li><a href="#kernel">Kernel</a><ul>
<li><a href="#root-filesystem">Root filesystem</a></li>
<li><a href="#system-applications">System applications</a></li>
<li><a href="#device-specific-data">Device-specific data</a></li>
</ul>
</li>
<li><a href="#the-basics-of-software-update">The basics of software update</a><ul>
<li><a href="#making-updates-robust">Making updates robust</a></li>
<li><a href="#making-updates-fail-safe">Making updates fail-safe</a></li>
<li><a href="#making-updates-secure">Making updates secure</a></li>
</ul>
</li>
<li><a href="#types-of-update-mechanism">Types of update mechanism</a><ul>
<li><a href="#symmetric-image-update">Symmetric image update</a></li>
<li><a href="#asymmetric-image-update">Asymmetric image update</a></li>
<li><a href="#atomic-file-updates">Atomic file updates</a></li>
</ul>
</li>
<li><a href="#ota-updates"><span class="caps">OTA</span> updates</a></li>
<li><a href="#summary_2">Summary</a></li>
</ul>
</li>
<li><a href="#chapter-9-interfacing-with-device-drivers">Chapter 9. Interfacing with Device Drivers</a><ul>
<li><a href="#the-role-of-device-drivers">The role of device drivers</a></li>
<li><a href="#character-devices">Character devices</a></li>
<li><a href="#block-devices">Block devices</a></li>
<li><a href="#network-devices">Network devices</a></li>
<li><a href="#finding-out-about-drivers-at-runtime">Finding out about drivers at runtime</a><ul>
<li><a href="#getting-information-from-sysfs">Getting information from sysfs</a><ul>
<li><a href="#the-devices-sysdevices">The devices: /sys/devices</a></li>
<li><a href="#the-drivers-sysclass">The drivers: /sys/class</a><ul>
<li><a href="#the-block-drivers-sysblock">The block drivers: /sys/block</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#finding-the-right-device-driver">Finding the right device driver</a></li>
<li><a href="#device-drivers-in-user-space">Device drivers in user space</a><ul>
<li><a href="#gpio"><span class="caps">GPIO</span></a><ul>
<li><a href="#handling-interrupts-from-gpio">Handling interrupts from <span class="caps">GPIO</span></a></li>
</ul>
</li>
<li><a href="#leds">LEDs</a></li>
<li><a href="#i2c">\(I^2C\)</a></li>
<li><a href="#serial-peripheral-interface-spi">Serial Peripheral Interface (<span class="caps">SPI</span>)</a></li>
</ul>
</li>
<li><a href="#writing-a-kernel-device-driver">Writing a kernel device driver</a><ul>
<li><a href="#designing-a-character-driver-interface">Designing a character driver interface</a></li>
<li><a href="#compiling-kernel-modules">Compiling kernel modules</a></li>
<li><a href="#loading-kernel-modules">Loading kernel modules</a></li>
</ul>
</li>
<li><a href="#discovering-the-hardware-configuration">Discovering the hardware configuration</a><ul>
<li><a href="#linking-hardware-with-device-drivers">Linking hardware with device drivers</a></li>
</ul>
</li>
<li><a href="#summary_3">Summary</a></li>
</ul>
</li>
<li><a href="#chapter-10-starting-up-the-init-program">Chapter 10. Starting Up - The init Program</a><ul>
<li><a href="#after-the-kernel-has-booted">After the kernel has booted</a></li>
<li><a href="#busybox-init">BusyBox init</a></li>
<li><a href="#system-v-init">System V init</a><ul>
<li><a href="#inittab">inittab</a></li>
<li><a href="#the-initd-scripts">The init.d scripts</a></li>
<li><a href="#starting-and-stopping-services">Starting and stopping services</a></li>
</ul>
</li>
<li><a href="#systemd">systemd</a><ul>
<li><a href="#introducing-targets-services-and-units">Introducing targets, services, and units</a><ul>
<li><a href="#units">Units</a></li>
<li><a href="#services">Services</a></li>
<li><a href="#targets">Targets</a></li>
</ul>
</li>
<li><a href="#how-systemd-boots-the-system">How systemd boots the system</a></li>
<li><a href="#adding-a-watchdog">Adding a watchdog</a></li>
</ul>
</li>
<li><a href="#summary_4">Summary</a></li>
</ul>
</li>
<li><a href="#chapter-11-managing-power">Chapter 11. Managing Power</a><ul>
<li><a href="#measuring-power-usage">Measuring power usage</a></li>
<li><a href="#scaling-the-clock-frequency">Scaling the clock frequency</a><ul>
<li><a href="#the-cpufreq-driver">The CPUFreq driver</a></li>
</ul>
</li>
<li><a href="#selecting-the-best-idle-state">Selecting the best idle state</a><ul>
<li><a href="#the-cpuidle-driver">The CPUIdle driver</a></li>
<li><a href="#tickless-operation">Tickless operation</a></li>
</ul>
</li>
<li><a href="#powering-down-peripherals">Powering down peripherals</a></li>
<li><a href="#putting-the-system-to-sleep">Putting the system to sleep</a><ul>
<li><a href="#power-states">Power states</a></li>
<li><a href="#wakeup-events">Wakeup events</a></li>
<li><a href="#timed-wakeups-from-the-real-time-clock">Timed wakeups from the real-time clock</a></li>
</ul>
</li>
<li><a href="#summary_5">Summary</a></li>
</ul>
</li>
<li><a href="#chapter-12-learning-about-processes-and-threads">Chapter 12. Learning About Processes and Threads</a><ul>
<li><a href="#processes">Processes</a><ul>
<li><a href="#terminating-a-process">Terminating a process</a></li>
<li><a href="#running-a-different-program">Running a different program</a></li>
<li><a href="#inter-process-communication">Inter-process communication</a><ul>
<li><a href="#summary-of-message-based-ipc">Summary of message-based <span class="caps">IPC</span></a></li>
<li><a href="#shared-memory-based-ipc">Shared memory-based <span class="caps">IPC</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#threads">Threads</a><ul>
<li><a href="#creating-a-new-thread">Creating a new thread</a></li>
<li><a href="#terminating-a-thread">Terminating a thread</a></li>
<li><a href="#compiling-a-program-with-threads">Compiling a program with threads</a></li>
<li><a href="#changing-conditions">Changing conditions</a></li>
</ul>
</li>
<li><a href="#scheduling">Scheduling</a><ul>
<li><a href="#fairness-versus-determinism">Fairness versus determinism</a></li>
<li><a href="#time-shared-policies">Time-shared policies</a><ul>
<li><a href="#niceness">Niceness</a></li>
</ul>
</li>
<li><a href="#real-time-policies">Real-time policies</a></li>
<li><a href="#choosing-a-real-time-priority">Choosing a real-time priority</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-13-managing-memory">Chapter 13. Managing Memory</a><ul>
<li><a href="#virtual-memory-basics">Virtual memory basics</a></li>
<li><a href="#kernel-space-memory-layout">Kernel space memory layout</a><ul>
<li><a href="#how-much-memory-does-the-kernel-use">How much memory does the kernel use?</a></li>
</ul>
</li>
<li><a href="#user-space-memory-layout">User space memory layout</a></li>
<li><a href="#the-process-memory-map">The process memory map</a></li>
<li><a href="#swapping">Swapping</a></li>
<li><a href="#mapping-memory-with-mmap">Mapping memory with mmap</a><ul>
<li><a href="#using-mmap-to-access-device-memory">Using mmap to access device memory</a></li>
</ul>
</li>
<li><a href="#how-much-memory-does-my-application-use">How much memory does my application use?</a></li>
<li><a href="#per-process-memory-usage">Per-process memory usage</a><ul>
<li><a href="#using-smem">Using smem</a></li>
</ul>
</li>
<li><a href="#identifying-memory-leaks">Identifying memory leaks</a><ul>
<li><a href="#mtrace">mtrace</a></li>
</ul>
</li>
<li><a href="#running-out-of-memory">Running out of memory</a></li>
</ul>
</li>
<li><a href="#chapter-14-debugging-with-gdb">Chapter 14. Debugging with <span class="caps">GDB</span></a><ul>
<li><a href="#preparing-to-debug">Preparing to debug</a></li>
<li><a href="#debugging-applications">Debugging applications</a><ul>
<li><a href="#remote-debugging-using-gdbserver">Remote debugging using gdbserver</a></li>
</ul>
</li>
<li><a href="#starting-to-debug">Starting to debug</a><ul>
<li><a href="#connecting-gdb-and-gdbserver">Connecting <span class="caps">GDB</span> and gdbserver</a></li>
<li><a href="#setting-the-sysroot">Setting the sysroot</a></li>
</ul>
</li>
<li><a href="#just-in-time-debugging">Just-in-time debugging</a></li>
<li><a href="#debugging-forks-and-threads">Debugging forks and threads</a></li>
<li><a href="#core-files">Core files</a><ul>
<li><a href="#using-gdb-to-look-at-core-files">Using <span class="caps">GDB</span> to look at core files</a></li>
</ul>
</li>
<li><a href="#debugging-kernel-code">Debugging kernel code</a><ul>
<li><a href="#debugging-kernel-code-with-kgdb">Debugging kernel code with kgdb</a></li>
<li><a href="#debugging-modules">Debugging modules</a></li>
<li><a href="#debugging-kernel-code-with-kdb">Debugging kernel code with kdb</a></li>
<li><a href="#looking-at-an-oops">Looking at an Oops</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-15-profiling-and-tracing">Chapter 15. Profiling and Tracing</a><ul>
<li><a href="#poor-mans-profiler">Poor man’s profiler</a></li>
<li><a href="#introducing-perf">Introducing perf</a><ul>
<li><a href="#configuring-the-kernel-for-perf">Configuring the kernel for perf</a></li>
<li><a href="#profiling-with-perf">Profiling with perf</a></li>
<li><a href="#call-graphs">Call graphs</a></li>
<li><a href="#perf-annotate">perf annotate</a></li>
</ul>
</li>
<li><a href="#introducing-ftrace">Introducing Ftrace</a></li>
<li><a href="#using-lttng">Using LTTng</a><ul>
<li><a href="#using-lttng-for-kernel-tracing">Using LTTng for kernel tracing</a></li>
</ul>
</li>
<li><a href="#using-valgrind">Using Valgrind</a><ul>
<li><a href="#callgrind">Callgrind</a></li>
<li><a href="#helgrind">Helgrind</a></li>
</ul>
</li>
<li><a href="#using-strace">Using strace</a></li>
</ul>
</li>
<li><a href="#chapter-16-real-time-programming">Chapter 16. Real-Time Programming</a><ul>
<li><a href="#what-is-real-time">What is real time?</a></li>
<li><a href="#identifying-sources-of-non-determinism">Identifying sources of non-determinism</a></li>
<li><a href="#kernel-preemption">Kernel preemption</a></li>
<li><a href="#the-real-time-linux-kernel-preempt_rt">The real-time Linux kernel (PREEMPT_RT)</a><ul>
<li><a href="#threaded-interrupt-handlers">Threaded interrupt handlers</a></li>
</ul>
</li>
<li><a href="#preemptible-kernel-locks">Preemptible kernel locks</a><ul>
<li><a href="#getting-the-preempt_rt-patches">Getting the PREEMPT_RT patches</a></li>
</ul>
</li>
<li><a href="#high-resolution-timers">High-resolution timers</a></li>
<li><a href="#avoiding-page-faults">Avoiding page faults</a></li>
<li><a href="#interrupt-shielding">Interrupt shielding</a></li>
<li><a href="#measuring-scheduling-latencies">Measuring scheduling latencies</a><ul>
<li><a href="#cyclictest">cyclictest</a></li>
<li><a href="#using-ftrace">Using Ftrace</a></li>
<li><a href="#combining-cyclictest-and-ftrace">Combining cyclictest and Ftrace</a></li>
</ul>
</li>
<li><a href="#summary_6">Summary</a></li>
</ul>
</li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
            <p>Notes to the book <a href="https://www.packtpub.com/networking-and-servers/mastering-embedded-linux-programming">Mastering Embedded Linux Programming</a></p>
<p>My code examples can be found here: <a href="https://github.com/LukasWoodtli/MasteringEmbeddedLinuxProgramming">GitHub</a></p>
<p><em><span class="dquo">“</span>The versions of the main packages […] are U-Boot 2015.07, Linux 4.1, Yocto Project 1.8 “Fido”, and Buildroot 2015.08”</em></p>

<h1 id="chapter-1-starting-out">Chapter 1. Starting Out</h1>
<p><em><span class="dquo">“</span>At the heart of most embedded devices is a highly integrated chip that contains one or more processor cores and interfaces with main memory, mass storage, and peripherals of many types. This is referred to as a System on Chip, or SoC”</em></p>
<h2 id="selecting-the-right-operating-system">Selecting the right operating system</h2>
<p><em><span class="dquo">“</span>Some things to consider</em></p>
<ul>
<li><em>Is your hardware up to the job? Compared to a traditional <span class="caps">RTOS</span> […], Linux requires a lot more resources. It needs at least a 32-bit processor, and lots more memory.</em></li>
<li><em>Do you have the right skill set? […] detailed knowledge of Linux and how it relates to your hardware.</em></li>
<li><em>Is your system real-time? Linux can handle many real-time activities so long as you pay attention to certain details”</em></li>
</ul>
<h2 id="project-lifecycle">Project lifecycle</h2>
<p><em><span class="dquo">“</span>Four sections that reflect the phases of a project. The phases are not necessarily sequential.”</em></p>
<ul>
<li><em><span class="dquo">“</span>set up the development environment and create a working platform for the later phases. “board bring-up” phase.”</em></li>
<li><em><span class="dquo">“</span>System architecture and design choices […] storage of programs and data, how to divide work between kernel device drivers and applications, and how to initialize the system.”</em></li>
<li><em><span class="dquo">“</span>Writing embedded applications […] Linux process and threads model and how to manage memory in a resource-constrained device.”</em></li>
<li><em><span class="dquo">“</span>Debugging and optimizing performance […] trace, profile, and debug your code in both the applications and the kernel.”</em></li>
</ul>
<p><em><span class="dquo">“</span>Debugging and optimizing performance (chapters 12 and 13) describe how to trace, profile, and debug your code in both the applications and the kernel.”</em></p>
<h3 id="the-four-elements-of-embedded-linux">The four elements of embedded Linux</h3>
<ul>
<li><em><span class="dquo">“</span>Toolchain: This consists of the compiler and other tools needed to create code for your target device. Everything else depends on the toolchain.”</em></li>
<li><em><span class="dquo">“</span>Bootloader: This is necessary to initialize the board and to load and boot the Linux kernel.”</em></li>
<li><em><span class="dquo">“</span>Kernel: This is the heart of the system, managing system resources and interfacing with hardware.”</em></li>
<li><em><span class="dquo">“</span>Root filesystem: This contains the libraries and programs”</em></li>
</ul>
<h2 id="hardware-for-embedded-linux">Hardware for embedded Linux</h2>
<p><em><span class="dquo">“</span>[In] source code for Linux 4.1, there are 30 architectures, each represented by a sub-directory in the <code>arch/</code> directory. They are all 32- or 64-bit architectures, most with a </em><em>memory management unit (<span class="caps">MMU</span>)</em><em>, but some without.”</em></p>
<p><em><span class="dquo">“</span>There is another group that doesn’t have an <span class="caps">MMU</span> that runs a subset of Linux known as micro controller Linux or uClinux.”</em></p>
<p><em><span class="dquo">“</span>[Linux needs] a reasonable amount of <span class="caps">RAM</span>. 16 MiB is a good minimum”</em></p>
<p><em><span class="dquo">“</span>[We need] non-volatile storage, usually flash memory. 8 MiB is enough for a simple device”</em></p>
<p><em><span class="dquo">“</span>Linux has extensive support for flash storage devices, including raw <span class="caps">NOR</span> and <span class="caps">NAND</span> flash chips and managed flash in the form of <span class="caps">SD</span> cards, eMMC chips, <span class="caps">USB</span> flash memory”</em></p>
<p><em><span class="dquo">“</span>A debug port is very useful, most commonly an <span class="caps">RS</span>-232 serial port. It does not have to be fitted on production boards, but makes board bring-up, debugging, and development much easier.”</em></p>
<p><em><span class="dquo">“</span>[We] need some means of loading software when starting from scratch. [For example <span class="caps">JTAG</span>] but modern SoCs have the ability to load boot code directly from removable media, especially <span class="caps">SD</span> and micro <span class="caps">SD</span> cards, or serial interfaces such as <span class="caps">RS</span>-232 or <span class="caps">USB</span>.”</em></p>
<h1 id="chapter-2-learning-about-toolchains">Chapter 2. Learning About Toolchains</h1>
<h2 id="what-is-a-toolchain">What is a toolchain?</h2>
<p><em><span class="dquo">“</span>A standard <span class="caps">GNU</span> toolchain consists of three main components:”</em></p>
<ul>
<li><a href="http://www.gnu.org/software/binutils/">Binutils</a>: Assembler, linker, (ld) and other tools</li>
<li><a href="http://gcc.gnu.org/"><span class="caps">GCC</span></a>: Compilers for C, C++, Objective-C, Objective-C++, Java, Fortran, Ada, and Go. They all use a common back-end which produces assembler code for the <span class="caps">GNU</span> assembler (<span class="caps">GAS</span>)</li>
<li><strong>C library</strong>: Standardized <span class="caps">API</span> based on <span class="caps">POSIX</span> (interface to the operating system kernel from applications)</li>
</ul>
<p><em><span class="dquo">“</span>As well as these, you will need a copy of the Linux kernel headers,”</em></p>
<p><em><span class="dquo">“</span>of the header files in the include directory of your kernel source code. Those headers are intended for use in the kernel only and contain definitions that will cause conflicts if used in their raw state to compile regular Linux applications. Instead, you will need to generate a set of sanitized kernel headers”</em></p>
<h3 id="types-of-toolchain-native-versus-cross-toolchain">Types of toolchain - native versus cross toolchain</h3>
<p><em><span class="dquo">“</span>here are two types of toolchain:</em></p>
<ul>
<li><em>Native: This toolchain runs on the same type of system […] This is the usual case for desktops and servers, and it is becoming popular on certain classes of embedded devices. […]</em></li>
<li><em>Cross: This toolchain runs on a different type of system than the target, allowing the development to be done on a fast desktop <span class="caps">PC</span> and then loaded onto the embedded target for testing.”</em></li>
</ul>
<p><em><span class="dquo">“</span>Almost all embedded Linux development is done using a cross development toolchain, partly because most embedded devices are not well suited to program development since they lack computing power, memory, and storage, but also because it keeps the host and target environments separate.”</em></p>
<p><em><span class="dquo">“</span>there is a counter argument in favor of native development. Cross development creates the burden of cross-compiling all the libraries and tools that you need for your target.”</em></p>
<h3 id="cpu-architectures"><span class="caps">CPU</span> architectures</h3>
<p><em><span class="dquo">“</span>toolchain has to be built according to the capabilities of the target <span class="caps">CPU</span>:</em></p>
<ul>
<li><em><span class="caps">CPU</span> architecture: arm, mips, x86_64, and so on</em></li>
<li><em>Big- or little-endian operation: Some CPUs can operate in both modes, but the machine code is different for each</em></li>
<li><em>Floating point support: Not all versions of embedded processors implement a hardware floating point unit, in which case, the toolchain can be configured to call a software floating point library instead</em></li>
<li><em>Application Binary Interface (<span class="caps">ABI</span>): The calling convention used for passing parameters between function calls”</em></li>
</ul>
<h4 id="arm-oabi-eabi-and-eabihf"><span class="caps">ARM</span> <span class="caps">OABI</span>, <span class="caps">EABI</span> and <span class="caps">EABIHF</span></h4>
<p><em><span class="dquo">“</span>With many architectures, the <span class="caps">ABI</span> is constant across the family of processors. One notable exception is <span class="caps">ARM</span>. The <span class="caps">ARM</span> architecture transitioned to the </em>Extended Application Binary Interface<em> (</em><em><span class="caps">EABI</span></em><em>) in the late 2000’s, resulting in the previous <span class="caps">ABI</span> being named the </em>Old Application Binary Interface<em> (</em><em><span class="caps">OABI</span></em><em>). While the <span class="caps">OABI</span> is now obsolete, you continue to see references to <span class="caps">EABI</span>. Since then, the </em><span class="caps">EABI</span> has split into two<em>, based on the way that floating point parameters are passed. The </em>original <span class="caps">EABI</span> uses general purpose (integer)<em> registers</em> while the <em>newer </em><em><span class="caps">EABIHF</span></em><em> uses floating point registers. The <span class="caps">EABIHF</span> is significantly faster at floating point operations since it removes the need for copying between integer and floating point registers, but it is not compatible with CPUs that do not have a floating point unit. The choice, then, is between two incompatible ABIs: </em>you cannot mix and match the two<em> and so you have to decide at this stage.”</em></p>
<h4 id="gnu-prefix-tuple"><span class="caps">GNU</span> prefix tuple</h4>
<p><em><span class="dquo">“</span><span class="caps">GNU</span> uses a prefix to the tools to identify the various combinations that can be generated, consisting of a tuple of three or four components separated by dashes:</em></p>
<ul>
<li><em><span class="caps">CPU</span>: The <span class="caps">CPU</span> architecture, such as arm, mips, or x86_64. If the <span class="caps">CPU</span> has both endian modes, they may be differentiated by adding </em><em>el for little-endian</em><em>, or </em><em>eb for big-endian</em><em>. Good examples are little-endian <span class="caps">MIPS</span>, mipsel and big-endian <span class="caps">ARM</span>, armeb.</em></li>
<li><em>Vendor: This identifies the provider of the toolchain. Examples include buildroot, poky, or just unknown. Sometimes it is left out altogether.</em></li>
<li><em>Kernel: For our purposes, it is always ‘linux’.</em></li>
<li><em>Operating system: A name for the user space component, which might be <code>gnu</code> or <code>uclibcgnu</code>. The <span class="caps">ABI</span> may be appended here as well so, for <span class="caps">ARM</span> toolchains, you may see <code>gnueabi</code>, <code>gnueabihf</code>, <code>uclibcgnueabi</code>, or <code>uclibcgnueabihf</code>.”</em></li>
</ul>
<p><em><span class="dquo">“</span>You can find the tuple used when building the toolchain by using the <code>-dumpmachine</code> option of <code>gcc</code><span class="dquo">“</span></em></p>
<h3 id="choosing-the-c-library">Choosing the C library</h3>
<p><em><span class="dquo">“</span>The programming interface to the Unix operating system is defined in the C language, which is now defined by the </em><em><span class="caps">POSIX</span></em><em> standards. The C library is the implementation of that interface”</em></p>
<p><em><span class="dquo">“</span>There are several C libraries:</em></p>
<ul>
<li><em>glibc: is the standard <span class="caps">GNU</span> C library. It is big and, until recently, not very configurable, but it is the most complete implementation</em></li>
<li><em>eglibc: This is the embedded <span class="caps">GLIBC</span>. […] the code base from eglibc has been merged back into glibc. eglibc is no longer maintained.</em></li>
<li><em>uClibc: was first developed to work with uClinux. There is a configuration utility which allows you to fine-tune its features to your needs. […] smaller than glibc</em></li>
<li><em>musl libc: is a new C library designed for embedded systems.</em>”</li>
</ul>
<p><em><span class="dquo">“</span>So, which to choose?</em></p>
<ul>
<li><em>uClibc only if you are using uClinux or if you have very limited amounts of storage or <span class="caps">RAM</span></em></li>
<li><em>Otherwise, I prefer to use an up-to-date glibc, or eglibc”</em></li>
</ul>
<h2 id="finding-a-toolchain">Finding a toolchain</h2>
<p><em><span class="dquo">“</span>three choices for your cross development toolchain:</em></p>
<ul>
<li><em>a ready built toolchain that matches your needs</em> (i.e. <a href="https://www.linaro.org/">Linaro</a> for <span class="caps">ARM</span>)</li>
<li><em>generated by an embedded build tool</em> (i.e. Yocto)</li>
<li><em>create one yourself”</em> (crosstool-ng)</li>
</ul>
<h2 id="finding-out-about-your-cross-compiler">Finding out about your cross compiler</h2>
<p><em><span class="dquo">“</span>To find the version [of gcc], you use <code>--version</code>:”</em></p>
<p><code>arm-cortex_a8-linux-gnueabi-gcc --version</code></p>
<p><em><span class="dquo">“</span>To find how [gcc] was configured, use <code>-v</code>:”</em></p>
<p><code>arm-cortex_a8-linux-gnueabi-gcc -v</code></p>
<p>The output contains (among other information):</p>
<ul>
<li><code>--with-sysroot=/home/luki/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot</code>: the default sysroot directory</li>
<li><code>--enable-languages=c,c++</code>: C and C++ languages are enabled</li>
<li><code>--with-arch=armv7-a</code>: code is generated using the <span class="caps">ARM</span> v7a instruction set</li>
<li><code>--with-cpu=cortex-a8</code> and <code>--with-tune=cortex-a8</code>: code is tweaked for Cortex A8</li>
<li><code>--with-float=hard</code>: Generate opcodes for the floating point unit and uses the <span class="caps">VFP</span> registers for parameters</li>
<li><code>--enable-threads=posix</code>: Enable <span class="caps">POSIX</span> threads</li>
</ul>
<p><em><span class="dquo">“</span>you can override the configured setting, <code>–-with-cpu</code>, by adding <code>-mcpu</code> to the command line`:”</em></p>
<p><code>arm-cortex_a8-linux-gnueabihf-gcc -mcpu=cortex-a5 helloworld.c -o helloworld</code></p>
<p><em><span class="dquo">“</span>You can print out the the range of architecture-specific options available using:”</em></p>
<p>`arm-cortex_a8-linux-gnueabihf-gcc —target-help“</p>
<h2 id="the-sysroot-library-and-header-files">The sysroot, library, and header files</h2>
<p><em><span class="dquo">“</span>The toolchain sysroot is a directory which contains subdirectories for libraries, header files, and other configuration files.”</em></p>
<p><em><span class="dquo">“</span>It can be set when the toolchain is configured through <code>--with-sysroot=</code> or it can be set on the command line, using <code>--sysroot=</code>. You can see the location of the default sysroot by using <code>-print-sysroot</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>You will find the following in the sysroot:</em>
- <em><code>lib</code>: Contains the shared objects for the C library and the dynamic linker/loader, <code>ld-linux</code></em>
- <em><code>usr/lib</code>: the static library archives for the C library and any other libraries that may be installed subsequently</em>
- <em><code>usr/include</code>: Contains the headers for all the libraries</em>
- <em><code>usr/bin</code>: Contains the utility programs that run on the target, such as the <code>ldd</code> command</em>
- <em><code>/usr/share</code>: Used for localization and internationalization</em>
- <em><code>sbin</code>: Provides the ldconfig utility, used to optimize library loading paths</em>”</p>
<p><em><span class="dquo">“</span>some of these are needed on the development host to compile programs, and others - for example the shared libraries and <code>ld-linux</code> - are needed on the target at runtime.”</em></p>
<h2 id="other-tools-in-the-toolchain">Other tools in the toolchain</h2>
<ul>
<li><code>addr2line</code>: Converts program addresses into filenames and numbers. Useful for decoding addresses from a crash report</li>
<li><code>ar</code>: used to create static libraries</li>
<li><code>as</code>: <span class="caps">GNU</span> assembler</li>
<li><code>c++filt</code>: demangle C++ and Java symbols</li>
<li><code>cpp</code>: Standalone C preprocessor</li>
<li><code>elfedit</code>: update the <span class="caps">ELF</span> header</li>
<li><code>gcov</code>: coverage tool</li>
<li><code>gdb</code>: <span class="caps">GNU</span> debugger</li>
<li><code>gprof</code>: profiling tool</li>
<li><code>ld</code>: the <span class="caps">GNU</span> linker</li>
<li><code>nm</code>: list symbols from object files</li>
<li><code>objcopy</code>: copy and translate object files</li>
<li><code>objdump</code>: display information from object files</li>
<li><code>ranlib</code>: creates or modifies an index in a static library, making the linking stage faster</li>
<li><code>readelf</code>: display information in <span class="caps">ELF</span> object files</li>
<li><code>size</code>: list section sizes</li>
<li><code>strings</code>: display printable characters in files</li>
<li><code>strip</code>: strip the debug symbols of object file</li>
</ul>
<h2 id="looking-at-the-components-of-the-c-library">Looking at the components of the C library</h2>
<p><em><span class="dquo">“</span>The C library […] is composed of four main parts”</em>:</p>
<ul>
<li><code>libc</code>: the main C library</li>
<li><code>libm</code>: matn functions</li>
<li><code>libpthread</code>: <span class="caps">POSIX</span> threads</li>
<li><code>librt</code>: real-time extensions to <span class="caps">POSIX</span></li>
</ul>
<p><em><span class="dquo">“</span><code>libc</code>, is always linked in but the others have to be explicitly linked”</em></p>
<p><em><span class="dquo">“</span>You can verify which libraries have been linked […] by using the readelf command:”</em></p>
<p>`arm-cortex_a8-linux-gnueabihf-readelf -a myprog | grep “Shared library”“</p>
<p><em><span class="dquo">“</span>Shared libraries need a run-time linker […]:”</em></p>
<p><code>arm-cortex_a8-linux-gnu eabihf-readelf -a myprog | grep "program interpreter"</code></p>
<h2 id="linking-with-libraries-static-and-dynamic-linking">Linking with libraries: static and dynamic linking</h2>
<p><em><span class="dquo">“</span>Any application […] will be linked with the C library, libc. […] Other libraries […] have to be explicitly named through the <code>-l</code> option.”</em></p>
<h3 id="static-libraries">Static libraries</h3>
<p>*”Static linking is useful in a few circumstances.</p>
<ul>
<li>building a small system which consists of only BusyBox</li>
<li>if you need to run a program before the filesystem that holds the runtime libraries is available”*</li>
</ul>
<p><em><span class="dquo">“</span>[Tell] <code>gcc</code> to link all libraries statically by adding <code>-static</code>:”</em></p>
<p><code>arm-cortex_a8-linux-gnueabihf-gcc -static helloworld.c -o helloworld-static</code></p>
<p><em><span class="dquo">“</span>the size of the binary increases dramatically”</em></p>
<h3 id="shared-libraries">Shared libraries</h3>
<p><em><span class="dquo">“</span>The object code for a shared library must be position-independent so that the runtime linker is free to locate it in memory at the next free address. To do this, add the <code>-fPIC</code> parameter to gcc, and then link it using the <code>-shared</code> option”</em></p>
<h3 id="understanding-shared-library-version-numbers">Understanding shared library version numbers</h3>
<p><em><span class="dquo">“</span>Each library has a release version and an interface number. The release version is simply a string that is appended to the library name”</em></p>
<p><em><span class="dquo">“</span>The <code>soname</code> encodes the interface number when the library was built and is used by the runtime linker when it loads the library. It is formatted as <code>&lt;library name&gt;.so.&lt;interface number&gt;</code><span class="dquo">“</span></em></p>
<p>Find the <code>soname</code>:</p>
<p><code>readelf -a &lt;path_to_so&gt; | grep SONAME</code></p>
<p>Libraries and symbolic links in a library directory (example <code>libjpeg</code>):</p>
<table class="table table-striped">
<thead>
<tr>
<th>File</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>libjpeg.a</code></td>
<td>library archive used for static linking</td>
</tr>
<tr>
<td><code>libjpeg.so -&gt; libjpeg.so.8.0.2</code></td>
<td>symbolic link, used for dynamic linking</td>
</tr>
<tr>
<td><code>libjpeg.so.8 -&gt; libjpeg.so.8.0.2</code></td>
<td>symbolic link used when loading the library at runtime</td>
</tr>
<tr>
<td><code>libjpeg.so.8.0.2</code></td>
<td>This is the actual shared library, used at both compile time and runtime</td>
</tr>
</tbody>
</table>
<p><em><span class="dquo">“</span>The first two are only needed on the host computer for building, the last two are needed on the target at runtime.”</em></p>
<p>See also: <a href="http://man7.org/linux/man-pages/man8/ldconfig.8.html"><code>ldconfig</code></a></p>
<h2 id="the-art-of-cross-compiling">The art of cross compiling</h2>
<h3 id="simple-makefiles">Simple makefiles</h3>
<p><em><span class="dquo">“</span>[For] the Linux kernel, the U-Boot bootloader, and Busybox [and others] you only need to put the toolchain prefix in the make variable <code>CROSS_COMPILE</code>, for example <code>arm-cortex_a8-linux-gnueabi-</code>. Note the trailing dash <code>-</code>.”</em></p>
<p><em><span class="dquo">“</span>In the case of U-Boot and Linux, you also have to set the <code>make</code> variable <code>ARCH</code> to one of the machine architectures they support”</em></p>
<h3 id="autotools">Autotools</h3>
<p><em><span class="dquo">“</span>Autotools, refers to a group of tools that are used as the build system in many open source projects.”</em></p>
<ul>
<li><a href="http://www.gnu.org/software/autoconf/autoconf.html"><span class="caps">GNU</span> Autoconf</a> </li>
<li><a href="http://www.gnu.org/savannah-checkouts/gnu/automake"><span class="caps">GNU</span> Automake</a></li>
<li><a href="http://www.gnu.org/software/libtool/libtool.html"><span class="caps">GNU</span> Libtool</a></li>
<li><a href="https://www.gnu.org/software/gnulib">Gnulib</a></li>
</ul>
<p><em><span class="dquo">“</span>The role of Autotools is to smooth over the differences between the many different types of system that the package may be compiled for, accounting for different versions of compilers, different versions of libraries, different locations of header files, and dependencies with other packages.”</em></p>
<p><em><span class="dquo">“</span>Packages that use Autotools come with a script named <code>configure</code> that checks dependencies and generates makefiles according to what it finds.”</em></p>
<p><em><span class="dquo">“</span>Find the options […] by running <code>./configure --help</code>.”</em></p>
<p><em><span class="dquo">“</span>Autotools is able to handle cross development as well. You can influence the behavior of the configure script by setting these shell variables:</em></p>
<ul>
<li><em><code>CC</code>: The C compiler command</em></li>
<li><em><code>CFLAGS</code>: Additional C compiler flags</em></li>
<li><em><code>LDFLAGS</code>: Additional linker flags, for example if you have libraries in a non-standard directory <code>&lt;lib dir&gt;</code> you would add it to the library search</em> path by adding <code>-L&lt;lib dir&gt;</code>*</li>
<li><em><code>LIBS</code>: Contains a list of additional libraries to pass to the linker, for instance <code>-lm</code> for the math library</em></li>
<li><em><code>CPPFLAGS</code>: Contains C/C++ preprocessor flags, for example you would add <code>-I&lt;include dir&gt;</code> to search for headers in a non-standard directory <code>&lt;include dir&gt;</code></em></li>
<li><em><code>CPP</code>: The C preprocessor to use</em>”</li>
</ul>
<p><em><span class="dquo">“</span>Autotools understands three different types of machine that may be involved when compiling a package:</em></p>
<ul>
<li><em><code>Build</code>: This is the computer that is to build the package, which defaults to the current machine.</em></li>
<li><em><code>Host</code>: This is the computer the program will run on: for a native compile this is left blank and it defaults to be the same computer as build. For a </em><em>cross compile</em><em> you set it to be the </em><em>tuple of your toolchain</em><em>.</em></li>
<li><em><code>Target</code>: This is the computer the program will generate code for: you would set this when building a cross compiler, for example.</em>”</li>
</ul>
<h2 id="package-configuration">Package configuration</h2>
<p><em><span class="dquo">“</span>Tracking package dependencies is quite complex. The package configuration utility, <a href="http://www.freedesktop.org/wiki/Software/pkg-config"><code>pkg-config</code></a> helps track which packages are installed and which compile flags each needs by keeping a database of Autotools packages in <code>[sysroot]/usr/lib/pkgconfig</code>.”</em></p>
<p><em><span class="dquo">“</span>You can use the utility pkg-config to extract information in a form that you can feed straight to gcc. In the case of a library […], you want to know the library name (<code>--libs</code>) and any special C flags (<code>--cflags</code>).”</em></p>
<p><em><span class="dquo">“</span>You need to point it at the sysroot of the target toolchain by setting the shell variable <code>PKG_CONFIG_LIBDIR</code><span class="dquo">“</span></em></p>
<p><code>PKG_CONFIG_LIBDIR=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)/usr/lib/pkgconfig pkg-config sqlite3 --libs --cflags</code></p>
<h2 id="problems-with-cross-compiling">Problems with cross compiling</h2>
<p><em><span class="dquo">“</span>Typical pain points include:</em></p>
<ul>
<li><em>Home-grown build systems, zlib, for example, has a configure script but it does not behave like the Autotools configure</em></li>
<li><em>Configure scripts that read <code>pkg-config</code> information, headers, and other files from the host, disregarding the <code>--host</code> override</em></li>
<li><em>Scripts that insist on trying to run cross compiled code</em>”</li>
</ul>
<h2 id="summary">Summary</h2>
<p><em><span class="dquo">“</span>Beware of toolchains or distributions that are offered to you for free as part of a hardware package: they are often poorly configured and not maintained. In any case, you should make the choice according to your situation, and then be consistent in its use throughout the project.”</em></p>
<h1 id="chapter-3-all-about-bootloaders">Chapter 3. All About Bootloaders</h1>
<p><em><span class="dquo">“</span>The bootloader […] starts the system up and loads the operating system kernel. […] it passes control from itself to the kernel using […] a device tree (flattened device tree or <span class="caps">FDT</span>)”</em></p>
<h2 id="what-does-a-bootloader-do">What does a bootloader do?</h2>
<p><em><span class="dquo">“</span>the bootloader has two main jobs:</em></p>
<ul>
<li><em>basic system initialization and</em></li>
<li><em>the loading of the kernel”</em></li>
</ul>
<p><em><span class="dquo">“</span>Typically, the only resources operational at the beginning [after booting] are a single <span class="caps">CPU</span> core and some on-chip static memory.”</em></p>
<h2 id="the-boot-sequence">The boot sequence</h2>
<h3 id="phase-1-rom-code">Phase 1: <span class="caps">ROM</span> code</h3>
<p><em><span class="dquo">“</span>the code that runs immediately after a reset or power-on has to be stored on-chip in the SoC; this is known as <span class="caps">ROM</span> code.
It is programmed into the chip when it is manufactured, hence <span class="caps">ROM</span> code is proprietary and cannot be replaced by an open source equivalent.”</em></p>
<p><em><span class="dquo">“</span>the only <span class="caps">RAM</span> that the <span class="caps">ROM</span> code has access to is the small amount of static <span class="caps">RAM</span> (<span class="caps">SRAM</span>) found in most SoC designs. The size of the <span class="caps">SRAM</span> varies from as little as 4 KiB up to a few hundred KiB”</em></p>
<p><em><span class="dquo">“</span>In SoCs where the <span class="caps">SRAM</span> is not large enough to load a full bootloader like U-Boot, there has to be an intermediate loader called the secondary program loader, or <span class="caps">SPL</span>”</em></p>
<p><em><span class="dquo">“</span>At the end of this phase, the next stage bootloader is present in on-chip memory and the <span class="caps">ROM</span> code jumps to the beginning of that code.”</em></p>
<h3 id="phase-2-spl">Phase 2: <span class="caps">SPL</span></h3>
<p><em><span class="dquo">“</span><span class="caps">SPL</span> must set up the memory controller and other essential parts of the system preparatory to loading the </em><em>third stage program loader (<span class="caps">TPL</span>)</em><em> into main memory, the <span class="caps">DRAM</span>”</em></p>
<p><em><span class="dquo">“</span>The <span class="caps">SPL</span> may be open source […] but it is quite common for it to contain proprietary code”</em></p>
<h3 id="phase-3-tpl">Phase 3: <span class="caps">TPL</span></h3>
<p><em><span class="dquo">“</span>At last, we are running a full bootloader like U-Boot or Barebox.”</em></p>
<p><em><span class="dquo">“</span>At the end of the third phase, there is a kernel in memory”</em></p>
<p><em><span class="dquo">“</span>Embedded bootloaders usually disappear from memory once the kernel is running”</em></p>
<h2 id="booting-with-uefi-firmware">Booting with <span class="caps">UEFI</span> firmware</h2>
<p>See also: <a href="http://www.uefi.org">Universal Extensible Firmware Interface (<span class="caps">UEFI</span>)</a></p>
<h3 id="phase-1">Phase 1:</h3>
<p><em><span class="dquo">“</span>The processor loads the <span class="caps">UEFI</span> boot manager firmware from flash memory. In some designs, it is loaded directly from <span class="caps">NOR</span> flash memory, in others there is <span class="caps">ROM</span> code on-chip which loads the boot manager from <span class="caps">SPI</span> flash memory. The boot manager is roughly equivalent to the <span class="caps">SPL</span>, but may allow user interaction through a text-based or graphical interface.”</em></p>
<h3 id="phase-2">Phase 2:</h3>
<p><em><span class="dquo">“</span>The boot manager loads the boot firmware from the </em><em><span class="caps">EFI</span> System Partition (<span class="caps">ESP</span>)</em><em> or a hard disk or <span class="caps">SSD</span>, or from a network server via <span class="caps">PXE</span> boot.”</em></p>
<p><em><span class="dquo">“</span>[…] the <span class="caps">EXP</span> is identified by a well-known <span class="caps">GUID</span> value of </em><em><span class="caps">C12A7328</span>-<span class="caps">F81F</span>-11D2-<span class="caps">BA4B</span>-<span class="caps">00A0C93EC93B</span></em><em>.”</em></p>
<p>Partition: <span class="caps">FAT32</span></p>
<p>Third stage bootloader file: <code>&lt;efi_system_partition&gt;/boot/boot&lt;machine_type_short_name&gt;.efi</code></p>
<h3 id="phase-3">Phase 3:</h3>
<p><em><span class="dquo">“</span>The <span class="caps">TPL</span> in this case has to be a bootloader that is capable of loading a Linux kernel and an optional <span class="caps">RAM</span> disk into memory. Common choices are:</em></p>
<ul>
<li><em><span class="caps">GRUB</span> 2</em></li>
<li><em>gummiboot”</em></li>
</ul>
<h2 id="moving-from-bootloader-to-kernel">Moving from bootloader to kernel</h2>
<p><em><span class="dquo">“</span>When the bootloader passes control to the kernel it has to pass some basic information to the kernel:</em></p>
<ul>
<li><em>a number unique to the type of the SoC</em></li>
<li><em>Basic details of the hardware detected so far, […] size and location of the physical <span class="caps">RAM</span>, and the <span class="caps">CPU</span> clock speed</em></li>
<li><em>The kernel command line (plain <span class="caps">ASCII</span> string)</em></li>
<li><em>Optionally, the location and size of a device tree binary</em></li>
<li><em>Optionally, the location and size of an initial <span class="caps">RAM</span> disk”</em></li>
</ul>
<p><em><span class="dquo">“</span>It is common to provide the root filesystem as a <span class="caps">RAM</span> disk, in which case it is the responsibility of the bootloader to load the <span class="caps">RAM</span> disk image into memory.”</em></p>
<p><em><span class="dquo">“</span>There is a good description of the format of the kernel source in <code>Documentation/arm/Booting</code><span class="dquo">“</span></em></p>
<h2 id="introducing-device-trees">Introducing device trees</h2>
<p>See also: <a href="https://www.devicetree.org/">www.devicetree.org</a></p>
<p><em><span class="dquo">“</span>A device tree is a flexible way to define the hardware components of a computer system. Usually, the device tree is loaded by the bootloader and passed to the kernel, although it is possible to bundle the device tree with the kernel image itself […] for bootloaders that are not capable of handling them separately.”</em></p>
<p><em><span class="dquo">“</span>The format is derived from a Sun Microsystems bootloader known as OpenBoot”</em></p>
<p><em><span class="dquo">“</span>[It] has been adapted on a large scale by the many <span class="caps">ARM</span> Linux implementations”</em></p>
<h3 id="device-tree-basics">Device tree basics</h3>
<p>There are a large number of device tree source files:</p>
<ul>
<li>Linux kernel: <code>arch/$ARCH/boot/dts</code></li>
<li>U-boot: <code>arch/$ARCH/dts</code></li>
</ul>
<p><em><span class="dquo">“</span>The device tree represents a computer system as a collection of components joined together in a hierarchy […] begins with a root node, represented by a […] <code>/</code>, which contains subsequent nodes representing the hardware of the system. Each node has a name and contains a number of properties in the form <code>name = "value"</code><span class="dquo">“</span></em></p>
<h3 id="phandles-and-interrupts">Phandles and interrupts</h3>
<p>Phandels are used to connect devices in a way that doesn’t correspond to the main tree structure.</p>
<p><em><span class="dquo">“</span>As well as the obvious data connection between a component and other parts of the system, it might also be connected to an interrupt controller, to a clock source and to a voltage regulator. To express these connections, we have phandles.”</em></p>
<p><em><span class="dquo">“</span>[The] bindings can be found in the Linux kernel source, in directory <code>Documentation/devicetree/bindings/</code>.”</em></p>
<h3 id="compiling-a-device-tree">Compiling a device tree</h3>
<p><em><span class="dquo">“</span>The bootloader and kernel require a binary representation of the device tree, so it has to be compiled using the device tree compiler, <code>dtc</code>. The result is a file ending with <code>.dtb</code>, which is referred to as a device tree binary or a device tree blob.”</em></p>
<p><em><span class="dquo">“</span><code>dtc</code> does not give helpful error messages and it makes no checks other than on the basic syntax of the language”</em></p>
<h2 id="u-boot">U-Boot</h2>
<h3 id="building-u-boot">Building U-Boot</h3>
<p><em><span class="dquo">“</span>[…] the way U-Boot is configured has undergone a lot of changes since the 2014.10 release. Double-check that the instructions you are following are appropriate.”</em></p>
<div class="highlight"><pre><span></span><code><span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf- am335x_boneblack_defconfig
make <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf-
</code></pre></div>
<p><em><span class="dquo">“</span>The results of the compilation are:</em></p>
<ul>
<li><em><code>u-boot</code>: This is U-Boot in <span class="caps">ELF</span> object format, suitable for use with a debugger</em></li>
<li><em><code>u-boot.map</code>: This is the symbol table</em></li>
<li><em><code>u-boot.bin</code>: This is U-Boot in raw binary format, suitable for running on your device</em></li>
<li><em><code>u-boot.img</code>: This is <code>u-boot.bin</code> with a U-Boot header added, suitable for uploading to a running copy of U-Boot</em></li>
<li><em><code>u-boot.srec</code>: This is U-Boot in Motorola <code>srec</code> format, suitable for transferring over a serial connection”</em></li>
</ul>
<p><em><span class="dquo">“</span>a Secondary Program Loader (<span class="caps">SPL</span>) […] is built at the same time and is named <code>MLO</code><span class="dquo">“</span></em></p>
<h3 id="installing-u-boot">Installing U-Boot</h3>
<p><em><span class="dquo">“</span>[With] <span class="caps">JTAG</span>, it is usually possible to load a copy of U-Boot directly into <span class="caps">RAM</span> and set it running. From that point, you can use U-Boot commands to copy it into flash memory.”</em></p>
<p><em><span class="dquo">“</span>Some SoC designs have a boot <span class="caps">ROM</span> built in which can be used to read boot code from various external sources such as <span class="caps">SD</span> cards, serial interfaces, or USBs”</em></p>
<p>For BeagleBone Black:</p>
<p><em><span class="dquo">“</span>two partitions: the first is 64 MiB, formatted as <span class="caps">FAT32</span> [(bootable)], and will contain the bootloader, and the second is 1 GiB, formatted as ext4”</em></p>
<p>List block devices with: <a href="http://man7.org/linux/man-pages/man8/lsblk.8.html">lsblk</a></p>
<p><em><span class="dquo">“</span>copy U-Boot and the <span class="caps">SPL</span> to [first partition of <span class="caps">SD</span> card]:”</em></p>
<div class="highlight"><pre><span></span><code>cp MLO u-boot.img /media/<span class="nv">$USER</span>/boot
</code></pre></div>
<h3 id="boot-image-format">Boot image format</h3>
<p><em><span class="dquo">“</span>Prepare files [(like the Linux kernel)] for U-Boot using the <code>mkimage</code> command.”</em></p>
<p>Example:</p>
<div class="highlight"><pre><span></span><code>mkimage -A arm -O linux -T kernel -C gzip -a 0x80008000 <span class="se">\</span>
-e 0x80008000 -n <span class="s1">'Linux'</span> -d zImage uImage
</code></pre></div>
<h1 id="chapter-4-configuring-and-building-the-kernel">Chapter 4. Configuring and Building the Kernel</h1>
<h2 id="what-does-the-kernel-do">What does the kernel do?</h2>
<p><em><span class="dquo">“</span>The system call interface uses an architecture-specific method, such as a trap or a software interrupt, to switch the <span class="caps">CPU</span> from low privilege user mode to high privilege kernel mode, which allows access to all memory addresses and <span class="caps">CPU</span> registers.”</em></p>
<p><em><span class="dquo">“</span>Interrupts can only be handled in a device driver, never by a user space application.”</em></p>
<h2 id="choosing-a-kernel">Choosing a kernel</h2>
<h3 id="stable-and-long-term-support-releases">Stable and long term support releases</h3>
<p><em><span class="dquo">“</span>[…] stable releases and long term releases. After the release of a mainline kernel (maintained by Linus Torvalds) it is moved to the stable tree (maintained by Greg Kroah-Hartman).”</em></p>
<p><em><span class="dquo">“</span>some kernels are labeled </em><em>long term</em><em> and maintained for two or more years. There is at least one long term kernel release each year.”</em></p>
<p><a href="www.kernel.org">https://www.kernel.org/</a></p>
<p><a href="kernelnewbies.org">http://kernelnewbies.org/LinuxVersions</a></p>
<h3 id="vendor-support">Vendor support</h3>
<p><em><span class="dquo">“</span>You may find support for your board or SoC from independent open source projects, Linaro or the Yocto Project, for example, or from companies providing third party support for embedded Linux, but in many cases you will be obliged to look to the vendor of your SoC or board for a working kernel.”</em></p>
<h3 id="licensing">Licensing</h3>
<p><em><span class="dquo">“</span>The Linux source code is licensed under <span class="caps">GPL</span> v2”</em></p>
<p><em><span class="dquo">“</span>it is now accepted practice that the <span class="caps">GPL</span> does not </em><em>necessarily</em><em> apply to kernel modules. This is codified by the kernel <code>MODULE_LICENSE</code> macro, which may take the value <code>Proprietary</code> to indicate that it is not released under the <span class="caps">GPL</span>.”</em></p>
<p>*”[…] an oft-quoted e-mail thread titled “Linux <span class="caps">GPL</span> and binary module exception clause?” which is archived at <a href="http://yarchive.net">http://yarchive.net/comp/linux/gpl_modules.html</a></p>
<h2 id="building-the-kernel">Building the kernel</h2>
<h3 id="getting-the-source">Getting the source</h3>
<p><em><span class="dquo">“</span>The main directories of interest are:</em></p>
<ul>
<li><code>arch</code>: <em>architecture-specific files, one subdirectory per architecture.</em></li>
<li><code>Documentation</code>: *kernel documentation. Always look here first *</li>
<li><code>drivers</code>: <em>device drivers, a subdirectory for each type of driver.</em></li>
<li><code>fs</code>: <em>filesystem code.</em></li>
<li><code>include</code>: <em>kernel header files, including those required when building the toolchain.</em></li>
<li><code>init</code>: <em>the kernel start-up code.</em></li>
<li><code>kernel</code>: <em>core functions, including scheduling, locking, timers, power management, and debug/trace code.</em></li>
<li><code>mm</code>: <em>memory management.</em></li>
<li><code>net</code>: <em>network protocols.</em></li>
<li><code>scripts</code>: <em>many useful scripts, including the device tree compiler, <span class="caps">DTC</span>.</em></li>
<li><code>tools</code>: <em>many useful tools.”</em></li>
</ul>
<h3 id="understanding-kernel-configuration-kconfig">Understanding kernel configuration - Kconfig</h3>
<p>*”The value you put into <code>ARCH</code> is one of the subdirectories you find in directory arch, with the oddity that <code>ARCH=i386</code> and <code>ARCH=x86_64</code> both source <code>arch/x86/Kconfig</code>.</p>
<p>*”[search function] in <code>menuconfig</code> by pressing the forward slash key, <code>/</code><span class="dquo">“</span>.</p>
<p><em><span class="dquo">“</span>There are a set of known working configuration files in <code>arch/$ARCH/configs</code>, each containing suitable configuration values for a single SoC or a group of SoCs.”</em></p>
<p><em><span class="dquo">“</span>[There is a] target named <code>oldconfig</code>. This takes an existing <code>.config</code> file and asks you to supply configuration values for any options that don’t have them. You would use it when moving a configuration to a newer kernel version; copy <code>.config</code> from the old kernel to the new source directory and run the <code>make ARCH=arm oldconfig</code> command to bring it up to date. It can also be used to validate a <code>.config</code> file that you have edited manually”</em></p>
<h3 id="using-localversion-to-identify-your-kernel">Using <span class="caps">LOCALVERSION</span> to identify your kernel</h3>
<div class="highlight"><pre><span></span><code>make <span class="nv">ARCH</span><span class="o">=</span>arm kernelversion
</code></pre></div>
<p><em><span class="dquo">“</span>If you change the configuration from the default, it is advisable to append your own version information, which you can configure by setting <code>CONFIG_LOCALVERSION</code><span class="dquo">“</span></em></p>
<h3 id="kernel-modules">Kernel modules</h3>
<p><em><span class="dquo">“</span>[A] few cases where kernel modules are a good idea in embedded systems:</em></p>
<ul>
<li><em>proprietary modules</em></li>
<li><em>reduce boot time by deferring the loading of non-essential drivers</em></li>
<li><em>[it] would take up too much memory to compile [all drivers] statically</em></li>
</ul>
<h2 id="compiling-kbuild">Compiling - Kbuild</h2>
<h3 id="finding-out-which-kernel-target-to-build">Finding out which kernel target to build</h3>
<p><em><span class="dquo">“</span>To build a kernel image, you need to know what your bootloader expects.</em></p>
<ul>
<li><strong>U-Boot</strong>: <em>Traditionally, U-Boot has required <code>uImage</code>, but newer versions can load a <code>zImage</code> file using the <code>bootz</code> command</em></li>
<li><strong>x86 targets</strong>: <em>Requires a <code>bzImage</code>file</em></li>
<li><strong>Most other bootloaders</strong>: <em>Require a <code>zImage</code> file”</em></li>
</ul>
<p><em><span class="dquo">“</span>There is a small issue with building a uImage file for <span class="caps">ARM</span> with multi-platform support […]. It allows a single kernel binary to run on multiple platforms and is a step on the road toward having a small number of kernels for all <span class="caps">ARM</span> devices. The kernel selects the correct platform by reading the machine number or the device tree passed to it by the bootloader.
The problem occurs because the location of physical memory might be different for each platform, and so the relocation address for the kernel (usually <code>0x8000</code> bytes from the start of physical <span class="caps">RAM</span>) might also be different.”</em></p>
<p><em><span class="dquo">“</span>The <code>uImage</code> format is not compatible with multi-platform images.”</em></p>
<p><em><span class="dquo">“</span>You can still create a uImage binary from a multi-platform build, so long as you give the <code>LOADADDR</code> of the particular SoC you are hoping to boot this kernel on. You can find the load address by looking in <code>mach -[your SoC]/Makefile.boot</code> and noting the value of <code>zreladdr-y</code>:”</em></p>
<div class="highlight"><pre><span></span><code><span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf- <span class="nv">LOADADDR</span><span class="o">=</span>0x80008000 uImage
</code></pre></div>
<h3 id="build-artifacts">Build artifacts</h3>
<p><em><span class="dquo">“</span>If you have compiled your kernel with debug enabled (<code>CONFIG_DEBUG_INFO=y</code>), it will contain debug symbols which can be used with debuggers like <code>kgdb</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span><code>System.map</code> contains the symbol table in a human readable form.”</em></p>
<p><em><span class="dquo">“</span>Most bootloaders cannot handle <span class="caps">ELF</span> code directly. There is a further stage of processing which takes vmlinux and places those binaries in `arch/$<span class="caps">ARCH</span>/boot that are suitable for the various bootloaders:</em></p>
<ul>
<li><code>Image</code>: <em><code>vmlinux</code> converted to raw binary format.</em></li>
<li><code>zImage</code>: <em>For the PowerPC architecture, this is just a compressed version of <code>Image</code> […] the bootloader must do the decompression. For all other architectures, [<code>Image</code> contains] a stub of code that decompresses and relocates it.</em></li>
<li><code>uImage</code>: <em><code>zImage</code> plus a 64-byte U-Boot header.</em>”</li>
</ul>
<h3 id="compiling-device-trees">Compiling device trees</h3>
<p><em><span class="dquo">“</span>The <code>dtbs</code> target builds device trees according to the rules in <code>arch/$ARCH/boot/dts/Makefile</code><span class="dquo">“</span></em> , using the device tree source files in that directory.”*</p>
<div class="highlight"><pre><span></span><code>make <span class="nv">ARCH</span><span class="o">=</span>arm dtbs
</code></pre></div>
<p><em><span class="dquo">“</span>The compiled <code>.dtb</code> files are generated in the same directory as the sources.”</em></p>
<h3 id="compiling-modules">Compiling modules</h3>
<p><em><span class="dquo">“</span>Build [modules] separately using the <code>modules</code> target:”</em></p>
<div class="highlight"><pre><span></span><code>make -j <span class="m">4</span> <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf- modules
</code></pre></div>
<p><em><span class="dquo">“</span>The compiled modules have a <code>.ko</code> suffix and are generated in the same directory as the source code”</em></p>
<p><em><span class="dquo">“</span>Use the <code>modules_install</code> <code>make</code> target to install them in the right place.”</em></p>
<p><em><span class="dquo">“</span>To install them into the staging area of your root filesystem […], provide the path using <code>INSTALL_MOD_PATH</code>:”</em></p>
<div class="highlight"><pre><span></span><code><span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf- <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span><span class="nv">$HOME</span>/rootfs modules_install
</code></pre></div>
<h3 id="cleaning-kernel-sources">Cleaning kernel sources</h3>
<p>Make targets:</p>
<ul>
<li><span class="dquo">“</span><code>clean</code>: <em>Removes object files and most intermediates.</em></li>
<li><code>mrproper</code>: <em>Removes all intermediate files, including the <code>.config</code> file. [Return] the source tree to the state it was in immediately after cloning</em></li>
<li><code>distclean</code>: <em>This is the same as <code>mrproper</code>, but also deletes editor backup files, patch files, and other artifacts of software development.</em>”</li>
</ul>
<h2 id="booting-the-kernel">Booting the kernel</h2>
<h3 id="early-user-space">Early user space</h3>
<p><em><span class="dquo">“</span>In order to transition from kernel initialization to user space, the kernel has to mount a root filesystem and execute a program in that root filesystem. This can be achieved via a ramdisk or by mounting a real filesystem on a block device.”</em></p>
<p><em><span class="dquo">“</span>The code for all of this is in <code>init/main.c</code>, starting with the function <code>rest_init()</code>, which creates the first thread with <span class="caps">PID</span> 1 and runs the code in <code>kernel_init()</code>.”</em></p>
<p><em><span class="dquo">“</span>If there is a ramdisk, it will try to execute the program <code>/init</code> […]. If fails to find and run <code>/init</code>, it tries to mount a filesystem by calling the function <code>prepare_namespace()</code> in <code>init/do_mounts.c</code>. This requires a <code>root=</code> command line to give the name of the block device to use for mounting, usually in the form:”</em></p>
<div class="highlight"><pre><span></span><code><span class="nv">root</span><span class="o">=</span>/dev/&lt;disk name&gt;&lt;partition number&gt;
</code></pre></div>
<p><em><span class="dquo">“</span>Or, for <span class="caps">SD</span> cards and eMMC:”</em></p>
<div class="highlight"><pre><span></span><code><span class="nv">root</span><span class="o">=</span>/dev/&lt;disk name&gt;p&lt;partition number&gt;
</code></pre></div>
<p><em><span class="dquo">“</span>If the mount succeeds, it will try to execute <code>/sbin/init</code>, followed by <code>/etc/init</code>, <code>/bin/init</code>, and then <code>/bin/sh</code>, stopping at the first one that works.”</em></p>
<h3 id="kernel-messages">Kernel messages</h3>
<table class="table table-striped">
<thead>
<tr>
<th>Level</th>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>KERN_EMERG</td>
<td>0</td>
<td>The system is unusable</td>
</tr>
<tr>
<td>KERN_ALERT</td>
<td>1</td>
<td>Action must be taken immediately</td>
</tr>
<tr>
<td>KERN_CRIT</td>
<td>2</td>
<td>Critical conditions</td>
</tr>
<tr>
<td>KERN_ERR</td>
<td>3</td>
<td>Error conditions</td>
</tr>
<tr>
<td>KERN_WARNING</td>
<td>4</td>
<td>Warning conditions</td>
</tr>
<tr>
<td>KERN_NOTICE</td>
<td>5</td>
<td>Normal but significant conditions</td>
</tr>
<tr>
<td>KERN_INFO</td>
<td>6</td>
<td>Informational</td>
</tr>
<tr>
<td>KERN_DEBUG</td>
<td>7</td>
<td>Debug-level messages</td>
</tr>
</tbody>
</table>
<p><em><span class="dquo">“</span>They are first written to a buffer, <code>__log_buf</code>, the size of which is two to the power of <code>CONFIG_LOG_BUF_SHIFT</code>.”</em></p>
<p><em><span class="dquo">“</span>You can dump the entire buffer using the command <code>dmesg</code>.”</em></p>
<p><em><span class="dquo">“</span>The default console log level is <code>7</code>, meaning that messages of level <code>6</code> and lower are displayed”</em></p>
<h3 id="kernel-command-line">Kernel command line</h3>
<p><em><span class="dquo">“</span>[The kernel command line string can be set] via the <code>bootargs</code> variable in the case of U-Boot; it can also be defined in the device tree, or set as part of the kernel configuration in <code>CONFIG_CMDLINE</code>.”</em></p>
<p><em><span class="dquo">“</span>There is a complete list in <code>Documentation/kernel-parameters.txt</code><span class="dquo">“</span></em></p>
<ul>
<li><code>debug</code>: Sets the console log level to the highest level <code>8</code></li>
<li><code>init=</code>: The init program to run from a mounted root filesystem (default: <code>/sbin/init</code>)</li>
<li><code>lpj=</code>: Sets <code>loops_per_jiffy</code> to a given constant</li>
<li><code>panic=</code> when the kernel panics: if the value is greater than zero, it gives the number of seconds before rebooting; if it is zero, it waits forever (default); or if it is less than zero, it reboots without any delay.</li>
<li><code>quiet</code> suppressing all but emergency messages</li>
<li><code>rdinit=</code>: The init program to run from a ramdisk (defaults: <code>/init</code>)</li>
<li><code>ro</code>: Mounts the root device as read-only (no effect on a ramdisk)</li>
<li><code>root=</code>: Device to mount the root filesystem</li>
<li>
<p><code>rootdelay=</code>: The number of seconds to wait before trying to mount the root device (default: zero)</p>
</li>
<li>
<p><code>rootfstype=</code>: The filesystem type for the root device. In many cases, it is auto-detected (required for <code>jffs2</code> filesystems)</p>
</li>
<li><code>rootwait</code>: Waits indefinitely for the root device to be detected. Usually necessary with mmc devices.</li>
<li><code>rw</code>: Mounts the root device as read-write (default).</li>
</ul>
<p><em><span class="dquo">“</span>During initialization, the kernel loops for approximately 250 ms to calibrate a delay loop. The value is stored in the variable <code>loops_per_jiffy</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>If the kernel always runs on the same hardware, it will always calculate the same value. You can shave 250 ms off the boot time by adding <code>lpj=&lt;value_reported_to_console&gt;</code> to the command line.”</em></p>
<h2 id="porting-linux-to-a-new-board">Porting Linux to a new board</h2>
<p><em><span class="dquo">“</span>The organization of architecture-specific code in <code>arch/$ARCH</code> differs from one system to another.”</em></p>
<p><em><span class="dquo">“</span>The x86 architecture is pretty clean because most hardware details are detected at runtime. […]. The <span class="caps">ARM</span> architecture, on the other hand, is quite messy, in part because there is a lot of variability between the many <span class="caps">ARM</span>-based SoCs. Platform-dependent code is put in directories named <code>mach-\*</code> , approximately one per SoC. There are other directories named <code>plat-\*</code> which contain code common to several versions of an SoC. In the case of the BeagleBone Black, the relevant directory is <code>arch/arm/mach-omap2</code>. […] it contains support for <span class="caps">OMAP2</span>, 3, and 4 chips, as well as the AM33xx family of chips that the BeagleBone uses.”</em></p>
<h2 id="summary_1">Summary</h2>
<p><em><span class="dquo">“</span>The customization of the kernel for a particular target may consist of changes to the core kernel code, additional drivers for devices that are not in mainline Linux, a default kernel configuration file, and a device tree source file.”</em></p>
<p><em><span class="dquo">“</span>One of the things you should consider […] is whether the kernel features and drivers should be compiled as modules or built-in.”</em></p>
<p><em><span class="dquo">“</span>Building the kernel produces a compressed kernel image file, named <code>zImage</code>, <code>bzImage</code>, or <code>uImage</code>, depending on the bootloader you will be using and the target architecture. A kernel build will also generate any kernel modules (as <code>.ko</code> files) that you have configured, and device tree binaries (as <code>.dtb</code> files) if your target requires them.”</em></p>
<p><em><span class="dquo">“</span>The root filesystem can be a ramdisk or a filesystem accessed via a block device,”</em></p>
<h1 id="chapter-5-building-a-root-filesystem">Chapter 5. Building a Root Filesystem</h1>
<h2 id="what-should-be-in-the-root-filesystem">What should be in the root filesystem?</h2>
<p><em><span class="dquo">“</span>The kernel will get a root filesystem, either an <code>initramfs</code>, passed as a pointer from the bootloader, or by mounting the block device given on the kernel command line by the <code>root=</code> parameter. Once it has a root filesystem, the kernel will execute the first program, by default named <code>init</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>To make a minimal root filesystem, you need these components:</em></p>
<ul>
<li><em><code>init</code>: This is the program that starts everything off, usually by running a series of scripts.</em></li>
<li><em>Shell: You need a shell to give you a command prompt but, more importantly, also to run the shell scripts called by init and other programs.</em></li>
<li><em>Daemons: A daemon is a background program that provides a service to others.</em></li>
<li><em>Shared libraries: Most programs are linked with shared libraries, and so they must be present in the root filesystem.</em></li>
<li><em>Configuration files: The configuration for <code>init</code> and other daemons is stored in a series of text files, usually in the <code>/etc</code> directory.</em></li>
<li><em>Device nodes: These are the special files that give access to various device drivers.</em></li>
<li><em><code>/proc</code> and <code>/sys</code>: These two pseudo filesystems represent kernel data structures as a hierarchy of directories and files. Many programs and library functions depend on proc and sys.</em></li>
<li><em>Kernel modules: If you have configured some parts of your kernel to be modules, they need to be installed in the root filesystem, usually in <code>/lib/modules/[kernel version]</code><span class="dquo">“</span></em></li>
</ul>
<h3 id="the-directory-layout">The directory layout</h3>
<p><em><span class="dquo">“</span>The Linux kernel does not care about the layout of files and directories beyond the existence of the program named by <code>init=</code> or <code>rdinit=</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>However, many programs expect certain files to be in certain places”</em></p>
<p><em><span class="dquo">“</span>The basic layout of a Linux system is defined in the <a href="http://refspecs.linuxfoundation.org/fhs.shtml">Filesystem Hierarchy Standard (<span class="caps">FHS</span>)</a>”</em></p>
<p><em><span class="dquo">“</span>Embedded devices tend to use a subset based on their needs, but it usually includes the following:</em></p>
<ul>
<li><code>/bin</code>: <em>Programs essential for all users</em></li>
<li><code>/dev</code>: <em>Device nodes and other special files</em></li>
<li><code>/etc</code>: <em>System configuration files</em></li>
<li><code>/lib</code>: <em>Essential shared libraries</em> [i.e. the C-library]</li>
<li><code>/proc</code>: <em>The <code>proc</code> filesystem</em></li>
<li><code>/sbin</code>: <em>Programs essential to the system administrator</em></li>
<li><code>/sys</code>: <em>The <code>sysfs</code> filesystem</em></li>
<li><code>/tmp</code>: <em>A place to put temporary or volatile files</em></li>
<li><code>/usr</code>: <em>Additional programs, libraries, and system administrator utilities, in the directories <code>/usr/bin</code>, <code>/usr/lib</code> and <code>/usr/sbin</code>, respectively</em></li>
<li><code>/var</code>: <em>A hierarchy of files and directories that may be modified at runtime, for example, log messages, some of which must be retained after boot</em>”</li>
</ul>
<p><em><span class="dquo">“</span>The difference between <code>/bin</code> and <code>/sbin</code> is simply that the latter need not be included in the search path for non-root users.”</em></p>
<p><em><span class="dquo">“</span>The significance of <code>/usr</code> is that it maybe in a separate partition from the root filesystem, so it cannot contain anything that is needed to boot the system up.”</em></p>
<h3 id="posix-file-access-permissions"><span class="caps">POSIX</span> file access permissions</h3>
<div class="math">$$\begin{matrix}
\left.\begin{matrix}
400 &amp; r &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; -\\ 
200 &amp; - &amp; w &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; -\\ 
100 &amp; - &amp; - &amp; x &amp; - &amp; - &amp; - &amp; - &amp; - &amp; -
\end{matrix}\right\} \text{Owner permissions}\\ 
\left.\begin{matrix}
040 &amp; - &amp; - &amp; - &amp; r &amp; - &amp; - &amp; - &amp; - &amp; -\\ 
020 &amp; - &amp; - &amp; - &amp; - &amp; w &amp; - &amp; - &amp; - &amp; -\\ 
010 &amp; - &amp; - &amp; - &amp; - &amp; - &amp; x &amp; - &amp; - &amp; -
\end{matrix}\right\} \text{Group permissions}\\ 
\left.\begin{matrix}
004 &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; r &amp; - &amp; -\\ 
002 &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; w &amp; -\\ 
001 &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; - &amp; x
\end{matrix}\right\} \text{World permissions}
\end{matrix}$$</div>
<p><em><span class="dquo">“</span>There is a further group of three bits that have special meanings:</em></p>
<ul>
<li><em><span class="caps">SUID</span> (4): If the file is executable, it changes the effective <span class="caps">UID</span> of the process to that of the owner of the file when the program is run.</em></li>
<li><em><span class="caps">SGID</span> (2): Similar to <span class="caps">SUID</span>, this changes the effective <span class="caps">GID</span> of the process to that of the group of the file.</em></li>
<li><em>Sticky (1): In a directory, this restricts deletion so that one user cannot delete files that are owned by another user. This is usually set on <code>/tmp</code> and <code>/var/tmp</code>.”</em></li>
</ul>
<p><em><span class="dquo">“</span>The <span class="caps">SUID</span> bit is probably used most often. It gives non-root users a temporary privilege escalation to superuser to perform a task. […] for normal users to use <code>ping</code>, [which] is owned by user <code>root</code> and has the <span class="caps">SUID</span> bit set so that when you run <code>ping</code>, it executes with <span class="caps">UID</span> 0 regardless of your <span class="caps">UID</span>.”</em></p>
<h3 id="programs-for-the-root-filesystem">Programs for the root filesystem</h3>
<h4 id="busybox-to-the-rescue">BusyBox to the rescue!</h4>
<p><em><span class="dquo">“</span>BusyBox tools implement a subset of the functions of the desktop equivalents, but they do enough of it to be useful in the majority of cases. Another trick BusyBox employs is to combine all the tools together into a single binary”</em></p>
<p><em><span class="dquo">“</span>BusyBox has over three hundred applets including an init program, several shells of varying levels of complexity, and utilities for most admin tasks. There is even a simple version of the vi editor, so you can change text files on your device.”</em></p>
<h4 id="toybox-an-alternative-to-busybox">ToyBox - an alternative to BusyBox</h4>
<p><em><span class="dquo">“</span>ToyBox has the same aim as BusyBox, but with more emphasis on complying with standards, especially <span class="caps">POSIX</span>-2008 and <span class="caps">LSB</span> 4.1”</em></p>
<p><em><span class="dquo">“</span>it implements fewer applets [than BusyBox]”</em></p>
<p><em><span class="dquo">“</span>[The] main difference is the license, which is <span class="caps">BSD</span> rather than <span class="caps">GPL</span> v2.”</em></p>
<h3 id="libraries-for-the-root-filesystem">Libraries for the root filesystem</h3>
<h4 id="reducing-the-size-by-stripping">Reducing the size by stripping</h4>
<div class="highlight"><pre><span></span><code>arm-cortex_a8-linux-gnueabihf-strip rootfs/lib/libc-2.22.so
</code></pre></div>
<blockquote>
<p>Be careful about stripping kernel modules. Some symbols are required by the module loader to relocate the module code, and so the module will fail to load if they are stripped out. Use this command to remove debug symbols while keeping those used for relocation: strip <code>--strip-unneeded &lt;module name&gt;</code>.</p>
</blockquote>
<h3 id="device-nodes">Device nodes</h3>
<p><em><span class="dquo">“</span>[…] Unix philosophy that everything is a file (except network interfaces, which are sockets).”</em></p>
<p><em><span class="dquo">“</span>Block devices are mass storage devices, such as <span class="caps">SD</span> cards or hard drives. A character device is pretty much anything else, once again with the exception of network interfaces.”</em></p>
<p><em><span class="dquo">“</span>Device nodes are created using the program named <code>mknod</code> (short for make node):</em>”</p>
<div class="highlight"><pre><span></span><code>mknod &lt;name&gt; &lt;type&gt; &lt;major&gt; &lt;minor&gt;
</code></pre></div>
<p><em><span class="dquo">“</span>The parameters to <code>mknod</code> are as follows:</em></p>
<ul>
<li><em><code>name</code> is the name of the device node that you want to create.</em></li>
<li><em><code>type</code> is either <code>c</code> for character devices or <code>b</code> for a block.</em> </li>
<li><em><code>major</code> and <code>minor</code> are a pair of numbers, which are used by the kernel to route file requests to the appropriate device driver code. There is a list of standard major and minor numbers in the kernel source in the file <code>Documentation/devices.txt</code>.”</em></li>
</ul>
<p><em><span class="dquo">“</span>In a really minimal root filesystem, you need just two nodes to boot with BusyBox: <code>console</code> and <code>null</code>.”</em></p>
<p><em><span class="dquo">“</span>The <code>console</code> only needs to be accessible to <code>root</code>, the owner of the device node, so the access permissions are <code>600</code>. The <code>null</code> device should be readable and writable by everyone, so the mode is <code>666</code>. You can use the <code>-m</code> option for <code>mknod</code> to set the mode when creating the node. You need to be <code>root</code> to create device nodes, as shown here:”</em></p>
<div class="highlight"><pre><span></span><code>sudo mknod -m <span class="m">666</span> dev/null c <span class="m">1</span> <span class="m">3</span>
sudo mknod -m <span class="m">600</span> dev/console c <span class="m">5</span> <span class="m">1</span>
</code></pre></div>
<p><em><span class="dquo">“</span>You can delete device nodes using the standard <code>rm</code> command: there is no <code>rmnod</code> command because, once created, they are just files.”</em></p>
<h3 id="the-proc-and-sysfs-filesystems">The proc and sysfs filesystems</h3>
<p><em><span class="dquo">“</span><code>proc</code> and <code>sysfs</code> are two pseudo filesystems”</em></p>
<p><em><span class="dquo">“</span>when you read one of the files [in <code>proc</code> or <code>sysfs</code>], the contents you see do not come from disk storage; it has been formatted on-the-fly by a function in the kernel. Some files are also writable, meaning that a kernel function is called with the new data you have written and, if it is of the correct format and you have sufficient permissions, it will modify the value stored in the kernel’s memory. In other words, <code>proc</code> and <code>sysfs</code> provide another way to interact with device drivers and other kernel code.”</em></p>
<p><em><span class="dquo">“</span>The <code>proc</code> and <code>sysfs</code> filesystems should be mounted on the directories called <code>/proc</code> and <code>/sys</code>:</em>”</p>
<div class="highlight"><pre><span></span><code>mount -t proc proc /proc
mount -t sysfs sysfs /sys
</code></pre></div>
<p><em><span class="dquo">“</span>[The] purpose [of <code>proc</code>] was to expose information about processes to user space”</em></p>
<p><em><span class="dquo">“</span>there is a directory for each process named <code>/proc/&lt;PID&gt;</code>, which contains information about its state.”</em></p>
<p><em><span class="dquo">“</span>there are files that give information about other parts of the kernel, for example, <code>/proc/cpuinfo</code> tells you about the <span class="caps">CPU</span>, <code>/proc/interrupts</code> has information about interrupts”</em></p>
<p><em><span class="dquo">“</span>in <code>/proc/sys</code>, there are files that display and control the state and behavior of kernel subsystems, especially scheduling, memory management, and networking.”</em></p>
<p><a href="http://man7.org/linux/man-pages/man5/proc.5.html">man 5 proc</a></p>
<p><em><span class="dquo">“</span>the role of <code>sysfs</code> is to present the kernel driver model to user space. It exports a hierarchy of files relating to devices and device drivers and the way they are connected to each other.”</em></p>
<h4 id="mounting-filesystems">Mounting filesystems</h4>
<p><em><span class="dquo">“</span>The <code>mount</code> command allows us to attach one filesystem to a directory within another, forming a hierarchy of filesystems.”</em></p>
<p><em><span class="dquo">“</span>The format of the mount command is as follows:”</em></p>
<div class="highlight"><pre><span></span><code>mount <span class="o">[</span>-t vfstype<span class="o">]</span> <span class="o">[</span>-o options<span class="o">]</span> device directory
</code></pre></div>
<p><a href="http://man7.org/linux/man-pages/man8/mount.8.html">man 8 mount</a></p>
<p><em><span class="dquo">“</span>Looking at the example of mounting the <code>proc</code> filesystem, there is something odd: there is no device node, such as <code>/dev/proc</code>, since it is a pseudo filesystem and not a real one. But the <code>mount</code> command requires a device parameter. Consequently, we have to give a string where <code>device</code> should go, but it does not matter much what that string is.”</em></p>
<h3 id="kernel-modules_1">Kernel modules</h3>
<p><em><span class="dquo">“</span>Kernel modules […] need to be installed into the root filesystem, using the kernel make target <code>modules_install</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>This will copy them into the directory called <code>/lib/modules/&lt;kernel version&gt;</code> together with the configuration files needed by the <code>modprobe</code> command.”</em></p>
<h2 id="transferring-the-root-filesystem-to-the-target">Transferring the root filesystem to the target</h2>
<p>Multiple posibilities:</p>
<ul>
<li><em><span class="dquo">“</span>initramfs: Also known as a ramdisk, […] a filesystem image that is loaded into <span class="caps">RAM</span> by the bootloader. Ramdisks are easy to create and have no dependencies on mass storage drivers. They can be used in fallback maintenance mode when the main root filesystem needs updating. They can even be used as the main root filesystem in small embedded devices, and they are commonly used as the early user space in mainstream Linux distributions. […] the contents of the root filesystem are volatile, and any changes […] will be lost when the system next boots.”</em></li>
<li><em><span class="dquo">“</span>Disk image: This is a copy of the root filesystem formatted and ready to be loaded onto a mass storage device on the target. […] Creating a disk image is probably the most common option.”</em></li>
<li><em><span class="dquo">“</span>Network filesystem: The staging directory can be exported to the network via an <span class="caps">NFS</span> server and mounted by the target at boot time. This is often done during the development phase”</em></li>
</ul>
<h2 id="creating-a-boot-initramfs">Creating a boot initramfs</h2>
<p><em><span class="dquo">“</span><code>initramfs</code> is a compressed <code>cpio</code> archive.”</em></p>
<p><em><span class="dquo">“</span>You need to configure your kernel with <code>CONFIG_BLK_DEV_INITRD</code> to support <code>initramfs</code>.”</em></p>
<p><em><span class="dquo">“</span>there are three different ways to create a boot ramdisk: as a standalone <code>cpio</code> archive, as a <code>cpio</code> archive embedded in the kernel image, and as a device table which the kernel build system processes as part of the build.”</em></p>
<h3 id="booting-with-qemu">Booting with <span class="caps">QEMU</span></h3>
<p><em><span class="dquo">“</span><span class="caps">QEMU</span> has the option called <code>-initrd</code> to load <code>initramfs</code> into memory.”</em></p>
<div class="highlight"><pre><span></span><code><span class="nv">QEMU_AUDIO_DRV</span><span class="o">=</span>none <span class="se">\</span>
qemu-system-arm -m 256M -nographic -M versatilepb <span class="se">\</span>
-kernel zImage -append <span class="s2">"console=ttyAMA0 rdinit=/bin/sh"</span> <span class="se">\</span>
-dtb versatile-pb.dtb -initrd initramfs.cpio.gz
</code></pre></div>
<h3 id="building-an-initramfs-into-the-kernel-image">Building an initramfs into the kernel image</h3>
<p><em><span class="dquo">“</span>Linux can be configured to incorporate <code>initramfs</code> into the kernel image. To do this […] set <code>CONFIG_INITRAMFS_SOURCE</code> to the full path of the <code>cpio</code> archive. […] Note that it has to be the uncompressed <code>cpio</code> file ending in <code>.cpio</code>, not the gzipped version. […] Booting is the same as before, except that there is no ramdisk file.”</em></p>
<p>For <span class="caps">QEMU</span>:</p>
<div class="highlight"><pre><span></span><code><span class="nv">QEMU_AUDIO_DRV</span><span class="o">=</span>none qemu-system-arm -m 256M <span class="se">\</span>
-nographic -M versatilepb -kernel zImage <span class="se">\</span>
-append <span class="s2">"console=ttyAMA0 rdinit=/bin/sh"</span> <span class="se">\</span>
-dtb versatile-pb.dtb
</code></pre></div>
<p>For BeagleBone Black (U-Boot):</p>
<div class="highlight"><pre><span></span><code>fatload mmc <span class="m">0</span>:1 0x80200000 zImage
fatload mmc <span class="m">0</span>:1 0x80f00000 am335x-boneblack.dtb setenv bootargs <span class="nv">console</span><span class="o">=</span>ttyO0,115200 <span class="nv">rdinit</span><span class="o">=</span>/bin/sh bootz 0x80200000 – 0x80f00000
</code></pre></div>
<h3 id="building-an-initramfs-using-a-device-table">Building an initramfs using a device table</h3>
<p><em><span class="dquo">“</span>A device table is a text file that lists the files, directories, device nodes, and links that go into an archive or filesystem image. The overwhelming advantage is that it allows you to create entries in the archive file that are owned by the <code>root</code> user, or any other <span class="caps">UID</span>, without having root privileges yourself.”</em></p>
<p><em><span class="dquo">“</span>It is only when it is expanded by Linux at boot time that real files and directories get created, using the attributes you have specified.”</em></p>
<p><em><span class="dquo">“</span>You write the device table file, and then point <code>CONFIG_INITRAMFS_SOURCE</code> at it. Then, when you build the kernel, it creates the <code>cpio</code> archive from the instructions in the device table. At no point do you need root access.”</em></p>
<p><em><span class="dquo">“</span>Creating an <code>initramfs</code> device table from scratch is made easier by a script in the kernel source code in <code>scripts/gen_initramfs_list.sh</code>, which creates a device table from a given directory.”</em></p>
<h3 id="the-old-initrd-format">The old initrd format</h3>
<p><em><span class="dquo">“</span>There is an older format for a Linux ramdisk, known as <code>initrd</code>. It was the only format available before Linux 2.6 and is still needed if you are using the mmu-less variant of Linux, uClinux. It is pretty obscure […]. There is more information in the kernel source in <code>Documentation/initrd.txt</code><span class="dquo">“</span></em></p>
<h2 id="the-init-program">The init program</h2>
<p><em><span class="dquo">“</span>The init program [of BusyBox] begins by reading the configuration file, <code>/etc/inittab</code>.”</em></p>
<h3 id="adding-user-accounts-to-the-root-filesystem">Adding user accounts to the root filesystem</h3>
<p><em><span class="dquo">“</span>Add to your staging directory the files <code>etc/passwd</code>, <code>etc/shadow</code>, and <code>etc/group</code> […]. Make sure that the permissions of <code>shadow</code> are <code>0600</code>. Next, you need to initiate the login procedure by starting a program called <code>getty</code>.”</em></p>
<h2 id="a-better-way-of-managing-device-nodes">A better way of managing device nodes</h2>
<p><em><span class="dquo">“</span>There are other ways to create device nodes automatically on demand:</em></p>
<ul>
<li><code>devtmpfs</code>: <em>This is a pseudo filesystem that you mount over <code>/dev</code> at boot time. The kernel populates it with device nodes for all the devices that the kernel currently knows about […]. Take a look at the Linux source file: <code>drivers/char/mem.c</code> and see how <code>struct memdev</code> is initialized.</em></li>
<li><code>mdev</code>: <em>This is a BusyBox applet that is used to populate a directory with device nodes and to create new nodes as needed. There is a configuration file, <code>/etc/mdev.conf</code>, which contains rules for ownership and the mode of the nodes.</em></li>
<li><code>udev</code>: This is the mainstream equivalent of <code>mdev</code>. You will find it on desktop Linux and in some embedded devices. […] It is now part of <code>systemd</code>.”*</li>
</ul>
<h3 id="an-example-using-devtmpfs">An example using devtmpfs</h3>
<p><em><span class="dquo">“</span>Support for the <code>devtmpfs</code> filesystem is controlled by kernel configuration variable: <code>CONFIG_DEVTMPFS</code>.”</em></p>
<p><em><span class="dquo">“</span>If you enable <code>CONFIG_DEVTMPFS_MOUNT</code> in your kernel configuration, the kernel will automatically mount <code>devtmpfs</code> just after mounting the root filesystem. However, this option has no effect when booting <code>initramfs</code><span class="dquo">“</span></em></p>
<h3 id="an-example-using-mdev">An example using mdev</h3>
<p><em><span class="dquo">“</span>While <code>mdev</code> is a bit more complex to set up, it does allow you to modify the permissions of device nodes as they are created. You begin by running <code>mdev</code> with the <code>-s</code> option, which causes it to scan the <code>/sys</code> directory looking for information about current devices. From this information, it populates the <code>/dev</code> directory with the corresponding nodes. If you want to keep track of new devices coming online and create nodes for them as well, you need to make <code>mdev</code> a hot plug client by writing to `/proc/sys/kernel/hotplug.”</em></p>
<p><em><span class="dquo">“</span>[It] is documented in the BusyBox source code in <code>docs/mdev.txt</code><span class="dquo">“</span></em></p>
<h2 id="additional-reading">Additional reading</h2>
<ul>
<li><a href="http://refspecs.linuxfoundation.org/fhs.shtml">Filesystem Hierarchy Standard, Version 3.0</a></li>
<li><em>ramfs</em>, <em>rootfs</em> and <em>initramfs</em>, Rob Landley, October 17, 2005, which is part of the Linux source in <code>Documentation/filesystems/ramfs-rootfs-initramfs.txt</code></li>
</ul>
<h1 id="chapter-6-selecting-a-build-system">Chapter 6. Selecting a Build System</h1>
<h2 id="build-systems">Build systems</h2>
<p><em><span class="dquo">“</span>A build system should be able to build, from upstream source code, some or all of the following:</em></p>
<ul>
<li><em>A toolchain</em></li>
<li><em>A bootloader</em></li>
<li><em>A kernel</em></li>
<li><em>A root filesystem”</em></li>
</ul>
<p><em><span class="dquo">“</span>A build system has to be able to do the following:</em></p>
<ol>
<li><em>Download the source code from upstream, either directly from the source code control system or as an archive, and cache it locally.</em></li>
<li><em>Apply patches to enable cross compilation, fix architecture-dependent</em></li>
<li><em>Build the various components.</em></li>
<li><em>Create a staging area and assemble a root filesystem.</em></li>
<li><em>Create image files in various formats ready to be loaded onto the target.”</em></li>
</ol>
<p><em><span class="dquo">“</span>[In the Yocto project] every component is generated as a binary
package, by default, using the <span class="caps">RPM</span> format, and then the packages
are combined together to make the filesystem image. Furthermore,
you can install a package manager in the filesystem image, which
allows you to update packages at runtime.”</em></p>
<h2 id="the-yocto-project">The Yocto Project</h2>
<p><em><span class="dquo">“</span>[With the Yocto project one can] build toolchains, bootloaders,
kernels, and root filesystems […] it can generate an entire
Linux distribution for you with binary packages that can be
installed at runtime. The Yocto Project is primarily a group of
recipes, […] written using a combination of Python and shell
script, together with a task scheduler called </em><em>BitBake</em><em>”</em></p>
<h3 id="background">Background</h3>
<p><em><span class="dquo">“</span>The Yocto Project collects together several components, the most
important of which are the following:</em></p>
<ul>
<li><em><strong><span class="caps">OE</span>-Core</strong>: This is the core metadata, which is shared with OpenEmbedded</em></li>
<li><em><strong>BitBake</strong>: This is the task scheduler, which is shared with OpenEmbedded and other projects</em></li>
<li><em><strong>Poky</strong>: This is the reference distribution</em></li>
<li><em><strong>Documentation</strong>: This is the user’s manuals and developer’s guides for each component</em></li>
<li><em><strong>Toaster</strong>: This is a web-based interface to BitBake and its metadata”</em></li>
</ul>
<h3 id="configuring">Configuring</h3>
<p><em><span class="dquo">“</span>You must source [a] script each time you want to work on [a] project.”</em></p>
<div class="highlight"><pre><span></span><code><span class="nb">source</span> oe-init-build-env &lt;build-dir&gt;
</code></pre></div>
<p><em><span class="dquo">“</span>This will put you into the directory: <code>&lt;build-dir&gt;</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>Initially, the build directory contains only one subdirectory 
named <code>conf/</code>, which contains the configuration files for this project:</em></p>
<ul>
<li><code>local.conf</code>: <em>This contains a specification of the device you are going to build and the build environment.</em></li>
<li><code>bblayers.conf</code>: <em>This contains paths of the meta layers you are going to use.</em></li>
<li><code>templateconf.cfg</code>: This contains the name of a directory, which contains various <code>conf</code> files. By default, it points to <code>meta-poky/conf/</code>.”*</li>
</ul>
<h3 id="building">Building</h3>
<p><em><span class="dquo">“</span>Run BitBake, telling it which root filesystem image you want to create. Some common images are as follows:</em></p>
<ul>
<li><code>core-image-minimal</code>: <em>This is a small console-based system which is useful for tests and as the basis for custom images.</em></li>
<li><code>core-image-minimal-initramfs</code>: <em>This is similar to core-image-minimal, but built as a ramdisk.</em></li>
<li><code>core-image-x11</code>: <em>This is a basic image with support for graphics through an X11 server and the xterminal terminal app.</em> - <code>core-image-sato</code>: <em>This is a full graphical system based on Sato, which is a mobile graphical environment built on X11, and <span class="caps">GNOME</span>. The image includes several apps including a Terminal, an editor, and a file manager.”</em></li>
</ul>
<p><em><span class="dquo">“</span>When [the build] is complete, you will find several new directories in the build directory […] You should see the following in <code>tmp/</code>:</em></p>
<ul>
<li><code>work/</code>: <em>This contains the build directory and the staging area for the root filesystem.</em></li>
<li><code>deploy/</code>: <em>This contains the final binaries to be deployed on the target:</em><ul>
<li><code>deploy/images/[machine name]/</code>: <em>Contains the bootloader, the kernel, and the root filesystem images ready to be run on the target</em></li>
<li><code>deploy/rpm/</code>: <em>This contains the <span class="caps">RPM</span> packages that went to make up the images</em></li>
<li><code>deploy/licenses/</code>: <em>This contains the license files extracted from each package”</em></li>
</ul>
</li>
</ul>
<h3 id="running-the-qemu-target">Running the <span class="caps">QEMU</span> target</h3>
<p><em><span class="dquo">“</span>When you build a <span class="caps">QEMU</span> target, an internal version of <span class="caps">QEMU</span> is generated.”</em></p>
<p><em><span class="dquo">“</span>There is a wrapper script named <code>runqemu</code> to run this version of
<span class="caps">QEMU</span>. To run the <span class="caps">QEMU</span> emulation, make sure that you have sourced
<code>oe-init-build-env</code>, and then just type this:”</em></p>
<div class="highlight"><pre><span></span><code>runqemu qemuarm

<span class="c1"># or</span>
runqemu qemuarm nographic
</code></pre></div>
<p>For help run: <code>runqemu help</code></p>
<h3 id="layers">Layers</h3>
<p><em><span class="dquo">“</span>The core layers of the Yocto Project are as follows:</em></p>
<ul>
<li><code>meta</code>: <em>This is the OpenEmbedded core with some changes for Poky</em></li>
<li><code>meta-poky</code>: <em>This is the metadata specific to the Poky distribution</em></li>
<li><code>meta-yocto-bsp</code>: <em>This contains the board support packages for the machines that the Yocto Project supports”</em></li>
</ul>
<p><em><span class="dquo">“</span>The list of layers in which BitBake searches for recipes is stored in <code>&lt;your build directory&gt;/conf/bblayers.conf</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>Each meta layer has to have at least one configuration file,
named <code>conf/layer.conf</code>, and it should also have the <code>README</code> file 
and a license.”</em></p>
<p><em><span class="dquo">“</span>There is a handy helper script:
<code>scripts/yocto-layer create &lt;layer-name&gt;</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>The layer priority is used if the same recipe appears in several layers: the one in the layer with the highest priority wins.”</em></p>
<h4 id="bitbake-and-recipes">BitBake and recipes</h4>
<p><em><span class="dquo">“</span>BitBake processes metadata of several different types, which include the following:</em></p>
<ul>
<li><em><strong>Recipes</strong>: Files ending in <code>.bb</code>. These contain information about building a unit of software, including how to get a copy of the source code, the dependencies on other components, and how to build and install it.</em></li>
<li><em><strong>Append</strong>: Files ending in <code>.bbappend</code>. These allow some details of a recipe to be overridden or extended. A <code>bbappend</code> file simply appends its instructions to the end of a recipe (<code>.bb</code> ) file of the same root name.</em></li>
<li><strong><em>Include</em>*: Files ending in <code>.inc</code>. These contain information that is common to several recipes, allowing information to be shared among them. The files maybe included using the </strong>include<strong> or </strong>require<strong> keywords. The difference is that </strong>require<strong> produces an error if the file does not exist, whereas </strong>include*<em> does not.</em></li>
<li><strong><em>Classes</em>*: Files ending in <code>.bbclass</code>. These contain common build information, for example, how to build a kernel or how to build an autotools project. The classes are inherited and extended in recipes and other classes using the </strong>inherit*<em> keyword. The class <code>classes/base.bbclass</code> is implicitly inherited in every recipe.</em></li>
<li><em><strong>Configuration</strong>: Files ending in <code>.conf</code>. They define various configuration variables that govern the project’s build process.”</em></li>
</ul>
<p><em><span class="dquo">“</span>A recipe is a collection of tasks written in a combination of
Python and shell script. The tasks have names such as <code>do_fetch</code>, 
<code>do_unpack</code>, <code>do_patch</code>, <code>do_configure</code>, <code>do_compile</code>, and 
<code>do_install</code>. The default task is <code>do_build</code>.”</em></p>
<p><em><span class="dquo">“</span>You can list the tasks available in a recipe using <code>bitbake -c listtasks [recipe]</code>.”</em></p>
<p><em><span class="dquo">“</span>The tasks that need to be defined are <code>do_compile</code>
and <code>do_install</code>.”</em></p>
<h3 id="writing-an-image-recipe">Writing an image recipe</h3>
<p><em><span class="dquo">“</span>If you want to create an image that is to be shared with other 
developers or to be loaded onto a production system, then you 
should put the changes into an </em><em>image recipe</em><em>.”</em></p>
<h3 id="creating-an-sdk">Creating an <span class="caps">SDK</span></h3>
<p><em><span class="dquo">“</span>It is very useful to be able to create a standalone toolchain 
that other developers can install, avoiding the need for everyone
in the team to have a full installation of the Yocto Project.”</em></p>
<p><em><span class="dquo">“</span>You can do that for any image using the <code>populate_sdk</code>.”</em></p>
<h1 id="chapter-7-creating-a-storage-strategy">Chapter 7. Creating a Storage Strategy</h1>
<h2 id="storage-options">Storage options</h2>
<p><em><span class="dquo">“</span>There have been several generations of flash memory in that time,
progressing from <span class="caps">NOR</span> to <span class="caps">NAND</span> to managed flash such as eMMC.”</em></p>
<ul>
<li><span class="caps">NOR</span> flash:<ul>
<li>expensive</li>
<li>reliable</li>
<li>can be mapped into <span class="caps">CPU</span> address space</li>
<li>allows to execute code directly from flash</li>
<li>low capacity (ranging from a few megabytes to a few gigabyte)</li>
</ul>
</li>
<li><span class="caps">NAND</span> flash:<ul>
<li>much cheaper than <span class="caps">NOR</span></li>
<li>available in higher capacities(range of tens of megabytes to tens of gigabytes)</li>
<li>needs a lot of hardware and software support</li>
</ul>
</li>
<li>Managed flash memory<ul>
<li>consists of one or more <span class="caps">NAND</span> flash chips with a controller</li>
<li>hardware interface similar as hard disk</li>
</ul>
</li>
</ul>
<h3 id="nor-flash"><span class="caps">NOR</span> flash</h3>
<p><em><span class="dquo">“</span>The memory cells in <span class="caps">NOR</span> flash chips are arranged into erase blocks of,
for example, 128 KiB.
Erasing a block sets all the bits to 1. It can be programmed one word at
a time. Each erase cycle damages the memory cells slightly, and after a
number of cycles, the erase block becomes unreliable and cannot be
used anymore. [see data sheet for number of erase cycles, usually in the
range of 100K to 1M]. The data can be read word by word. The chip is
usually mapped into the <span class="caps">CPU</span> address space, which means that you can
execute code directly from <span class="caps">NOR</span> flash. This makes it a convenient place
to put the bootloader code”</em></p>
<p><em><span class="dquo">“</span>There is a standard register-level interface for <span class="caps">NOR</span> flash chips called the Common Flash Interface or <span class="caps">CFI</span>,
which all modern chips support.”</em></p>
<p><a href="https://www.jedec.org/">The <span class="caps">CFI</span> is described in standard <span class="caps">JESD68</span></a></p>
<h3 id="nand-flash"><span class="caps">NAND</span> flash</h3>
<p>Different genrations:</p>
<ul>
<li>single-level cell (<span class="caps">SLC</span>, one bit per cell)</li>
<li>multi-level cell (<span class="caps">MLC</span>, two bits per cell)</li>
<li>tri-level cell (<span class="caps">TLC</span>, three bits per cell)</li>
</ul>
<p><em><span class="dquo">“</span>Where reliability is a concern, you should make sure you are using <span class="caps">SLC</span> <span class="caps">NAND</span> flash chips.”</em></p>
<p><em><span class="dquo">“</span><span class="caps">NAND</span> flash is organized into erase blocks ranging in size from 16 KiB to 512 KiB […] erasing a block sets
all the bits to 1.”</em></p>
<p><em><span class="dquo">“</span>The number of erase cycles before the block becomes unreliable is […] typically as few as 1K cycles for <span class="caps">TLC</span> chips
and up to 100K for <span class="caps">SLC</span>.”</em></p>
<p><em><span class="dquo">“</span><span class="caps">NAND</span> flash can only be read and written in pages, usually of 2 or 4 KiB.”</em></p>
<p><em><span class="dquo">“</span>They cannot be mapped into the address space and so code and data have to be copied into <span class="caps">RAM</span>
before they can be accessed.”</em></p>
<p><em><span class="dquo">“</span>Data transfers to and from the chip are prone to bit flips, which can be detected and corrected using
error-correction codes (ECCs).”</em></p>
<p><em><span class="dquo">“</span>There is an extra area of memory per page known as the out-of-band (<span class="caps">OOB</span>) area, or the spare area.”</em></p>
<p><em><span class="dquo">“</span>Many parts of the system are interested in the layout of the <span class="caps">OOB</span> area: the SoC <span class="caps">ROM</span> boot code, the bootloader,
the kernel <span class="caps">MTD</span> driver, the filesystem code, and the tools to create filesystem images.”</em></p>
<p><em><span class="dquo">“</span>It is up to you to make sure that they all agree.”</em></p>
<p><em><span class="dquo">“</span>There is a standard register-level interface for <span class="caps">NAND</span> flash chips known as the Open <span class="caps">NAND</span> Flash Interface or ONFi , which most modern chips adhere to. See http://www.onfi.org/”</em></p>
<h3 id="managed-flash">Managed flash</h3>
<p><em><span class="dquo">“</span>The most important types of chips for embedded systems are Secure Digital (<span class="caps">SD</span>)
cards and the embedded variant known as eMMC.”</em></p>
<h4 id="multimediacard-and-secure-digital-cards">MultiMediaCard and Secure Digital cards</h4>
<p><em><span class="dquo">“</span>Newer versions of the <span class="caps">SD</span> specification allow smaller packaging (mini <span class="caps">SD</span> and microSD, which is often written as uSD)
and larger capacities: high capacity <span class="caps">SDHC</span> up to 32 <span class="caps">GB</span> and extended capacity
<span class="caps">SDXC</span> up to <span class="caps">2TB</span>.”</em></p>
<p><em><span class="dquo">“</span>The hardware interface for <span class="caps">MMC</span> and <span class="caps">SD</span> cards is very similar, and it is
possible to use full-sized <span class="caps">MMC</span> cards in full-sized <span class="caps">SD</span> card slots (but not the other
way round).”</em></p>
<p><em><span class="dquo">“</span>There is a command set for reading and writing memory in sectors of 512 bytes.”</em></p>
<h2 id="accessing-flash-memory-from-the-bootloader">Accessing flash memory from the bootloader</h2>
<h3 id="u-boot-and-nor-flash">U-Boot and <span class="caps">NOR</span> flash</h3>
<p><em><span class="dquo">“</span>U-Boot has drivers for <span class="caps">NOR</span> <span class="caps">CFI</span> chips in <code>drivers/mtd</code><span class="dquo">“</span></em></p>
<h3 id="u-boot-and-nand-flash">U-Boot and <span class="caps">NAND</span> flash</h3>
<p><em><span class="dquo">“</span>For <span class="caps">NAND</span> flash, you need a driver for the <span class="caps">NAND</span> flash controller on your
SoC, which you can find in the U-Boot source code in the directory
<code>drivers/mtd/nand</code>.”</em></p>
<p><em><span class="dquo">“</span>U-Boot can also read files stored in the <span class="caps">JFFS2</span> , <span class="caps">YAFFS2</span> , and <span class="caps">UBIFS</span> filesystems.”</em></p>
<h3 id="u-boot-and-mmc-sd-and-emmc">U-Boot and <span class="caps">MMC</span>, <span class="caps">SD</span>, and eMMC</h3>
<p><em><span class="dquo">“</span>U-Boot has drivers for several <span class="caps">MMC</span> controllers in <code>drivers/mmc</code>.”</em></p>
<p><em><span class="dquo">“</span>U-boot can also read files from the <span class="caps">FAT32</span> and ext4 filesystems on <span class="caps">MMC</span> storage.”</em></p>
<h2 id="accessing-flash-memory-from-linux">Accessing flash memory from Linux</h2>
<p><em><span class="dquo">“</span><span class="caps">NOR</span> and <span class="caps">NAND</span> flash memory is handled by the </em><em>Memory Technology Device</em><em> subsystem, or </em><em><span class="caps">MTD</span></em><em>.”</em></p>
<p><em><span class="dquo">“</span>In the case of <span class="caps">NAND</span> flash, there are also functions to handle the <span class="caps">OOB</span> area and to identify bad blocks.”</em></p>
<p><em><span class="dquo">“</span><span class="caps">MMC</span>/<span class="caps">SD</span> cards and eMMC use the <code>mmcblk</code> driver; CompactFlash and hard drives use the <span class="caps">SCSI</span> disk driver, <code>sd</code>.
<span class="caps">USB</span> flash drives use the <code>usb_storage</code> driver together with the <code>sd</code> driver.”</em></p>
<h3 id="memory-technology-devices">Memory technology devices</h3>
<p><em><span class="dquo">“</span><span class="caps">MTD</span> consists of three layers: a core set of functions, a set of drivers
for various types of chips, and user-level drivers that present the flash
memory as a character device or a block device.”</em></p>
<p><em><span class="dquo">“</span>Only a small number of drivers are needed for <span class="caps">NOR</span> flash chips, enough to cover the <span class="caps">CFI</span> standard and
variations plus a few non-compliant chips.”</em></p>
<p><em><span class="dquo">“</span>For <span class="caps">NAND</span> flash, you will need a driver for the <span class="caps">NAND</span> flash controller you are using; this is usually supplied
as part of the board support package.”</em></p>
<p><em><span class="dquo">“</span>There are drivers […] in the directory <code>drivers/mtd/nand</code>.”</em></p>
<h4 id="mtd-partitions"><span class="caps">MTD</span> partitions</h4>
<p><em><span class="dquo">“</span>You can see a summary of the configuration at runtime by reading <code>/proc/mtd</code>:”</em></p>
<div class="highlight"><pre><span></span><code>cat /proc/mtd
</code></pre></div>
<p><em><span class="dquo">“</span>There is more detailed information for each partition in <code>/sys/class/mtd</code>,
[that] is nicely summarized using <code>mtdinfo</code>:”</em></p>
<div class="highlight"><pre><span></span><code>mtdinfo /dev/mtd0
</code></pre></div>
<h4 id="mtd-device-drivers"><span class="caps">MTD</span> device drivers</h4>
<p><em><span class="dquo">“</span>The upper level of the <span class="caps">MTD</span> subsystem is a pair of device drivers:</em></p>
<ul>
<li><em>A character device, with a major number of 90. There are two device nodes per <span class="caps">MTD</span> partition number, <code>N</code>: <code>/dev/mtdN</code> […] and <code>/dev/mtdNro</code> […]. The latter is just a read-only version of the former.</em></li>
<li><em>A block device, with a major number of 31 and a minor number of <code>N</code>. The device nodes are in the form <code>/dev/mtdblockN</code>.”</em></li>
</ul>
<h4 id="the-mtd-character-device-mtd">The <span class="caps">MTD</span> character device, mtd</h4>
<p><em><span class="dquo">“</span>The character devices are the most important: they allow you to access the underlying flash memory as an array of bytes so that you can read and write (program)
the flash. It also implements a number of <code>ioctl</code> functions that allow you to erase blocks and to manage the <span class="caps">OOB</span> area on <span class="caps">NAND</span> chips.
[See for a list of <code>ioctl</code>s]: <code>include/uapi/mtd/mtd-abi.h</code> [and the book].”</em></p>
<p><em><span class="dquo">“</span>There is a set of utility programs known as <code>mtd-utils</code> for manipulating flash memory.”</em></p>
<p><em><span class="dquo">“</span>You must always erase flash memory before writing new contents to it.”</em></p>
<p><em><span class="dquo">“</span>To program <span class="caps">NOR</span> flash, you simply copy bytes to the <span class="caps">MTD</span> device node using a file copy command such as <code>cp</code>.
Unfortunately, this doesn’t work with <span class="caps">NAND</span> memory as the copy will fail at the first bad block. Instead,
use <code>nandwrite</code>, which skips over any bad blocks. To read back <span class="caps">NAND</span> memory, you should use <code>nanddump</code>,
which also skips bad blocks.”</em></p>
<h4 id="logging-kernel-oops-to-mtd">Logging kernel oops to <span class="caps">MTD</span></h4>
<p><em><span class="dquo">“</span>A kernel error, or oops, is normally logged via the klogd and syslogd daemons to a circular memory buffer or a file.”</em></p>
<p><em><span class="dquo">“</span>A more reliable method is to write oops and kernel panics to an <span class="caps">MTD</span> partition as a circular log buffer.
You enable it with <code>CONFIG_MTD_OOPS</code> and add <code>console=ttyMTDN</code> to the kernel command line,
<code>N</code> being the <span class="caps">MTD</span> device number to write the messages to.”</em></p>
<h4 id="simulating-nand-memory">Simulating <span class="caps">NAND</span> memory</h4>
<p><em><span class="dquo">“</span>The <span class="caps">NAND</span> simulator emulates a <span class="caps">NAND</span> chip using system <span class="caps">RAM</span>.”</em></p>
<p><em><span class="dquo">“</span>In particular, the ability to simulate bad blocks, bit flips, and other errors allows you to test code paths that are difficult to exercise using real flash memory.”</em></p>
<p><em><span class="dquo">“</span>The code is in <code>drivers/mtd/nand/nandsim.c</code>. Enable it with the kernel configuration <code>CONFIG_MTD_NAND_NANDSIM</code>.”</em></p>
<h3 id="the-mmc-block-driver">The <span class="caps">MMC</span> block driver</h3>
<p><em><span class="dquo">“</span><span class="caps">MMC</span>/<span class="caps">SD</span> cards and eMMC chips are accessed using the mmcblk block driver.”</em></p>
<p><em><span class="dquo">“</span>The drivers are located in the Linux source code in <code>drivers/mmc/host</code>.”</em></p>
<h2 id="filesystems-for-flash-memory">Filesystems for flash memory</h2>
<p><em><span class="dquo">“</span>There are several challenges when making efficient use of flash memory for mass storage:
the mismatch between the size of an erase block and a disk sector, the limited number of erase
cycles per erase block, and the need for bad block handling on <span class="caps">NAND</span> chips. These differences
are resolved by a </em><em>Flash translation layer</em><em>, or </em><em><span class="caps">FTL</span></em><em>.”</em></p>
<h2 id="filesystems-for-nor-and-nand-flash-memory">Filesystems for <span class="caps">NOR</span> and <span class="caps">NAND</span> flash memory</h2>
<ul>
<li><strong><span class="caps">JFFS2</span> (Journaling Flash File System 2)</strong>:<ul>
<li>first available flash filesystem for Linux</li>
<li>still in use</li>
<li>works for <span class="caps">NOR</span> and <span class="caps">NAND</span> memory</li>
<li>slow during mount</li>
</ul>
</li>
<li>**<span class="caps">YAFFS2</span> (Yet Another Flash File System 2)”“:<ul>
<li>similar to <span class="caps">JFFS2</span></li>
<li>specifically for <span class="caps">NAND</span> flash memory</li>
</ul>
</li>
<li><strong><span class="caps">UBIFS</span> (Unsorted Block Image File System)</strong>:<ul>
<li>works in conjunction with the <span class="caps">UBI</span> block driver</li>
<li>reliable flash filesystem</li>
<li>works with <span class="caps">NOR</span> and <span class="caps">NAND</span> memory</li>
<li>better performance than <span class="caps">JFFS2</span> or <span class="caps">YAFFS2</span></li>
<li>should be the preferred solution for new designs!</li>
</ul>
</li>
</ul>
<p>All of these use <span class="caps">MTD</span> as the common interface to flash memory.</p>
<h3 id="jffs2"><span class="caps">JFFS2</span></h3>
<p><em><span class="dquo">“</span>[Journaling Flash File System] is a log-structured filesystem that uses <span class="caps">MTD</span> to
access flash memory.”</em></p>
<h4 id="creating-a-jffs2-filesystem">Creating a <span class="caps">JFFS2</span> filesystem</h4>
<p><em><span class="dquo">“</span>Creating an empty <span class="caps">JFFS2</span> filesystem [:] erasing an <span class="caps">MTD</span> partition with clean markers
and then mounting it. There is no formatting step because a blank <span class="caps">JFFS2</span> filesystem
consists entirely of free blocks. [see book for examples]”</em></p>
<h3 id="yaffs2"><span class="caps">YAFFS2</span></h3>
<p><em><span class="dquo">“</span><span class="caps">YAFFS</span> is also a log-structured filesystem following the same design principles as <span class="caps">JFFS2</span>.”</em></p>
<p><em><span class="dquo">“</span>it has a faster mount-time scan, simpler and faster garbage collection, and has no compression.”</em></p>
<p><em><span class="dquo">“</span><span class="caps">YAFFS</span> is not limited to Linux; it has been ported to a wide range of operating systems.”</em></p>
<p><em><span class="dquo">“</span>”<span class="caps">YAFFS</span> code has never been merged into mainline Linux, so you will have to patch your kernel.</em></p>
<h4 id="creating-a-yaffs2-filesystem">Creating a <span class="caps">YAFFS2</span> filesystem</h4>
<p><em><span class="dquo">“</span>As with <span class="caps">JFFS2</span>, to create a <span class="caps">YAFFS2</span> filesystem at runtime, you only need to erase the partition and mount it [see book for examples].”</em></p>
<h3 id="ubi-and-ubifs"><span class="caps">UBI</span> and <span class="caps">UBIFS</span></h3>
<p>Unsorted Block Image (<span class="caps">UBI</span>) driver and and corresponding filesystem (<span class="caps">UBIFS</span>).</p>
<h4 id="ubi"><span class="caps">UBI</span></h4>
<p><em><span class="dquo">“</span><span class="caps">UBI</span> provides an idealized, reliable view of a flash chip by mapping </em><em>physical erase blocks</em><em> (</em><em><span class="caps">PEB</span></em><em>)
to </em><em>logical erase blocks</em><em> (</em><em><span class="caps">LEB</span></em><em>). Bad blocks are not mapped to LEBs and so are never used. If a block
cannot be erased, it is marked as bad and dropped from the mapping.”</em></p>
<p><em><span class="dquo">“</span><span class="caps">UBI</span> accesses the flash memory through the <span class="caps">MTD</span> layer.”</em></p>
<p><em><span class="dquo">“</span><code>ubiformat</code> needs to know the minimum unit of I/O, which for most <span class="caps">NAND</span> flash chips is the page size,
but some chips allow reading and writing in sub pages that are a half or a quarter of the page size.
Consult the chip data sheet for details and, if in doubt, use the page size.”</em></p>
<p><em><span class="dquo">“</span>The first time you attach to an <span class="caps">MTD</span> partition after a <code>ubiformat</code>, there will be no volumes.
You can create volumes using <code>ubimkvol</code>.”</em></p>
<p>There is a tool <code>ubinfo</code>:</p>
<div class="highlight"><pre><span></span><code>ubinfo -a /dev/ubi0
</code></pre></div>
<h4 id="ubifs"><span class="caps">UBIFS</span></h4>
<p><em><span class="dquo">“</span><span class="caps">UBIFS</span> uses a <span class="caps">UBI</span> volume to create a robust filesystem. It adds sub-allocation and garbage collection to create a complete
flash translation layer.”</em></p>
<p><em><span class="dquo">“</span><span class="caps">UBIFS</span> has a journal for fast recovery in the event of power down.”</em></p>
<p><em><span class="dquo">“</span>Creating a filesystem image for <span class="caps">UBIFS</span> is a two-stage process: first you create a <span class="caps">UBIFS</span> image using
<code>mkfs.ubifs</code>, and then embed it into a <span class="caps">UBI</span> volume using <code>ubinize</code>.”</em></p>
<h2 id="filesystems-for-managed-flash">Filesystems for managed flash</h2>
<h3 id="flashbench">Flashbench</h3>
<p><em><span class="dquo">“</span>To make optimum use of the underlying flash memory, you need to know the erase block size and page size.
Manufacturers do not publish these numbers as a rule, but it is possible to deduce them by observing the
behavior of the chip or card [using flashbench, see book for more details].”</em></p>
<h3 id="ext4">Ext4</h3>
<p><em><span class="dquo">“</span></em><em>ext4</em><em> is very stable and well tested and has a journal that makes recovery from an unscheduled shutdown fast
and mostly painless. It is a good choice for managed flash devices”</em></p>
<h2 id="read-only-compressed-filesystems">Read-only compressed filesystems</h2>
<h3 id="squashfs">squashfs</h3>
<p><em><span class="dquo">“</span>The resulting filesystem is read-only, so there is no mechanism to modify any of the files at runtime. The only
way to update a <code>squashfs</code> filesystem is to erase the whole partition and program in a new image. <code>squashfs</code> is not
bad-block aware and so must be used with reliable flash memory such as <span class="caps">NOR</span> flash. However, it can be used on <span class="caps">NAND</span>
flash as long as you use <span class="caps">UBI</span> to create an emulated, reliable <span class="caps">MTD</span>.”</em></p>
<h2 id="temporary-filesystems">Temporary filesystems</h2>
<p><em><span class="dquo">“</span>You can create a temporary <span class="caps">RAM</span>-based filesystem by simply mounting <code>tmpfs</code>:”</em></p>
<p><em><span class="dquo">“</span>As with <code>procfs</code> and <code>sysfs</code>, there is no device node associated with <code>tmpfs</code>, so you have to supply a place-keeper string.”</em></p>
<p><em><span class="dquo">“</span>It would be a disaster if <code>tmpfs</code> grew to be that large, so it is a very good idea to cap it with a <code>-o size</code> parameter.”</em></p>
<div class="highlight"><pre><span></span><code>mount -t tmpfs -o <span class="nv">size</span><span class="o">=</span>1m tmp_files /tmp
</code></pre></div>
<p><em><span class="dquo">“</span>In addition to <code>/tmp</code>, some subdirectories of <code>/var</code> contain volatile data”</em></p>
<p><em><span class="dquo">“</span>In the Yocto Project, <code>/run</code> and <code>/var/volatile</code> are <code>tmpfs</code> mounts.”</em></p>
<h2 id="making-the-root-filesystem-read-only">Making the root filesystem read-only</h2>
<p><em><span class="dquo">“</span>You need to make your target device able to survive unexpected events, including file corruption, and still be able to boot
and achieve at least a minimum level of function. Making the root filesystem read-only is a key part of achieving this ambition
because it eliminates accidental overwrites. Making it read-only is easy: replace <code>rw</code> with <code>ro</code> on the kernel command line or
use an inherently read-only filesystem such as <code>squashfs</code>.
However, you will find that there are a few files and directories that are traditionally writable
[see book for more details].”</em></p>
<p><em><span class="dquo">“</span>If you are using the Yocto Project, you can create a read-only root filesystem by adding <code>IMAGE_FEATURES = "read-only-rootfs"</code>
to <code>conf/local.conf</code> or to your image recipe.”</em></p>
<h1 id="chapter-8-updating-software-in-the-field">Chapter 8. Updating Software in the Field</h1>
<h2 id="what-to-update">What to update?</h2>
<h3 id="bootloader">Bootloader</h3>
<p><em><span class="dquo">“</span>Updating the bootloader is risky: what happens if the system powers down midway? Consequently, most update solutions leave the bootloader alone. This is not a big problem, because the bootloader only runs for a short time at power-on and is not normally a great source of run- time bugs.”</em></p>
<h2 id="kernel">Kernel</h2>
<p><em><span class="dquo">“</span>There are several parts to the kernel [that need to be updated]:</em></p>
<ul>
<li><em>A binary image loaded by the bootloader, often stored in the root filesystem.</em></li>
<li><em>Many devices also have a Device Tree Binary (<span class="caps">DTB</span>) […]. The <span class="caps">DTB</span> is usually stored alongside the kernel binary.</em></li>
<li><em>There may be kernel modules in the root filesystem.”</em></li>
</ul>
<h3 id="root-filesystem">Root filesystem</h3>
<p><em><span class="dquo">“</span>The root filesystem contains the essential system libraries, utilities, and scripts needed to make the system work. It is very desirable to be able to replace and upgrade all of these. The mechanism depends on the implementation.”</em></p>
<h3 id="system-applications">System applications</h3>
<p><em><span class="dquo">“</span>[The system applications] may be bundled with the root filesystem, but it is also common for them to be placed in a separate filesystem to make updating easier and to maintain separation between the system files, which are usually open source, and the application files, which are often proprietary.”</em></p>
<h3 id="device-specific-data">Device-specific data</h3>
<p><em><span class="dquo">“</span>[Files that comntain] settings, logs, user-supplied data, and the like. It is not often that they need to be updated, but they do need to be preserved during an update”</em></p>
<h2 id="the-basics-of-software-update">The basics of software update</h2>
<h3 id="making-updates-robust">Making updates robust</h3>
<p><em><span class="dquo">“</span>The update as a whole must be atomic: there should be no stage at which part of the system is updated but not other parts. There must be a single, uninterruptible change to the system that switches to the new version of software.”</em></p>
<h3 id="making-updates-fail-safe">Making updates fail-safe</h3>
<p><em><span class="dquo">“</span>[It’s possible to configure] the kernel to reboot a number of seconds after a panic. You can do this either when you build the kernel by setting <code>CONFIG_PANIC_TIMEOUT</code> or by setting the kernel command line to panic [e.g <code>panic=5</code> for reboot after 5 seconds].”</em></p>
<p><em><span class="dquo">“</span>To enable panic on Oops in the kernel configuration, set <code>CONFIG_PANIC_ON_OOPS=y</code> or, on the kernel command line, <code>oops=panic</code>.”</em></p>
<p><em><span class="dquo">“</span>If you are using systemd, you can use the inbuilt watchdog function”</em></p>
<p><em><span class="dquo">“</span>[Otherwise] you may want to enable the watchdog support built into Linux, as described in the kernel source code in <code>Documentation/watchdog</code>.”</em></p>
<h3 id="making-updates-secure">Making updates secure</h3>
<p><em><span class="dquo">“</span>Remote update […] need a secure transfer channel, such as <span class="caps">HTTPS</span>.”</em></p>
<p><em><span class="dquo">“</span>[…] secure boot protocol in the bootloader. If the kernel image is signed at the factory with a digital key, the bootloader can check the key before it loads the kernel and refuse to load it if the keys do not match”</em></p>
<p><em><span class="dquo">“</span>U-Boot implements such a mechanism, which is described in the U-Boot source code in <code>doc/uImage.FIT/verified-boot.txt</code>.”</em></p>
<h2 id="types-of-update-mechanism">Types of update mechanism</h2>
<h3 id="symmetric-image-update">Symmetric image update</h3>
<p><em><span class="dquo">“</span>There are several open source projects that implement symmetric image update. One is the </em><em>Mender</em><em> client operating in standalone mode […]. Another is </em><em>SWUpdate</em><em> […]. A third example is </em><em><span class="caps">RAUC</span></em><em>, the </em><em>Robust Auto-Update Controller</em><em>”</em></p>
<p><em><span class="dquo">“</span>There are some drawbacks with this scheme. One is that by updating an entire filesystem image, the size of the update package is large.”</em></p>
<p><em><span class="dquo">“</span>A second drawback is the need to keep storage space for a redundant copy of the root filesystem and other components.”</em></p>
<h3 id="asymmetric-image-update">Asymmetric image update</h3>
<p><em><span class="dquo">“</span>You can reduce storage requirements by keeping a minimal recovery operating system purely for updating the main one”</em></p>
<p><em><span class="dquo">“</span>Once the Recovery <span class="caps">OS</span> is running, it can stream updates to the main operating system image.”</em></p>
<p><em><span class="dquo">“</span>The Recovery <span class="caps">OS</span> is usually a lot smaller than the main operating system, maybe only a few megabytes.”</em></p>
<p><em><span class="dquo">“</span>For open source implementations of asymmetric image update, you could consider </em><em>SWUpdate</em><em> or </em><em><span class="caps">RAUC</span></em><em>”</em></p>
<h3 id="atomic-file-updates">Atomic file updates</h3>
<p><em><span class="dquo">“</span>Another approach is to have redundant copies of a root filesystem present in multiple directories of a single filesystem and then use the <code>chroot(8)</code> command to choose one of them at boot time.”</em></p>
<p><em><span class="dquo">“</span>The OSTree project, now renamed libOSTree, is the most popular implementation of this idea”</em></p>
<p><em><span class="dquo">“</span>It is one of the update methods available in </em><em>Automotive Grade Linux (<span class="caps">AGL</span>)</em><em>, and it is available in the Yocto Project through the meta-update layer, which is supported by </em><em>Advanced Telematic Systems (<span class="caps">ATS</span>)</em><em>.”</em></p>
<h2 id="ota-updates"><span class="caps">OTA</span> updates</h2>
<p><em><span class="dquo">“</span>Two examples of open source projects […] for <span class="caps">OTA</span> update:</em></p>
<ul>
<li><em>Mender in managed mode</em></li>
<li><em>The hawkBit in conjunction with an updater client such as </em><em>SWUpdate</em><em> or </em><em><span class="caps">RAUC</span></em><em>”</em></li>
</ul>
<h2 id="summary_2">Summary</h2>
<p><em><span class="dquo">“</span>The approach used most often, and also the one with most real-world testing, is the symmetric image (</em><em>A/B</em><em>) update, or its cousin the asymmetric (recovery) image update. Here, you have the choice of SWUpdate, <span class="caps">RAUC</span>, and Mender.”</em></p>
<h1 id="chapter-9-interfacing-with-device-drivers">Chapter 9. Interfacing with Device Drivers</h1>
<p><em><span class="dquo">“</span>In many cases, you will find that there are device drivers provided for you, and you can achieve everything you want without writing any kernel code. For example, you can manipulate <span class="caps">GPIO</span> pins and LEDs using files in </em><em>sysfs</em><em>, and there are libraries to access serial buses, including </em><em><span class="caps">SPI</span> (Serial Peripheral Interface)</em><em> and </em><em><span class="caps">I2C</span> (Inter-Integrated Circuit)</em><em>.”</em></p>
<h2 id="the-role-of-device-drivers">The role of device drivers</h2>
<p><em><span class="dquo">“</span>One driver may control multiple devices of the same kind.”</em></p>
<p><em><span class="dquo">“</span>Kernel device driver code runs at a high privilege level, as does the rest of the kernel. It has full access to the processor address space and hardware registers. It can handle interrupts and <span class="caps">DMA</span> transfers.”</em></p>
<p><em><span class="dquo">“</span>Device drivers should be as simple as possible by just providing information to applications where the real decisions are made.”</em></p>
<p><em><span class="dquo">“</span>In Linux, there are three main types of device driver:</em></p>
<ul>
<li><em>Character: This is for an unbuffered I/O with a rich range of functions and a thin layer between the application code and the driver. It is the first choice when implementing custom device drivers.</em></li>
<li><em>Block: This has an interface tailored for block I/O to and from mass storage devices. There is a thick layer of buffering designed to make disk reads and writes as fast as possible, which makes it unsuitable for anything else.</em></li>
<li><em>Network: This is similar to a block device but is used for transmitting and receiving network packets rather than disk blocks.”</em></li>
</ul>
<p><em><span class="dquo">“</span>There is also a fourth type that presents itself as a group of files in one of the pseudo file systems. For example, you might access the <span class="caps">GPIO</span> driver through a group of files in <code>/sys/class/gpio</code><span class="dquo">“</span></em></p>
<h2 id="character-devices">Character devices</h2>
<p><em><span class="dquo">“</span>Character devices are identified in user space by a special file called a </em><em>device node</em><em>. This file name is mapped to a device driver using the major and minor numbers associated with it. Broadly speaking, the </em><em>major number</em><em> maps the device node to a particular device driver, and the </em><em>minor number</em><em> tells the driver which interface is being accessed.”</em></p>
<p><em><span class="dquo">“</span>The list of standard major and minor numbers can be found in the kernel documentation in <code>Documentation/devices.txt</code>. The list does not get updated very often.”</em></p>
<p><em><span class="dquo">“</span>When you open a character device node, the kernel checks to see whether the major and minor numbers fall into a range registered by a character device driver. If so, it passes the call to the driver, otherwise the open call fails. The device driver can extract the minor number to find out which hardware interface to use.”</em></p>
<p><em><span class="dquo">“</span>[One could use] the stream I/O functions, <code>fopen(3)</code>, <code>fread(3)</code>, and <code>fclose(3)</code> instead [of <code>open(2)</code>, <code>read(2)</code>, and <code>close(2)</code>], but the buffering implicit in these functions often causes unexpected behavior.”</em></p>
<h2 id="block-devices">Block devices</h2>
<p><em><span class="dquo">“</span>Although character and block devices are identified using major and minor numbers, they are in different namespaces. A character driver with a major number 4 is in no way related to a block driver with a major number 4.”</em></p>
<p><em><span class="dquo">“</span>With block devices, the major number is used to identify the device driver and the minor number is used to identify the partition.”</em></p>
<p><em><span class="dquo">“</span>Both the <span class="caps">MMC</span> and <span class="caps">SCSI</span> block drivers expect to find a partiton table at the start of the disk. The partition table is created using utilities such as <code>fdisk</code>, <code>sfidsk</code>, or <code>parted</code>.”</em></p>
<p><em><span class="dquo">“</span>Both the <span class="caps">MMC</span> and <span class="caps">SCSI</span> block drivers expect to find a partiton table at the start of the disk. The partition table is created using utilities such as fdisk, sfidsk, or parted.”</em></p>
<h2 id="network-devices">Network devices</h2>
<p><em><span class="dquo">“</span>Network devices are not accessed through device nodes, and they do not have major and minor numbers. Instead, a network device is allocated a name by the kernel, based on a string and an instance number.”</em></p>
<p><em><span class="dquo">“</span>[User space programs] interact with the network driver indirectly by opening sockets”</em></p>
<p><em><span class="dquo">“</span>It is possible to access network devices directly from user space by creating a socket and using the ioctl commands listed in <code>include/linux/sockios.h</code><span class="dquo">“</span></em></p>
<h2 id="finding-out-about-drivers-at-runtime">Finding out about drivers at runtime</h2>
<p><em><span class="dquo">“</span>You can find out a lot by reading the files in <code>/proc</code> and <code>/sys</code>.”</em></p>
<div class="highlight"><pre><span></span><code>cat /proc/devices
</code></pre></div>
<p><em><span class="dquo">“</span>For each driver, you can see the major number and the base name.”</em></p>
<p><em><span class="dquo">“</span>network devices do not appear in this list, because they do not have device nodes.”</em></p>
<div class="highlight"><pre><span></span><code>ip link show
</code></pre></div>
<h3 id="getting-information-from-sysfs">Getting information from <code>sysfs</code></h3>
<p><em><span class="dquo">“</span><code>sysfs</code> [is a] representation of kernel objects, attributes, and relationships. A kernel object is a directory, an attribute is a file, and a relationship is a symbolic link from one object to another”</em></p>
<p><em><span class="dquo">“</span>You can see the kernel’s view of the system laid out before you by looking in <code>/sys</code>.”</em></p>
<h4 id="the-devices-sysdevices">The devices: <code>/sys/devices</code></h4>
<p><em><span class="dquo">“</span>There are three directories that are present on all systems:</em></p>
<ul>
<li><em><code>system/</code>: This contains devices at the heart of the system, including CPUs and clocks.</em></li>
<li><em><code>virtual/</code>: This contains devices that are memory-based. You will find the memory devices that appear as <code>/dev/null</code>, <code>/dev/random</code>, and <code>/dev/zero</code> in <code>virtual/mem</code>. You will find the loopback device, <code>lo</code>, in <code>virtual/net</code>.</em></li>
<li><em><code>platform/</code>: This is a catch-all for devices that are not connected via a conventional hardware bus. This maybe almost everything on an embedded device.</em>”</li>
</ul>
<p><em><span class="dquo">“</span>The other devices appear in directories that correspond to actual system buses.”</em></p>
<p><em><span class="dquo">“</span>Navigating this hierarchy is quite hard, because it requires some knowledge of the topology of your system, and the path-names become quite long and hard to remember. To make life easier, <code>/sys/class</code> and <code>/sys/block</code> offer two different views of the devices.”</em></p>
<h4 id="the-drivers-sysclass">The drivers: <code>/sys/class</code></h4>
<p><em><span class="dquo">“</span>This is a view of the device drivers presented by their type. In other words, it is a software view rather than a hardware view.”</em></p>
<h5 id="the-block-drivers-sysblock">The block drivers: <code>/sys/block</code></h5>
<p><em><span class="dquo">“</span>There is a subdirectory for each block device.”</em></p>
<p><em><span class="dquo">“</span>The conclusion, then, is that you can learn a lot about the devices (the hardware) and the drivers (the software) that are present on a system by reading <code>sysfs</code>.”</em></p>
<h2 id="finding-the-right-device-driver">Finding the right device driver</h2>
<p><em><span class="dquo">“</span>Where do you start to look for device drivers to support all of these peripherals?”</em></p>
<p><em><span class="dquo">“</span>There maybe support in your kernel already: there are many thousands of drivers in mainline Linux and there are many vendor-specific drivers in the vendor kernels. Begin by running <code>make menuconfig</code> (or <code>xconfig</code>) and search for the product name or number.”</em></p>
<p><em><span class="dquo">“</span>Next, try searching through the code in the drivers directory”</em></p>
<h2 id="device-drivers-in-user-space">Device drivers in user space</h2>
<p><em><span class="dquo">“</span>There are generic device drivers for many common types of device that allow you to interact with hardware directly from user space without having to write a line of kernel code. User space code is certainly easier to write and debug. It is also not covered by the <span class="caps">GPL</span>.”</em></p>
<p><em><span class="dquo">“</span>These drivers fall into two broad categories: those that you control through files in <code>sysfs</code>, including <span class="caps">GPIO</span> and LEDs, and serial buses that expose a generic interface through a device node, such as <span class="math">\(I^2C\)</span>.”</em></p>
<h3 id="gpio"><span class="caps">GPIO</span></h3>
<p><em><span class="dquo">“</span>Each [pin] can be in one of two states: either high or low. In most cases you can configure the <span class="caps">GPIO</span> pin to be either an input or an output. You can even use a group of <span class="caps">GPIO</span> pins to create higher level interfaces such as <span class="math">\(I^2C\)</span> or <span class="caps">SPI</span> by manipulating each bit in software, a technique that is called </em><em>bit banging</em><em>.”</em></p>
<p><em><span class="dquo">“</span>Generally speaking, it is hard to achieve timer accuracy better than a millisecond unless you configure a real-time kernel.”</em></p>
<p><em><span class="dquo">“</span>More common use cases for <span class="caps">GPIO</span> are for reading push buttons and digital sensors and controlling LEDs, motors, and relays.”</em></p>
<p><em><span class="dquo">“</span>All this diversity is handled by a kernel subsystem known as <code>gpiolib</code>, which is not actually a library but the infrastructure <span class="caps">GPIO</span> drivers use to expose I/O in a consistent way. There are details about the implementation of gpiolib in the kernel source in <code>Documentation/gpio</code> and the code for the drivers themselves is in <code>drivers/gpio</code>.”</em></p>
<p><em><span class="dquo">“</span>Applications can interact with gpiolib through files in the <code>/sys/class/gpio</code> directory.”</em></p>
<p><em><span class="dquo">“</span>The file named <code>base</code> contains the number of the first <span class="caps">GPIO</span> pin in the register and <code>ngpio</code> contains the number of bits in the register.”</em></p>
<p><em><span class="dquo">“</span>To control a <span class="caps">GPIO</span> bit from user space, you first have to export it from kernel space, which you do by writing the <span class="caps">GPIO</span> number to <code>/sys/class/gpio/export</code>.”</em></p>
<p><em><span class="dquo">“</span>You can remove a <span class="caps">GPIO</span> from user space control by writing the <span class="caps">GPIO</span> number to <code>/sys/class/gpio/unexport</code>.”</em></p>
<h4 id="handling-interrupts-from-gpio">Handling interrupts from <span class="caps">GPIO</span></h4>
<p><em><span class="dquo">“</span>If the <span class="caps">GPIO</span> bit can generate interrupts, the file called <code>edge</code>    exists. Initially, it has the value called <code>none</code>, meaning that it does not generate interrupts. To enable interrupts, you can set it to one of these values:</em></p>
<ul>
<li><em><code>rising</code>: Interrupt on rising edge</em></li>
<li><em><code>falling</code>: Interrupt on falling edge</em></li>
<li><em><code>both</code>: Interrupt on both rising and falling edges</em></li>
<li><em><code>none</code>: No interrupts (default)”</em></li>
</ul>
<h3 id="leds">LEDs</h3>
<p><em><span class="dquo">“</span>LEDs are often controlled though a <span class="caps">GPIO</span> pin, but there is another kernel subsystem that offers more specialized control specific to the purpose. The <code>leds</code> kernel subsystem adds the ability to set brightness, should the <span class="caps">LED</span> have that ability, and it can handle LEDs connected in other ways than a simple <span class="caps">GPIO</span> pin.”</em></p>
<p><em><span class="dquo">“</span>You will have to configure your kernel with the option, <code>CONFIG_LEDS_CLASS</code>, and with the <span class="caps">LED</span> trigger actions that are appropriate to you. There is more information on <code>Documentation/leds/</code>, and the drivers are in <code>drivers/leds/</code>.”</em></p>
<p><em><span class="dquo">“</span>LEDs are controlled through an interface in <code>sysfs</code> in the directory <code>/sys/class/leds</code>.”</em></p>
<h3 id="i2c"><span class="math">\(I^2C\)</span></h3>
<p><em><span class="dquo">“</span>There is a related standard known as </em><em>system management bus</em><em> (</em><em>SMBus</em><em>) that is found on PCs, which is used to access temperature and voltage sensors. SMBus is a subset of <span class="caps">I2C</span>.”</em></p>
<p><em><span class="dquo">“</span><span class="math">\(I^2C\)</span> is a master-slave protocol with the master being one or more host controllers on the SoC. Slaves have a 7-bit address assigned by the manufacturer (read the data sheet).”</em></p>
<p><em><span class="dquo">“</span>The master may initiate a read or write transactions with one of the slaves. Frequently, the first byte is used to specify a register on the slave, and the remaining bytes are the data read from or written to that register.”</em></p>
<p><em><span class="dquo">“</span>There is one device node for each host controller”</em></p>
<div class="highlight"><pre><span></span><code>ls -l /dev/i2c*
</code></pre></div>
<p><em><span class="dquo">“</span>The device interface provides a series of <code>ioctl</code> commands that query the host controller and send the <code>read</code> and <code>write</code> commands to <span class="math">\(I^2C\)</span> slaves. There is a package named i2c-tools.”</em></p>
<p><em><span class="dquo">“</span>The <code>i2c-tools</code> package is available in Buildroot and the Yocto Project as well as most mainstream distributions.”</em></p>
<h3 id="serial-peripheral-interface-spi">Serial Peripheral Interface (<span class="caps">SPI</span>)</h3>
<p><em><span class="dquo">“</span>The <span class="caps">SPI</span> bus is similar to <span class="caps">I2C</span>, but is a lot faster, up to tens of MHz.”</em></p>
<p><em><span class="dquo">“</span>There is a generic <span class="caps">SPI</span> device driver, which you can enable through the kernel configuration <code>CONFIG_SPI_SPIDEV</code>.”</em></p>
<p><em><span class="dquo">“</span>The device nodes are named <code>spidev[bus].[chip select]</code><span class="dquo">“</span></em></p>
<div class="highlight"><pre><span></span><code>ls -l /dev/spi*
</code></pre></div>
<p><em><span class="dquo">“</span>[There is] example code in <code>Documentation/spi</code>.”</em></p>
<h2 id="writing-a-kernel-device-driver">Writing a kernel device driver</h2>
<p><em><span class="dquo">“</span>Character drivers are the most flexible and should cover 90% of all your needs.”</em></p>
<h3 id="designing-a-character-driver-interface">Designing a character driver interface</h3>
<p><em><span class="dquo">“</span>There are other ways to communicate with device drivers than just <code>read</code> and <code>write</code> [check the book for more details]:</em></p>
<ul>
<li><em><code>ioctl</code>: The kernel maintainers dislike <code>ioctl</code> because it makes kernel code and application code too interdependent</em></li>
<li><em><code>sysfs</code>: This is the preferred way now</em></li>
<li><em><code>mmap</code>: You can get direct access to kernel buffers and hardware registers by mapping kernel memory into user space, bypassing the kernel.</em></li>
<li><em><code>debugfs</code>: This is another pseudo filesystem. […] There is a good description of <code>debugfs</code> in the kernel documentation, <code>Documentation/filesystems/debugfs.txt</code>.</em></li>
<li><em><code>netlink</code>: creates a socket that links kernel space to user space.</em>”</li>
</ul>
<h3 id="compiling-kernel-modules">Compiling kernel modules</h3>
<p><em><span class="dquo">“</span>Kernel modules are not binary compatible between kernel releases and configurations: the module will only load on the kernel it was compiled with.”</em></p>
<h3 id="loading-kernel-modules">Loading kernel modules</h3>
<p><em><span class="dquo">“</span>You can load, unload, and list modules using the simple <code>insmod</code>, <code>lsmod</code>, and <code>rmmod</code> commands”</em></p>
<p><em><span class="dquo">“</span>If the module is placed in a subdirectory in <code>/lib/modules/&lt;kernel release&gt;</code>, you can create a </em><em>modules dependency database</em><em> using the command, <code>depmod -a</code><span class="dquo">“</span></em></p>
<h2 id="discovering-the-hardware-configuration">Discovering the hardware configuration</h2>
<p><em><span class="dquo">“</span>Devices on a discoverable bus such as <span class="caps">PCI</span> or <span class="caps">USB</span> have a query mode, which returns resource requirements and a unique identifier.”</em></p>
<p><em><span class="dquo">“</span>Most of the hardware blocks on an embedded board do not have such identifiers. You have to provide the information yourself in the form of a </em><em>device tree</em><em> or as C structures known as </em><em>platform data</em><em>.”</em></p>
<h3 id="linking-hardware-with-device-drivers">Linking hardware with device drivers</h3>
<p><em><span class="dquo">“</span>For most drivers, specific bindings are documented in <code>Documentation/devicetree/bindings</code>.”</em></p>
<h2 id="summary_3">Summary</h2>
<p><em><span class="dquo">“</span>Character driver interface is the most flexible and therefore, the most common. Linux drivers fit into a framework known as the driver model, which is exposed through <code>sysfs</code>. Pretty much the entire state of the devices and drivers is visible in <code>/sys</code>.”</em></p>
<h1 id="chapter-10-starting-up-the-init-program">Chapter 10. Starting Up - The init Program</h1>
<p><em><span class="dquo">“</span>There are many possible implementations of <code>init</code>.”</em></p>
<p><em><span class="dquo">“</span>The three main ones [are]: BusyBox <code>init</code>, System V <code>init</code>, and <code>systemd</code>.”</em></p>
<h2 id="after-the-kernel-has-booted">After the kernel has booted</h2>
<p><em><span class="dquo">“</span>The <code>init</code> program has <code>root</code> privilege, and since it is the first process to run, it has a process <span class="caps">ID</span> (<code>PID</code>) of <code>1</code>.”</em></p>
<p><em><span class="dquo">“</span>The tasks it has to perform are as follows:</em></p>
<ul>
<li><em>At boot, it starts daemon programs and configures system parameters and […] get the system into a working state.
Optionally, it launches a login daemon, such as <code>getty</code>, on Terminals that allow a
login shell.</em></li>
<li><em>It adopts processes that become orphaned as a result of their immediate parent terminating and there being no other processes in the thread group.</em></li>
<li><em>It responds to any of the <code>init</code><span class="quo">‘</span>s immediate children terminating by catching the signal <code>SIGCHLD</code> and collecting the return value to prevent them becoming zombie processes.</em></li>
<li><em>Optionally, it restarts those daemons that have terminated.</em></li>
<li><em>It handles the system shutdown.”</em></li>
</ul>
<p><em><span class="dquo">“</span>[<code>systemd</code> also handles] other runtime events, such as a new hardware and the loading and unloading of modules.”</em></p>
<h2 id="busybox-init">BusyBox init</h2>
<p><em><span class="dquo">“</span><code>init</code> begins by reading <code>/etc/inittab</code>. This contains a list of programs to run, one per line.”</em></p>
<p>Check the book for details about the format of <code>/etc/inittab</code> for BusyBox.</p>
<h2 id="system-v-init">System V init</h2>
<p><em><span class="dquo">“</span>Compared to the BusyBox <code>init</code>, System V <code>init</code> has two advantages. Firstly, the boot scripts are written in a well-known,
modular format, making it easy to add new packages at build time or runtime. Secondly, it has the concept of </em><em>runlevels</em><em>, which allow a
collection of programs to be started or stopped in one go when switching from one runlevel to another.”</em></p>
<p><em><span class="dquo">“</span>There are 8 runlevels numbered from 0 to 6, plus S:</em></p>
<ul>
<li><em><code>S</code>: Runs startup tasks</em></li>
<li><em><code>0</code>: Halts the system</em></li>
<li><em><code>1</code> to <code>5</code>: Available for general use</em></li>
<li><em><code>6</code>: Reboots the system”</em></li>
</ul>
<p><em><span class="dquo">“</span>Levels 1 to 5 can be used as you please. On the desktop Linux distributions, they are conventionally assigned as follows:</em></p>
<ul>
<li><em><code>1</code>: Single user</em></li>
<li><em><code>2</code>: Multi-user with no network configuration</em></li>
<li><em><code>3</code>: Multi-user with network configuration</em></li>
<li><em><code>4</code>: Not used</em></li>
<li><em><code>5</code>: Multi-user with graphical login”</em></li>
</ul>
<p><em><span class="dquo">“</span>The <code>init</code> program starts the default <code>runlevel</code> given by the <code>initdefault</code> line in <code>/etc/inittab</code>.
You can change the runlevel at runtime using the command <code>telinit [runlevel]</code>, which sends a message to <code>init</code>.
You can find the current runlevel and the previous one using the <code>runlevel</code> command.”</em></p>
<p><em><span class="dquo">“</span>The <code>halt</code> and <code>reboot</code> commands switch to runlevels called <code>0</code> and <code>6</code> respectively.”</em></p>
<p><em><span class="dquo">“</span>Runlevels are not used that much in embedded Linux: most devices simply 
boot to the default runlevel and stay there.”</em></p>
<blockquote>
<p>Runlevels are a simple and convenient way to switch between modes, for
example, from production to maintenance mode.</p>
</blockquote>
<h3 id="inittab">inittab</h3>
<p><em><span class="dquo">“</span>The <code>init</code> program begins by reading <code>/etc/inttab</code>, which contains entries that define what happens at each runlevel.”</em></p>
<p>Check the book for details about the format of <code>/etc/inittab</code> for System V <code>init</code>.</p>
<h3 id="the-initd-scripts">The init.d scripts</h3>
<p><em><span class="dquo">“</span>Each component that needs to respond to a runlevel change has a script in <code>/etc/init.d</code> to perform the change.
The script should expect two parameters: <code>start</code> and <code>stop</code>.”</em></p>
<h3 id="starting-and-stopping-services">Starting and stopping services</h3>
<p><em><span class="dquo">“</span>You can interact with the scripts in <code>/etc/init.d</code> by calling them directly.”</em></p>
<p><em><span class="dquo">“</span>All scripts implement <code>start</code> and <code>stop</code>, and they should also implement <code>help</code>.
Some implement <code>status</code> as well, which will tell you whether the service is running or not.
Mainstream distributions that still use System V <code>init</code> have a command named <code>service</code> to start and stop services, which hide the details of calling the scripts directly.”</em></p>
<h2 id="systemd">systemd</h2>
<p><em><span class="dquo">“</span>[<code>systemd</code> is a] set of tools for managing a Linux system based around an <code>init</code> daemon. It also includes device management (<code>udev</code>) and logging,
among other things. `systemd? is state of the art and is still evolving rapidly.”</em></p>
<p><em><span class="dquo">“</span>how is it better than System V <code>init</code> for embedded systems?</em></p>
<ul>
<li><em>The configuration is simpler and more logical (once you understand it). Rather than the sometimes convoluted shell scripts of System V <code>init</code>, <code>systemd</code> has unit configuration files, which are written in a well-defined format.</em></li>
<li><em>There are explicit dependencies between services rather than a two digit code that merely sets the sequence in which the scripts are run.</em></li>
<li><em>It is easy to set the permissions and resource limits for each service, which is important for the security.</em></li>
<li><em>It can monitor services and restart them if needed.</em></li>
<li><em>There are watchdogs for each service and for <code>systemd</code> itself.</em></li>
<li><em>Services are started in parallel, potentially reducing boot time.”</em></li>
</ul>
<h3 id="introducing-targets-services-and-units">Introducing targets, services, and units</h3>
<p><em><span class="dquo">“</span>[There are] three key concepts:</em></p>
<ul>
<li><em><strong>Unit</strong>, which is a configuration file that describes a target, a service, and several other things. Units are text files that contain properties and values.</em></li>
<li><em><strong>Service</strong>, which is a daemon that can be started and stopped, very much like a System V <code>init</code> service.</em></li>
<li><em><strong>Target</strong>, which is a group of services, similar to, but more general than, a System V <code>init</code> runlevel. There is a default target which is the group of services that are started at boot time.”</em></li>
</ul>
<p><em><span class="dquo">“</span>You can change states and find out what is going on using the <code>systemctl</code> command.”</em></p>
<h4 id="units">Units</h4>
<p><em><span class="dquo">“</span>The basic item of configuration is the unit file. Unit files are found in three different places:</em>
- <code>/etc/systemd/system</code>: <em>Local configuration</em>
- <code>/run/systemd/system</code>: <em>Runtime configuration</em>
- <code>/lib/systemd/system</code>: <em>Distribution-wide configuration”</em></p>
<p><em><span class="dquo">“</span>When looking for a unit, <code>systemd</code> searches the directories in that order, stopping as soon as
it finds a match, and allowing you to override the behavior of a distribution-wide unit by
placing a unit of the same name in <code>/etc/systemd/system</code>. You can disable a unit
completely by creating a local file that is empty or linked to <code>/dev/null</code>.”</em></p>
<p><em><span class="dquo">“</span>Dependencies in the Unit section are expressed though the keywords <code>Requires</code>, <code>Wants</code>,
and <code>Conflicts</code>:</em></p>
<ul>
<li><code>Requires</code>: This is a list of units that this unit depends on, which are started when this unit is started*</li>
<li><code>Wants</code>: This is a weaker form of <code>Requires</code>; the units listed are started but the current unit is not stopped if any of them fail*</li>
<li><code>Conflicts</code>: This is a negative dependency; the units listed are stopped when this one is started and, conversely, if one of them is started, this one is stopped”*</li>
</ul>
<p><em><span class="dquo">“</span>These three keywords define </em><em>outgoing dependencies</em><em>. They are used mostly to create dependencies between targets. There is another sort of dependency called an
</em><em>incoming dependency</em><em>, which is used to create a link between a service and a target. In other words, outgoing dependencies are used to create the list of targets
that need to be started as the system goes from one state to another, and incoming dependencies are used to determine the services that should be started or stopped
in any particular state. Incoming dependencies are created by the <code>WantedBy</code> keyword.”</em></p>
<p><em><span class="dquo">“</span>Processing the dependencies produces a list of units that should be started or stopped. The keywords <code>Before</code> and `After determine the order in which they
are started. The order of stopping is just the reverse of the start order:</em></p>
<ul>
<li><em><code>Before</code>: This unit should be started before the units listed</em></li>
<li><em><code>After</code>: This unit should be started after the units listed”</em></li>
</ul>
<h4 id="services">Services</h4>
<p><em><span class="dquo">“</span>A service is a daemon that can be started and stopped, equivalent to a System V <code>init</code> service.”</em></p>
<p><em><span class="dquo">“</span>Refer to the manual page for <code>systemd.service(5)</code> [and to the book for more information].”</em></p>
<h4 id="targets">Targets</h4>
<p><em><span class="dquo">“</span>A target is another type of unit, which groups services (or other types of unit). It is a type of unit that only has dependencies.”</em></p>
<p><em><span class="dquo">“</span>A target is a desired state, which performs the same role as System V <code>init</code> runlevels.”</em></p>
<h3 id="how-systemd-boots-the-system">How systemd boots the system</h3>
<p><em><span class="dquo">“</span>[…] how <code>systemd</code> implements the bootstrap. <code>systemd</code> is run by the kernel as a result of <code>/sbin/init</code> being symbolically linked to <code>/lib/systemd/systemd</code>.
It runs the default target, <code>default.target</code>, which is always a link to a desired target.”</em></p>
<p><em><span class="dquo">“</span>You can also list all the services and their current state using:”</em></p>
<div class="highlight"><pre><span></span><code>systemctl list-units --type service
</code></pre></div>
<p><em><span class="dquo">“</span>And the same for targets using:”</em></p>
<div class="highlight"><pre><span></span><code>systemctl list-units --type target
</code></pre></div>
<h3 id="adding-a-watchdog">Adding a watchdog</h3>
<p><em><span class="dquo">“</span>On most embedded SoCs,
there is a hardware watchdog, which can be accessed via the <code>/dev/watchdog</code> device node.”</em></p>
<p><em><span class="dquo">“</span>The interface with the watchdog driver is described in the kernel source 
in <code>Documentation/watchdog</code> and the code for the drivers is in <code>drivers/watchdog</code>.”</em></p>
<p><em><span class="dquo">“</span><code>systemd</code> has a useful feature that distributes the watchdog between multiple services.”</em></p>
<p><em><span class="dquo">“</span><code>systemd</code> can be configured to expect a regular keepalive call from a service and take action if it is not received,
creating a per-service software watchdog. For this to work, you have to add code to the daemon to send the <code>keepalive</code> messages.”</em></p>
<p><em><span class="dquo">“</span>There are examples in the <code>systemd</code> source code.”</em></p>
<p><em><span class="dquo">“</span>If <code>systemd</code> itself fails, the kernel crashes, or the hardware locks up.
In those cases, we need to tell <code>systemd</code> to use the watchdog driver”</em></p>
<h2 id="summary_4">Summary</h2>
<p><em><span class="dquo">“</span>In terms of reducing boot time, <code>systemd</code> is faster than System V <code>init</code>
for a similar workload. However, if you are looking for a very fast boot,
nothing can beat a simple BusyBox <code>init</code> with minimal boot scripts.”</em></p>
<h1 id="chapter-11-managing-power">Chapter 11. Managing Power</h1>
<p><em><span class="dquo">“</span>Even for devices running on mains power, reducing power usage has
benefits in reducing the need for cooling and energy costs.”</em></p>
<h2 id="measuring-power-usage">Measuring power usage</h2>
<p><em><span class="dquo">“</span>Measuring power externally, from outside the system, we just need an
ammeter to measure the current and a voltmeter to measure the voltage, and
then multiply the two together in order to get the wattage.”</em></p>
<p><em><span class="dquo">“</span>[There are] monitoring systems that are built into Linux. You will find
that plenty of information is reported to you via <code>sysfs</code>.
There is also a very useful program called </em><em>PowerTOP</em><em>, which gathers
information together from various sources and presents it in a single place.”</em></p>
<div class="highlight"><pre><span></span><code>cat /sys/power/state
</code></pre></div>
<h2 id="scaling-the-clock-frequency">Scaling the clock frequency</h2>
<p><em><span class="dquo">“</span>Reducing the frequency may actually increase the power budget because it
takes longer for the <span class="caps">CPU</span> to enter an idle state. So, in these conditions, 
it is best to use the highest frequency possible so that the <span class="caps">CPU</span> can go
back to idle quickly. This is called the </em><em>race to idle</em><em>.”</em></p>
<p><em><span class="dquo">“</span>There is another motivation to reduce frequency: </em><em>thermal management</em><em>.
It may become necessary to operate at a lower frequency just to keep the
temperature of the package within bounds.”</em></p>
<p><em><span class="dquo">“</span>Therefore, if we want to save power, we have to be able to change the
voltage that the <span class="caps">CPU</span> core operates at. But for any given voltage, there
is a maximum frequency beyond which the switching of the gates become unreliable.”</em></p>
<p><em><span class="dquo">“</span>Many SoCs implement such a feature: it is called
</em><em>Dynamic Voltage and Frequency Scaling</em><em>, or </em><em><span class="caps">DVFS</span></em><em>. Manufacturers
calculate optimum combinations of core frequency and voltage. Each
combination is called </em><em>Operating Performance Point</em><em>, or </em><em><span class="caps">OPP</span></em><em>.
The <span class="caps">ACPI</span> specification refers to them as P-states, with <code>P0</code> being
the <span class="caps">OPP</span> with the highest frequency. Although an <span class="caps">OPP</span> is a combination
of a frequency and a voltage, they are most often referred to by the
frequency component alone.”</em></p>
<h3 id="the-cpufreq-driver">The CPUFreq driver</h3>
<p><em><span class="dquo">“</span>Linux has a component named <code>CPUFreq</code> that manages the transitions
between OPPs. It is part of the board support for the package for each
SoC. <code>CPUFreq</code> consists of drivers in <code>drivers/cpufreq</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>It is controlled per-<span class="caps">CPU</span> via the <code>/sys/devices/system/cpu/cpuN/cpufreq</code>
directory, with <code>N</code> being the <span class="caps">CPU</span> number.”</em></p>
<h2 id="selecting-the-best-idle-state">Selecting the best idle state</h2>
<p><em><span class="dquo">“</span>Most CPUs have multiple idle states that use varying amounts of power.
Usually, there is a trade-off between the power usage and the latency, or
the length of time, it takes to exit the state. In the <span class="caps">ACPI</span> specification,
they are called </em><em>C-states</em><em>.”</em></p>
<p><em><span class="dquo">“</span>The key to selecting the right idle state is to have a good idea of how 
long the <span class="caps">CPU</span> is going to be quiescent.”</em></p>
<p><em><span class="dquo">“</span>[Monitor] the current <span class="caps">CPU</span> load: if it is high now, it is likely to
continue to be so in the immediate future, so a deep sleep would not be
beneficial. Even if the load is low, it is worth looking to see whether 
there is a timer event that expires soon. If there is no load and
no timer, then a deeper idle state is justified.”</em></p>
<p><em><span class="dquo">“</span>The part of Linux that selects the best idle state is the CPUIdle 
driver. There is a good deal of information about it in the kernel source
code in the <code>Documentation/cpuidle</code> directory.”</em></p>
<h3 id="the-cpuidle-driver">The CPUIdle driver</h3>
<p><em><span class="dquo">“</span>CPUIdle exposes information about each of the idle states in the
<code>/sys/devices/system/cpu/cpu0/cpuidle</code> directory, in which there is a
subdirectory for each of the sleep states, named <code>state0</code> to <code>stateN</code>.
<code>state0</code> is the </em><em>lightest</em><em> sleep and <code>stateN</code> the deepest. Note that
the numbering does not match that of the C-states and that
CPUIdle does not have a state equivalent to <code>C0</code> (running)”</em></p>
<h3 id="tickless-operation">Tickless operation</h3>
<p><em><span class="dquo">“</span>A related topic is the tickles, or <code>NOHZ</code>, option. If the system is
truly idle, the most likely source of interruptions will be the system
timer, which is programmed to generate a regular time tick at a rate of
<code>HZ</code> per second, where <code>HZ</code> is typically 100. Historically, Linux uses the
timer tick as the main time base for measuring time-outs.”</em></p>
<p><em><span class="dquo">“</span>And yet it is plainly wasteful to wake the <span class="caps">CPU</span> up to process a timer 
interruption if no timer events are registered for that particular moment.
The dynamic tick kernel configuration option, <code>CONFIG_NO_HZ</code>, looks at the
timer queue at the end of the timer processing routine
and schedules the next interruption at the time of the next event”</em></p>
<p><em><span class="dquo">“</span>In any power-sensitive application, the kernel should be configured
with this option enabled.”</em></p>
<h2 id="powering-down-peripherals">Powering down peripherals</h2>
<p><em><span class="dquo">“</span>This is managed by the </em><em>runtime power management</em><em> system, or
</em><em>runtime pm</em><em> for short. It works with drivers that support runtime pm,
shutting down those that are not in use and waking them again when they
are next needed. It is dynamic and should be transparent to user space.”</em></p>
<p><em><span class="dquo">“</span>The runtime power management is exposed via a <code>sysfs</code> interface. Each
device has a subdirectory named <code>power</code>, in which you will find 
[different] files.”</em></p>
<p>Check the book for more information about the files.</p>
<p><em><span class="dquo">“</span>For more information on runtime pm, look in the kernel source code at
<code>Documentation/power/runtime_pm.txt</code>.”</em></p>
<h2 id="putting-the-system-to-sleep">Putting the system to sleep</h2>
<p><em><span class="dquo">“</span>In the Linux kernel, this is known as </em><em>system sleep</em><em>. It is usually user-initiated”</em></p>
<p><em><span class="dquo">“</span>There are usually two options: suspend or hibernate. The first,
also known as </em><em>suspend to <span class="caps">RAM</span></em><em>, shuts everything down except the
system memory, so the machine is still consuming a little power.”</em></p>
<p><em><span class="dquo">“</span>If I select the </em><em>hibernate</em><em> option, the contents of memory are saved
to the hard drive. The system consumes no power at all, and so it can stay
in this state indefinitely, but on wake-up, it takes some time to restore
the memory from disk. Hibernate is very seldom used in embedded systems”</em></p>
<p><em><span class="dquo">“</span>For more information, look at the kernel source code in the <code>Documentation/power</code> directory.”</em></p>
<h3 id="power-states">Power states</h3>
<p><em><span class="dquo">“</span>In the <span class="caps">ACPI</span> specification, the sleep states are called </em><em>S-states</em><em>. Linux supports four sleep states.”</em></p>
<p>See the book for more details.</p>
<p><em><span class="dquo">“</span>Not all systems have support for all states. You can find out which are available by reading the <code>/sys/power/state</code> file”</em></p>
<p><em><span class="dquo">“</span>To enter one of the system sleep states, you just have to write the 
desired state to <code>/sys/power/state</code>.”</em></p>
<div class="highlight"><pre><span></span><code><span class="nb">echo</span> mem &gt; /sys/power/state
</code></pre></div>
<h3 id="wakeup-events">Wakeup events</h3>
<p><em><span class="dquo">“</span>Before you suspend a device, you must have a method of waking it again.”</em></p>
<p><em><span class="dquo">“</span>Some parts of the system have to remain powered on even during the
deepest sleep. This usually involves the </em><em>Power Management <span class="caps">IC</span></em><em> 
(</em><em><span class="caps">PMIC</span></em><em>), the </em><em>real-time clock</em><em> (</em><em><span class="caps">RTC</span></em><em>), and may additionally 
include interfaces such as <span class="caps">GPIO</span>, <span class="caps">UART</span>, and Ethernet.”</em></p>
<p><em><span class="dquo">“</span>Wakeup events are controlled through <code>sysfs</code>. Each device in
<code>/sys/device</code> has a subdirectory power containing a <code>wakeup</code> file”</em></p>
<p>See the book for more information.</p>
<p><em><span class="dquo">“</span>To get a list of devices that can generate wakeups, we can search for
all devices where wakeup contains either <code>enabled</code> or <code>disabled</code>:”</em></p>
<div class="highlight"><pre><span></span><code>find /sys/devices -name wakeup <span class="p">|</span> xargs grep “abled”
</code></pre></div>
<h3 id="timed-wakeups-from-the-real-time-clock">Timed wakeups from the real-time clock</h3>
<p><em><span class="dquo">“</span>Most systems have an <span class="caps">RTC</span> that can generate alarm interruptions up to
24 hours in the future. If so, the directory <code>/sys/class/rtc/rtc0</code> will
exist. It should contain the <code>wakealarm</code> file. Writing a number to
<code>wakealarm</code> will cause it to generate an alarm that number of seconds
later. If you also enable wake up events from <code>rtc</code>, it will resume a
suspended device.”</em></p>
<h2 id="summary_5">Summary</h2>
<p><em><span class="dquo">“</span>The majority of the power management is done for you by the <span class="caps">BSP</span>.”</em></p>
<h1 id="chapter-12-learning-about-processes-and-threads">Chapter 12. Learning About Processes and Threads</h1>
<h2 id="processes">Processes</h2>
<p><em><span class="dquo">“</span>A process holds the environment in which threads can run: it holds the memory mappings, the file descriptors, the user and group IDs, and more.”</em></p>
<p><em><span class="dquo">“</span>Creating a new process The <span class="caps">POSIX</span> function to create a process is 
<code>fork(2)</code>. It is an odd function because for each successful call,
there are two returns: one in the process that made the call,
known as the <code>Parent</code>, and one in the newly created process, known
as the <code>Child</code>.”</em></p>
<p><em><span class="dquo">“</span>Immediately after the call, the child is an exact copy of the
parent: it has the same stack, the same heap, the same file
descriptors, and it executes the same line of code, the one
following <code>fork</code>. The only way the programmer can tell them apart 
is by looking at the return value of <code>fork</code>: it is zero for the 
child and greater than zero for the parent. Actually, the value 
returned to the parent is the <span class="caps">PID</span> of the newly created child 
process. There is a third possibility, which is that the return 
value is negative, which means that the fork call failed and there
is still only one process.”</em></p>
<p><em><span class="dquo">“</span>Although the two processes are initially identical, they are in 
separate address spaces.”</em></p>
<h3 id="terminating-a-process">Terminating a process</h3>
<p><em><span class="dquo">“</span>[A process can be stopped by] calling the <code>exit(3)</code> function or,
involuntarily, by receiving a signal that is not handled. One
signal, in particular, <code>SIGKILL</code>, cannot be handled and so will
always kill a process.”</em></p>
<p><em><span class="dquo">“</span>[When a process is terminated] the system sends a signal, 
<code>SIGCHLD</code>, to the parent so that it knows this has happened.”</em></p>
<p><em><span class="dquo">“</span>Processes have a return value that is composed of either the 
argument to <code>exit</code>, if it terminated normally, or the signal 
number if it was killed.”</em></p>
<p><em><span class="dquo">“</span>The child process inherits most of the attributes of the parent, 
including the user and group IDs, all open file descriptors, 
signal handling, and scheduling characteristics.”</em></p>
<h3 id="running-a-different-program">Running a different program</h3>
<p><em><span class="dquo">“</span>The <code>fork</code> function creates a copy of a running program, but it 
does not run a different program. For that, you need one of the 
<code>exec</code> functions.”</em></p>
<p><em><span class="dquo">“</span>If the function [<code>exec\*</code>] succeeds, the kernel discards all the 
resources of the current process, including memory and file 
descriptors, and allocates memory to the new program being loaded. 
When the thread that called <code>exec\*</code> returns, it returns not to 
the line of code after the call but to the <code>main()</code> function of 
the new program.”</em></p>
<p><em><span class="dquo">“</span>It is common for a <code>fork</code> to be followed almost immediately by 
one of the <code>exec</code> functions.”</em></p>
<h3 id="inter-process-communication">Inter-process communication</h3>
<p><em><span class="dquo">“</span>Message-based protocols are usually easier to program and debug 
than shared memory but are slow if the messages are large or many.”</em></p>
<h4 id="summary-of-message-based-ipc">Summary of message-based <span class="caps">IPC</span></h4>
<p><em><span class="dquo">“</span>Unix sockets are used most often because they offer all that is 
needed, except perhaps message priority.”</em></p>
<p><em><span class="dquo">“</span>There are also higher-level abstractions, in particular, D-Bus, 
which are moving from mainstream Linux to embedded devices. D-Bus 
uses Unix sockets and shared memory under the surface.”</em></p>
<h4 id="shared-memory-based-ipc">Shared memory-based <span class="caps">IPC</span></h4>
<p><em><span class="dquo">“</span>Sharing memory removes the need for copying data between address
spaces, but introduces the problem of synchronizing accesses to
it. Synchronization between processes is commonly achieved using semaphores.”</em></p>
<h2 id="threads">Threads</h2>
<h3 id="creating-a-new-thread">Creating a new thread</h3>
<p><em><span class="dquo">“</span>[When running <code>ps</code>] <span class="caps">LWP</span> stands for </em><em>Light Weight Process</em><em>,
which, in this context, is another name for a thread.”</em></p>
<h3 id="terminating-a-thread">Terminating a thread</h3>
<p><em><span class="dquo">“</span>Note that if a multithreaded program calls <code>fork</code>, only the thread 
that made the call will exist in the new child process. Fork does 
not replicate all threads.”</em></p>
<h3 id="compiling-a-program-with-threads">Compiling a program with threads</h3>
<p><em><span class="dquo">“</span>When building a threaded program, you must add the <code>-pthread</code>
switch in the compile and link stages.”</em></p>
<h3 id="changing-conditions">Changing conditions</h3>
<p><em><span class="dquo">“</span>Cooperating threads need a method of alerting one another that
something has changed and needs attention. That thing is called a
condition and the alert is sent through a </em><em>condition variable</em><em>.”</em></p>
<p><em><span class="dquo">“</span>A condition is just something that you can test to give a <code>true</code>
or <code>false</code> result.”</em></p>
<p><em><span class="dquo">“</span>The only complexity [of condition variables] is that the
condition is, by definition, a shared resource and so has to be
protected by a mutex.”</em></p>
<h2 id="scheduling">Scheduling</h2>
<p><em><span class="dquo">“</span>The Linux scheduler has a queue of threads that are ready to
run, and its job is to schedule them on CPUs as they become
available. Each thread has a scheduling policy that may be
time-shared or real-time. The time-shared threads have a niceness
value that increases or reduces their entitlement to <span class="caps">CPU</span> time. The
real-time threads have a priority such that a higher prior”</em></p>
<p><em><span class="dquo">“</span>The scheduler runs when:</em></p>
<ul>
<li><em>A thread is blocked by calling <code>sleep()</code> or another blocking system call</em></li>
<li><em>A time-shared thread exhausts its time slice</em></li>
<li><em>An interruption causes a thread to be unblocked, for example, because of I/O completing”</em></li>
</ul>
<h3 id="fairness-versus-determinism">Fairness versus determinism</h3>
<p><em><span class="dquo">“</span>If you have a real-time program, fairness is not helpful.
Instead, you then want a policy that is deterministic, which will
give you at least minimal guarantees that your real-time threads
will be scheduled at the right time so that they don’t miss their
deadlines. This means that a real-time thread must preempt
time-shared threads. Real-time threads also have a static priority
that the scheduler can use to choose between them “</em></p>
<p><em><span class="dquo">“</span>Both types of thread can coexist. Those requiring deterministic
scheduling are scheduled first and the time remaining is divided
between the time-shared threads.”</em></p>
<h3 id="time-shared-policies">Time-shared policies</h3>
<p><em><span class="dquo">“</span>The scheduler used has been </em><em>Completely Fair Scheduler</em><em>
(</em><em><span class="caps">CFS</span></em><em>). It does not use timeslices in the normal sense of the
word. Instead, it calculates a running tally of the length of time
a thread would be entitled to run if it had its fair share of <span class="caps">CPU</span>
time, and it balances that with the actual amount of time it has
run for. If it exceeds its entitlement and there are other
time-shared threads waiting to run, the scheduler will suspend the
thread and run a waiting thread instead.”</em></p>
<p><em><span class="dquo">“</span>The time-shared policies are as follows:</em></p>
<ul>
<li><em><code>SCHED_NORMAL</code> (also known as <code>SCHED_OTHER</code>): This is the default policy. The vast majority of Linux threads use this policy.</em></li>
<li><em><code>SCHED_BATCH</code>: This is similar to <code>SCHED_NORMAL</code> except that threads are scheduled with a larger granularity […]. The intention is to reduce the number of context switches for background processing (batch jobs) and reduce the amount of <span class="caps">CPU</span> cache churn.</em></li>
<li><em><code>SCHED_IDLE</code>: These threads are run only when there are no threads of any other policy ready to run. It is the lowest possible priority.”</em></li>
</ul>
<h4 id="niceness">Niceness</h4>
<p><em><span class="dquo">“</span>A thread becomes <code>nice</code> by reducing its load on the system, or moves in the opposite direction by increasing it. The range of values is from <code>19</code>, which is really nice, to <code>-20</code>, which is really not nice. The default value is <code>0</code>.”</em></p>
<p><em><span class="dquo">“</span>The nice value can be changed for <code>SCHED_NORMAL</code> and <code>SCHED_BATCH</code> threads.”</em></p>
<p><em><span class="dquo">“</span>You can use a <span class="caps">TID</span> in place of a <span class="caps">PID</span> to change the <code>nice</code> value of an individual thread. “</em></p>
<h3 id="real-time-policies">Real-time policies</h3>
<p><em><span class="dquo">“</span>Real-time policies are intended for determinism. The real-time
scheduler will always run the highest priority real-time thread
that is ready to run. Real-time threads always preempt timeshare
threads. In essence, by selecting a real-time policy over a
timeshare policy, you are saying that you have inside knowledge of
the expected scheduling of this thread and wish to override the
scheduler’s built-in assumptions.</em>”</p>
<p><em><span class="dquo">“</span>There are two real-time policies:</em></p>
<ul>
<li><em><code>SCHED_FIFO</code>: This is a run to completion algorithm, which means that once the thread starts to run, it will continue until it is preempted by a higher priority real-time thread, it is blocked in a system call, or until it terminates (completes).</em></li>
<li><em><code>SCHED_RR</code>: This a round robin algorithm that will cycle between threads of the same priority if they exceed their time slice, which is 100 ms by default. [It is] possible to control the timeslice value through /proc/sys/kernel/sched_rr_timeslice_ms. Apart from this, it behaves in the same way as SCHED_FIFO.”</em></li>
</ul>
<p><em><span class="dquo">“</span>Each real-time thread has a priority in the range 1 to 99, with 99 being the highest.”</em></p>
<p><em><span class="dquo">“</span>The scheduler has, by default, reserved 5% of <span class="caps">CPU</span> time for non- real-time threads so that even a runaway real-time thread cannot completely halt the system. It is configured via two kernel controls:</em></p>
<ul>
<li><em><code>/proc/sys/kernel/sched_rt_period_us</code></em></li>
<li><em><code>/proc/sys/kernel/sched_rt_runtime_u</code><span class="dquo">“</span></em></li>
</ul>
<p><em><span class="dquo">“</span>[Another] option is to use a watchdog, either hardware or software, to monitor the execution of key threads.”</em></p>
<h3 id="choosing-a-real-time-priority">Choosing a real-time priority</h3>
<p><em><span class="dquo">“</span>The most widely used procedure for choosing priorities is known 
as </em><em>Rate Monotonic Analysis</em><em> (</em><em><span class="caps">RMA</span></em><em>).”</em></p>
<p><em><span class="dquo">“</span>The goal is to balance the load so that all threads can complete their execution phase before the next period.”</em></p>
<h1 id="chapter-13-managing-memory">Chapter 13. Managing Memory</h1>
<h2 id="virtual-memory-basics">Virtual memory basics</h2>
<p><em><span class="dquo">“</span>Linux divides this virtual address space into an area for applications, called </em><em>user space</em><em>, and an area for the kernel, called </em><em>kernel space</em><em>. The split between the two is set by a kernel configuration parameter named <code>PAGE_OFFSET</code>.”</em></p>
<p><em><span class="dquo">“</span>The user address space is allocated per process so that each process runs in a sandbox, separated from the others. The kernel address space is the same for all processes: there is only one kernel.”</em></p>
<p><em><span class="dquo">“</span>Each page of virtual memory may be:</em></p>
<ul>
<li><em>Unmapped, so that trying to access these addresses will result in a <code>SIGSEGV</code></em></li>
<li><em>Mapped to a page of physical memory that is private to the process</em></li>
<li><em>Mapped to a page of physical memory that is shared with other processes</em></li>
<li><em>Mapped and shared with a copy on write (CoW) flag set: a write is trapped in the kernel, which makes a copy of the page and maps it to the process in place of the original page before allowing the write to take place</em></li>
<li><em>Mapped to a page of physical memory that is used by the kernel”</em></li>
</ul>
<p><em><span class="dquo">“</span>The kernel may additionally map pages to reserved memory regions, for example, to access registers and memory buffers in device drivers.”</em></p>
<p><em><span class="dquo">“</span>The default allocation strategy is to over-commit, which leads to tricky out-of-memory situations.”</em></p>
<p><em><span class="dquo">“</span>The delays introduced by the memory management code in handling exceptions - page faults - make the system less deterministic, which is important for real-time programs.”</em></p>
<h2 id="kernel-space-memory-layout">Kernel space memory layout</h2>
<p><em><span class="dquo">“</span>Kernel memory […] is not demand-paged, which means that for every allocation using <code>kmalloc()</code> or a similar function, there is real physical memory. Kernel memory is never discarded or paged out.”</em></p>
<h3 id="how-much-memory-does-the-kernel-use">How much memory does the kernel use?</h3>
<p><em><span class="dquo">“</span>You can see the memory taken up by the kernel code and data in the kernel log […] or you can use the <code>size</code> command, as follows:”</em></p>
<div class="highlight"><pre><span></span><code>arm-poky-linux-gnueabi-size vmlinux
</code></pre></div>
<p><em><span class="dquo">“</span>There is an ongoing effort to allow small kernels to be built: […] <a href="https://tiny.wiki.kernel.org">Linux Kernel Tinification</a>.”</em></p>
<p><em><span class="dquo">“</span>You can get more information about memory usage by reading <code>/proc/meminfo</code>.”</em></p>
<p><em><span class="dquo">“</span>There is a description of each of [the] fields on the manual page <code>proc(5)</code>. “</em></p>
<p><em><span class="dquo">“</span>With modules, you can use <code>lsmod</code> to find out the memory space taken up”</em></p>
<h2 id="user-space-memory-layout">User space memory layout</h2>
<p><em><span class="dquo">“</span>Linux employs a lazy allocation strategy for user space, only mapping physical pages of memory when the program accesses it.”</em></p>
<p><em><span class="dquo">“</span>For example, allocating a buffer […] using <code>malloc(3)</code> returns a pointer to a block of memory addresses but no actual physical memory. A flag is set in the page 
table entries such that any read or write access is trapped by the kernel. This is known as a </em><em>page fault</em><em>. Only at this point does the kernel attempt to find a page 
of physical memory and add it to the page table mapping for the process.”</em></p>
<p><em><span class="dquo">“</span>There are two kinds of page faults: </em><em>minor</em><em> and </em><em>major</em><em>. With a minor fault, the kernel just has to find a page of physical memory and map it to the process 
address space […]. A major page fault occurs when the virtual memory is mapped to a file, for example, using <code>mmap(2)</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>Major faults are much more expensive in time and system resources.”</em></p>
<h2 id="the-process-memory-map">The process memory map</h2>
<p><em><span class="dquo">“</span>You can see the memory map for a process through the <code>proc</code> filesystem.”</em></p>
<p><em><span class="dquo">“</span>The maximum size of [the heap and stack] is controlled by the process’s ulimit:</em></p>
<ul>
<li><em>Heap: <code>ulimit -d</code>, default unlimited</em></li>
<li><em>Stack: <code>ulimit -s</code>, default 8 MiB”</em></li>
</ul>
<p><em><span class="dquo">“</span>Allocations that exceed the limit are rejected by <code>SIGSEGV</code>.”</em></p>
<h2 id="swapping">Swapping</h2>
<p><em><span class="dquo">“</span>On a system that has too little real memory for the workload it is carrying and so swapping becomes the main activity. This is sometimes known as
</em><em>disk thrashing</em><em>.”</em></p>
<p><em><span class="dquo">“</span>Swap is seldom used on embedded devices because it does not work well with flash storage, where constant writing would wear it out quickly. However, you may want to 
consider swapping to compressed <span class="caps">RAM</span> (zram).”</em> ​</p>
<h2 id="mapping-memory-with-mmap">Mapping memory with mmap</h2>
<p><em><span class="dquo">“</span>A process can also manipulate its memory map in an explicit way
using <code>mmap(2)</code><span class="dquo">“</span></em></p>
<h3 id="using-mmap-to-access-device-memory">Using mmap to access device memory</h3>
<p><em><span class="dquo">“</span>One example is the Linux framebuffer, <code>/dev/fb0</code>. The interface is
defined in <code>/usr/include/linux/fb.h</code>, including an <code>ioctl</code> function to get
the size of the display and the bits per pixel. You can then use <code>mmap</code> to
ask the video driver to share the framebuffer with the application and
read and write pixels.”</em></p>
<h2 id="how-much-memory-does-my-application-use">How much memory does my application use?</h2>
<p><em><span class="dquo">“</span>Linux believes that free memory is wasted memory and the kernel uses
free memory for buffers and caches with the knowledge that they can be
shrunk when the need arises.”</em></p>
<h2 id="per-process-memory-usage">Per-process memory usage</h2>
<p><em><span class="dquo">“</span>The ps and top commands [show]:</em></p>
<ul>
<li><em>Vss [virtual set size]: Called <span class="caps">VSZ</span> in the <code>ps</code> command and <span class="caps">VIRT</span> in <code>top</code>, this is the total amount of memory mapped by a process. It is the sum of all the regions shown in <code>/proc/&lt;PID&gt;/map</code>. This number is of limited interest since only part of the virtual memory is committed to physical memory at any time.</em></li>
<li><em>Rss [resident memory size]: Called <span class="caps">RSS</span> in <code>ps</code> and <span class="caps">RES</span> in <code>top</code>, this is the sum of memory that is mapped to physical pages of memory. This gets closer to the actual memory budget of the process, but there is a problem: if you add the Rss of all the processes, you will get an overestimate of the memory in use because some pages will be shared.”</em></li>
</ul>
<h3 id="using-smem">Using smem</h3>
<p><em><span class="dquo">“</span>[There are 2 more metrics]: </em><em>unique set size</em><em>, or </em><em>Uss</em><em>, and </em><em>proportional set size</em><em>, or </em><em>Pss</em><em>”</em></p>
<p>Check the book for more information.</p>
<p><em><span class="dquo">“</span>Information about Pss is available in <code>/proc/&lt;PID&gt;/smaps</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>There is a tool named </em><em>smem</em><em> that collates information from the smaps files and presents it in various ways”</em></p>
<h2 id="identifying-memory-leaks">Identifying memory leaks</h2>
<h3 id="mtrace">mtrace</h3>
<p><em><span class="dquo">“</span></em><em>mtrace</em><em> is a component of glibc that traces calls to malloc , free , and related functions.”</em></p>
<h2 id="running-out-of-memory">Running out of memory</h2>
<p><em><span class="dquo">“</span>There is a tuning parameter for kernel allocations in <code>/proc/sys/vm/overcommit_memory</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>There is another important variable in <code>/proc/meminfo:Committed_AS</code>. This is the total
amount of memory that is needed to fulfill all the allocations made so far.”</em></p>
<p><em><span class="dquo">“</span>The final defense is <code>oom-killer</code>. It uses a heuristic method to calculate a badness score between 0 and 1,000 for each process,
and then terminates those with the highest score until there is enough free memory.”</em></p>
<p><em><span class="dquo">“</span>You can influence the badness score for a process by writing an adjustment value to
<code>/proc/&lt;PID&gt;/oom_score_adj</code>.”</em></p>
<h1 id="chapter-14-debugging-with-gdb">Chapter 14. Debugging with <span class="caps">GDB</span></h1>
<h2 id="preparing-to-debug">Preparing to debug</h2>
<p><em><span class="dquo">“</span>In most cases, <code>-g</code> suffices: reserve <code>-g3</code> or <code>-ggdb3</code> for if you are having problems stepping through code, especially if it contains macros.”</em></p>
<p><em><span class="dquo">“</span>You will most likely need to compile without optimization, leaving out the <code>-O</code> compile switch, or using <code>-Og</code>, which enables optimizations that do not interfere with debugging.”</em></p>
<p><em><span class="dquo">“</span>On some architectures, <span class="caps">GCC</span> will not generate stack-frame pointers with the higher levels of optimization (<code>-O2</code> and above). If you find yourself in the situation that you really have to compile with <code>-O2</code> but still want backtraces, you can override the default behavior with <code>-fno-omit-frame-pointer</code>.”</em></p>
<h2 id="debugging-applications">Debugging applications</h2>
<h3 id="remote-debugging-using-gdbserver">Remote debugging using gdbserver</h3>
<p><em><span class="dquo">“</span><code>gdbserver</code> connects to a copy of <span class="caps">GDB</span> running on the host machine via a network connection or a serial interface.”</em></p>
<p><em><span class="dquo">“</span>Debugging through <code>gdbserver</code> is almost, but not quite, the same as debugging natively. The differences are mostly centered around the fact that there are two computers involved and they have to be in the right state for debugging to take place. Here are some things to look out for [check the book for more details]:</em></p>
<ul>
<li><em><span class="caps">GDB</span>, running on the host, needs to be told where to look for debug symbols and source code, especially for shared libraries.</em></li>
<li><em>The <span class="caps">GDB</span> <code>run</code> command does not work as expected.</em></li>
<li><em>You need debug symbols and source code for the binaries you want to debug on the host, but not on the target. Often, there is not enough storage space for them on the target, and they will need to be stripped before deploying to the target</em></li>
<li><em>The <span class="caps">GDB</span>/gdbserver combination does not support all the features of natively running <span class="caps">GDB</span>: for example, gdbserver cannot follow the child process after a <code>fork</code>, whereas native <span class="caps">GDB</span> can.”</em></li>
</ul>
<p><em><span class="dquo">“</span>For applications and shared libraries, <code>--strip-all</code> (the default) is fine, but when it comes to kernel modules, you will find that it will stop the module from loading. Use <code>--strip-unneeded</code> instead. “</em></p>
<h2 id="starting-to-debug">Starting to debug</h2>
<h3 id="connecting-gdb-and-gdbserver">Connecting <span class="caps">GDB</span> and gdbserver</h3>
<p><em>” In the case of a network connection, you launch <code>gdbserver</code> with the <span class="caps">TCP</span> port number to listen on and, optionally, an <span class="caps">IP</span> address to accept connections from. In most cases, you don’t care which <span class="caps">IP</span> address is going to connect, so you can just provide the port number. In this example, <code>gdbserver</code> waits for a connection on port 10000 from any host:”</em></p>
<div class="highlight"><pre><span></span><code>gdbserver :10000 ./hello-world
</code></pre></div>
<p><em><span class="dquo">“</span>Next, start the copy of <span class="caps">GDB</span> from your toolchain, pointing it at an unstripped copy of the program so that <span class="caps">GDB</span> can load the symbol table:”</em></p>
<div class="highlight"><pre><span></span><code>arm-poky-linux-gnueabi-gdb hello-world
</code></pre></div>
<p><em><span class="dquo">“</span>In <span class="caps">GDB</span>, use the command <code>target remote</code> to make the connection to <code>gdbserver</code>, giving it the <span class="caps">IP</span> address or hostname of the target and the port it is waiting on:”</em></p>
<div class="highlight"><pre><span></span><code><span class="o">(</span>gdb<span class="o">)</span> target remote <span class="m">192</span>.168.1.101:10000
</code></pre></div>
<p><em><span class="dquo">“</span>The procedure is similar for a serial connection. On the target, you tell gdbserver which serial port to use:”</em></p>
<div class="highlight"><pre><span></span><code>gdbserver /dev/ttyO0 ./hello-world
</code></pre></div>
<p><em><span class="dquo">“</span>You may need to configure the port baud rate beforehand using <code>stty(1)</code> or a similar program”</em></p>
<p><em><span class="dquo">“</span>The port must not be being used for anything else. For example, you can’t use a port that is being used as the system console. “</em></p>
<p><em><span class="dquo">“</span>On the host, you make the connection to gdbserver using <code>target remote</code> plus the serial device at the host end of the cable. In most cases, you will want to set the baud rate of the host serial port first, using the <span class="caps">GDB</span> command <code>set serial baud</code>:”</em></p>
<div class="highlight"><pre><span></span><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set</span> serial baud <span class="m">115200</span>
<span class="o">(</span>gdb<span class="o">)</span> target remote /dev/ttyUSB0
</code></pre></div>
<h3 id="setting-the-sysroot">Setting the sysroot</h3>
<p><em><span class="caps">GDB</span> needs to know where to find debug information and source code for the program and shared libraries you are debugging. When debugging natively, the paths are well known and built in to <span class="caps">GDB</span>, but when using a cross toolchain, <span class="caps">GDB</span> has no way to guess where the root of the target filesystem is. You have to give it this information.”</em></p>
<div class="highlight"><pre><span></span><code> <span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set</span> sysroot /opt/poky/2.2.1/sysroots/cortexa8hf-neon-poky-linux-gnueabi
</code></pre></div>
<p><em><span class="dquo">“</span><span class="caps">GDB</span> also needs to find the source code for the files you are debugging. <span class="caps">GDB</span> has a search path for source files, which you can see using the command <code>show directories</code>.”</em></p>
<p><em><span class="dquo">“</span><code>$cwd</code> is the current working directory of the <span class="caps">GDB</span> instance running on the host; <code>$cdir</code> is the directory where the source was compiled. The latter is encoded into the object files with the tag <code>DW_AT_comp_dir</code>. You can see these tags using <code>objdump --dwarf</code>.”</em></p>
<p><em><span class="dquo">“</span>You may have additional shared libraries that are stored outside the <code>sysroot</code>. In that case, you can use <code>set solib-search-path</code>, which can contain a colon-separated list of directories to search for shared libraries.”</em></p>
<p><em><span class="dquo">“</span>[Another] way of telling <span class="caps">GDB</span> where to look for source code, for both libraries and programs, is using the <code>directory</code> command. […] Paths added in this way take precedence because they are searched before those from <code>sysroot</code> or <code>solib-search-path</code>.”</em></p>
<h2 id="just-in-time-debugging">Just-in-time debugging</h2>
<p><em><span class="dquo">“</span>In the case of remote debugging, you need to find the <span class="caps">PID</span> of the process to be debugged and pass it to <code>gdbserver</code> with the <code>--attach</code> option.”</em></p>
<div class="highlight"><pre><span></span><code>gdbserver --attach :10000 <span class="m">109</span>
</code></pre></div>
<p><em><span class="dquo">“</span>When you are done, you can detach, allowing the program to continue running without the debugger:”</em></p>
<div class="highlight"><pre><span></span><code><span class="o">(</span>gdb<span class="o">)</span> detach
</code></pre></div>
<h2 id="debugging-forks-and-threads">Debugging forks and threads</h2>
<p><em><span class="dquo">“</span>Does the debug session follow the parent process or the child? This behavior is controlled by <code>follow-fork-mode</code>, which may be <code>parent</code> or <code>child</code>, with <code>parent</code> being the default. Unfortunately, current versions of <code>gdbserver</code> do not support this option, so it only works for native debugging.”</em></p>
<p><em><span class="dquo">“</span>There is a way to modify the way in which <span class="caps">GDB</span> handles stopped threads, through a parameter called <code>scheduler-locking</code>. Normally it is <code>off</code>, but if you set it to <code>on</code>, only the thread that was stopped at the breakpoint is resumed and the others remain stopped, giving you a chance to see what the thread alone does without interference. This continues to be the case until you turn <code>scheduler-locking off</code>. Gdbserver supports this feature.”</em></p>
<h2 id="core-files">Core files</h2>
<p><em><span class="dquo">“</span>Core files are not created by default, but only when the core file resource limit for the process is non-zero. You can change it for the current shell using <code>ulimit -c</code>.”</em></p>
<p><em><span class="dquo">“</span>There are two files that control the naming and placement of core files. The first is <code>/proc/sys/kernel/core_uses_pid</code>. Writing a <code>1</code> to it causes the <span class="caps">PID</span> number of the dying process to be appended to the filename. […] Much more useful is <code>/proc/sys/kernel/core_pattern</code>, which gives you a lot more control over core files.”</em></p>
<p><em><span class="dquo">“</span>You can also use a pattern that begins with an absolute directory name so that all core files are gathered together in one place.”</em></p>
<h3 id="using-gdb-to-look-at-core-files">Using <span class="caps">GDB</span> to look at core files</h3>
<p><em><span class="dquo">“</span>Here is a sample <span class="caps">GDB</span> session looking at a core file:”</em></p>
<div class="highlight"><pre><span></span><code>arm-poky-linux-gnueabi-gdb sort-debug /tmp/corefiles/core.sort-debug.1431425613
</code></pre></div>
<p>[Then use following commands]</p>
<div class="highlight"><pre><span></span><code><span class="o">(</span>gdb<span class="o">)</span> list
...
...
<span class="o">(</span>gdb<span class="o">)</span> bt
...
</code></pre></div>
<h2 id="debugging-kernel-code">Debugging kernel code</h2>
<h3 id="debugging-kernel-code-with-kgdb">Debugging kernel code with kgdb</h3>
<p><em><span class="dquo">“</span>The kernel is a complex system, with real-time behaviors. Don’t expect debugging to be as easy as it is for applications. Stepping through code that changes the memory mapping or switches context is likely to produce odd results.”</em></p>
<p><em><span class="dquo">“</span><code>kgdb</code> is the name given to the kernel <span class="caps">GDB</span> stubs that have been part of mainline Linux for many years now. There is a user manual in the kernel DocBook, and you can find an online version at https://www.kernel.org/doc/htmldocs/kgdb/index.html.”</em></p>
<p><em><span class="dquo">“</span>In addition to the <code>zImage</code> or <code>uImage</code> compressed kernel image, you will need the kernel image in <span class="caps">ELF</span> object format so that <span class="caps">GDB</span> can load the symbols into memory. This is the file called <code>vmlinux</code> that is generated in the directory where Linux is built.”</em></p>
<h3 id="debugging-modules">Debugging modules</h3>
<p><em><span class="dquo">“</span>The relocation addresses for each section of the module are stored in <code>/sys/module/&lt;module name&gt;/sections</code> [see also for hidden files, i.e .text].”</em></p>
<h3 id="debugging-kernel-code-with-kdb">Debugging kernel code with kdb</h3>
<p><em><span class="dquo">“</span>Although <code>kdb</code> does not have the features of <code>kgdb</code> and <span class="caps">GDB</span>, it does have its uses, and being self-hosted, there are no external dependencies to worry about. kdb has a simple command-line interface that you can use on a serial console. You can use it to inspect memory, registers, process lists, and <code>dmesg</code> and even set breakpoints to stop at a certain location.”</em></p>
<p><em><span class="dquo">“</span><code>kdb</code> is not a source-level debugger, so you can’t see the source code or single-step. However, you can display a backtrace using the <code>bt</code> command”</em></p>
<h3 id="looking-at-an-oops">Looking at an Oops</h3>
<p><em><span class="dquo">“</span>When the kernel performs an invalid memory access or executes an illegal instruction, a kernel Oops message is written to the kernel log.”</em></p>
<p><em><span class="dquo">“</span>[One] can use the <span class="caps">GDB</span> command disassemble with the <code>/s</code> modifier so that it shows source and assembler code together.”</em></p>
<div class="highlight"><pre><span></span><code>arm-poky-linux-gnueabi-gdb mbx.ko

:::bash
<span class="o">(</span>gdb<span class="o">)</span> disassemble /s mbx_write
</code></pre></div>
<blockquote>
<p>The offsets are displayed in decimal, not hex!</p>
</blockquote>
<h1 id="chapter-15-profiling-and-tracing">Chapter 15. Profiling and Tracing</h1>
<h2 id="poor-mans-profiler">Poor man’s profiler</h2>
<p><em><span class="dquo">“</span>You can profile an application just by using <span class="caps">GDB</span> to stop it at arbitrary intervals to see what it is doing. This is the </em><em>poor man’s profiler</em><em>. It is easy to set up and is one way of gathering profile data.”</em></p>
<p><a href="http://poormansprofiler.org">http://poormansprofiler.org</a></p>
<h2 id="introducing-perf">Introducing perf</h2>
<h3 id="configuring-the-kernel-for-perf">Configuring the kernel for perf</h3>
<p><em><span class="dquo">“</span>You need a kernel that is configured for <code>perf_events</code>, and you need the <code>perf</code> command cross compiled to run on the target. The relevant kernel configuration is <code>CONFIG_PERF_EVENTS</code>.”</em></p>
<p><em><span class="dquo">“</span>You will also need debug symbols on the target for the binaries that you are interested in profiling; otherwise, <code>perf</code> will not be able to resolve addresses to meaningful symbols.”</em></p>
<h3 id="profiling-with-perf">Profiling with perf</h3>
<p><em><span class="dquo">“</span>You can use <code>perf</code> to sample the state of a program using one of
the event counters and accumulate samples over a period of time to
create a profile. This is another example of statistical
profiling. The default event counter is called cycles, which is a
generic hardware counter that is mapped to a <span class="caps">PMU</span> register
representing a count of cycles at the core clock frequency.”</em></p>
<p><em><span class="dquo">“</span>By default, <code>perf record</code> samples at a frequency of 1000 Hz 
using the <code>cycles</code> counter.”</em></p>
<p><em><span class="dquo">“</span>A sampling frequency of 1000 Hz may be higher than you really
need, and may be the cause of an observer effect. Try with lower
rates: 100 Hz is enough for most cases, in my experience.”</em></p>
<h3 id="call-graphs">Call graphs</h3>
<p><em><span class="dquo">“</span>[To] see where […] functions are being called from. You can do 
that by capturing the backtrace from each sample, which you can do
with the <code>-g</code> option to <code>perf record</code>.”</em></p>
<h3 id="perf-annotate">perf annotate</h3>
<p><em><span class="dquo">“</span>Now that you know which functions to look at, it would be nice
to step inside and see the code and to have hit counts for each
instruction. That is what <code>perf annotate</code> does, by calling down to
a copy of <code>objdump</code> installed on the target. You just need to use
<code>perf annotate</code> in place of <code>perf report</code>.”</em></p>
<h2 id="introducing-ftrace">Introducing Ftrace</h2>
<p><em><span class="dquo">“</span>[The kernel function tracer]  is entirely implemented through 
virtual files in the <code>debugfs</code> filesystem.”</em></p>
<h2 id="using-lttng">Using LTTng</h2>
<p><em><span class="dquo">“</span>[LTTng covers] user space traces as well as the kernel.”</em></p>
<p><em><span class="dquo">“</span>LTTng consists of three components:</em>
- <em>A core session manager</em>
- <em>A kernel tracer implemented as a group of kernel modules</em>
- <em>A user space tracer implemented as a library”</em></p>
<p><em><span class="dquo">“</span>In addition to those, you will need a trace viewer such as 
<a href="http://www.efficios.com/babeltrace">Babeltrace</a> or the </em><em>Eclipse
Trace Compass plugin</em><em>.”</em></p>
<h3 id="using-lttng-for-kernel-tracing">Using LTTng for kernel tracing</h3>
<p><em><span class="dquo">“</span>LTTng can use the set of <code>ftrace</code> events […] as potential 
trace points. Initially, they are disabled.”</em></p>
<h2 id="using-valgrind">Using Valgrind</h2>
<h3 id="callgrind">Callgrind</h3>
<p><em><span class="dquo">“</span>Callgrind is only useful if your bottleneck is <span class="caps">CPU</span> bound. It’s 
not useful if heavy I/O or multiple processes are involved.”</em></p>
<h3 id="helgrind">Helgrind</h3>
<p><em><span class="dquo">“</span>This is a thread-error detector for detecting synchronization
errors in C, C++, and Fortran programs that include <span class="caps">POSIX</span> threads.”</em></p>
<h2 id="using-strace">Using strace</h2>
<p><em><span class="dquo">“</span>[<code>strace</code>] is a very simple tracer that captures system calls
made by a program and, optionally, its children”</em></p>
<p><em><span class="dquo">“</span><code>strace</code> uses the <code>ptrace(2)</code> function to hook calls as they are
made from user space to the kernel.”</em></p>
<h1 id="chapter-16-real-time-programming">Chapter 16. Real-Time Programming</h1>
<h2 id="what-is-real-time">What is real time?</h2>
<p><em><span class="dquo">“</span>A task is a real-time task if it has to complete before a
certain point in time, known as the </em><em>deadline</em><em>.”</em></p>
<p><em><span class="dquo">“</span>The other important thing to consider is the consequence of missing the deadline.”</em></p>
<ul>
<li><em><strong>Soft real-time</strong>: The deadline is desirable but is sometimes
missed without the system being considered a failure.</em></li>
<li><em><strong>Hard real-time</strong>: Here, missing a deadline has a serious
effect. We can further subdivide hard real-time into mission-
critical systems, in which there is a cost to missing the
deadline […] and safety-critical systems, in which there is a 
danger to life and limb”</em></li>
</ul>
<p><em><span class="dquo">“</span>A well-configured Linux system using a mainline kernel is good
for soft real-time tasks with deadlines down to tens of
milliseconds, and a kernel with the <code>PREEMPT_RT</code> patch is good for
soft and hard real-time mission-critical systems with deadlines
down to several hundreds of microseconds.”</em></p>
<blockquote>
<p>It is a myth of real-time computing that it is fast. This is not so,
the more deterministic a system is, the lower the maximum throughput.</p>
</blockquote>
<h2 id="identifying-sources-of-non-determinism">Identifying sources of non-determinism</h2>
<p><em><span class="dquo">“</span>Here are some problem areas:</em></p>
<ul>
<li><em><strong>Scheduling</strong>: Real-time threads must be scheduled before others, and so they must have a real-time policy, <code>SCHED_FIFO</code> or <code>SCHED_RR</code>. Additionally, they should have priorities assigned in descending order starting with the one with the shortest deadline, according to the theory of Rate Monotonic Analysis</em></li>
<li><em><strong>Scheduling latency</strong>: The kernel must be able to reschedule as soon as an event such as an interrupt or timer occurs, and not be subject to unbounded delays.</em></li>
<li><em><strong>Priority inversion</strong>: This is a consequence of priority-based scheduling, which leads to unbounded delays when a high-priority thread is blocked on a mutex held by a low-priority thread […] User space has priority inheritance and priority ceiling mutexes; in kernel space, we have rt-mutexes, which implement priority inheritance […]</em></li>
<li><em><strong>Accurate timers</strong>: If you want to manage deadlines in the region of low milliseconds or microseconds, you need timers that match. High-resolution timers are crucial and are a configuration option on almost all kernels.</em></li>
<li><em><strong>Page faults</strong>: A page fault while executing a critical section of code will upset all timing estimates. You can avoid them by locking memory</em></li>
<li><em><strong>Interrupts</strong>: They occur at unpredictable times and can result in an unexpected processing overhead if there is a sudden flood of them. There are two ways to avoid this. One is to run interrupts as kernel threads, and the other, on multi-core devices, is to shield one or more CPUs from interrupt handling.</em></li>
<li><em><strong>Processor caches</strong>: These provide a buffer between the <span class="caps">CPU</span> and the main memory and, like all caches, are a source of non-determinism, especially on multi-core devices.</em></li>
<li>*<em><em>Memory bus contention</em>: When peripherals access memory directly through a <span class="caps">DMA</span> channel, they use up a slice of memory bus bandwidth, which slows down access from the <span class="caps">CPU</span> core (or cores) and so contributes to non-deterministic execution of the program.”</em></li>
</ul>
<h2 id="kernel-preemption">Kernel preemption</h2>
<p><em><span class="dquo">“</span>Mainline Linux has three settings for preemption:</em></p>
<ul>
<li><em><code>CONFIG_PREEMPT_NONE</code>: No preemption</em></li>
<li><em><code>CONFIG_PREEMPT_VOLUNTARY</code>: This enables additional checks for requests for preemption</em></li>
<li><em>`CONFIG_PREEMPT: This allows the kernel to be preempted”</em></li>
</ul>
<p><em><span class="dquo">“</span>With preemption set to <code>none</code>, kernel code will continue without
rescheduling until it either returns via a <code>syscall</code> back to user
space, where preemption is always allowed, or it encounters a
sleeping wait that stops the current thread. […]  It is the
default for servers and some desktop kernels, where throughput is
more important than responsiveness.”</em></p>
<p><em><span class="dquo">“</span>[<code>CONFIG_PREEMPT</code>] is often described as a soft real-time option, and most embedded kernels are configured in this way.”</em></p>
<h2 id="the-real-time-linux-kernel-preempt_rt">The real-time Linux kernel (PREEMPT_RT)</h2>
<p><em><span class="dquo">“</span>The central plan is to reduce the amount of time the kernel spends running in an </em><em>atomic context</em><em>, which is where it is not safe to call the scheduler and switch to a different thread. Typical atomic contexts are when the kernel is in the following states:</em></p>
<ul>
<li><em>Running an interrupt or trap handler.</em></li>
<li><em>Holding a spinlock or in an <span class="caps">RCU</span> critical section. Spin lock and <span class="caps">RCU</span> are kernel-locking primitives</em></li>
<li><em>Between calls to <code>preempt_disable()</code> and <code>preempt_enable()</code>.</em></li>
<li><em>Hardware interrupts are disabled (IRQs off)”</em></li>
</ul>
<p><em><span class="dquo">“</span>The changes that are part of <code>PREEMPT_RT</code> fall into two main
areas: one is to reduce the impact of interrupt handlers by
turning them into kernel threads, and the other is to make locks
preemptible so that a thread can sleep while holding one. […]
there is a large overhead in these changes, which makes
average-case interrupt handling slower but much more deterministic.”</em></p>
<h3 id="threaded-interrupt-handlers">Threaded interrupt handlers</h3>
<p><em><span class="dquo">“</span>Not all interrupts are triggers for real-time tasks, but all
interrupts steal cycles from real-time tasks. Threaded interrupt
handlers allow a priority to be associated with the interrupt and
for it to be scheduled at an appropriate time.”</em></p>
<p><em><span class="dquo">“</span>You can make threaded IRQs the default by configuring the kernel 
with <code>CONFIG_IRQ_FORCED_THREADING=y</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>When you apply the <code>PREEMPT_RT</code> patches, interrupts are, by 
default, configured as threads in this way.”</em></p>
<p><em><span class="dquo">“</span>It is normal that the timer interrupt handler be run inline.”</em></p>
<p><em><span class="dquo">“</span>[See the book for a] suggested order of descending thread priorities”</em></p>
<p><em><span class="dquo">“</span>You can change the priorities using the <code>chrt</code> command as 
part of the boot script.”</em></p>
<h2 id="preemptible-kernel-locks">Preemptible kernel locks</h2>
<p><em><span class="dquo">“</span>A spin lock is a busy-wait mutex that does not require a context 
switch in the contended case, and so it is very efficient as long 
as the lock is held for a short time. Ideally, they should be 
locked for less than the time it would take to reschedule twice.”</em></p>
<p><em><span class="dquo">“</span>In mainline Linux, locking a spin lock disables kernel
preemption, creating an atomic context. This means that a low
priority thread that holds a spin lock can prevent a high-priority
thread from being scheduled.”</em></p>
<p><em><span class="dquo">“</span>The solution adopted by <code>PREEMPT_RT</code> is to replace almost all
spin locks with <span class="caps">RT</span>-mutexes. A mutex is slower than a spin lock,
but it is fully preemptible. Not only that, but <span class="caps">RT</span>-mutexes
implement priority inheritance and so are not susceptible to
priority inversion.”</em></p>
<h3 id="getting-the-preempt_rt-patches">Getting the PREEMPT_RT patches</h3>
<p><em><span class="dquo">“</span>The <span class="caps">RT</span> developers do not create patch sets for every kernel version because of the amount of effort involved.”</em></p>
<p><em><span class="dquo">“</span>The patches are available at
<a href="https://www.kernel.org/pub/linux/kernel/projects/rt">https://www.kernel.org/pub/linux/kernel/projects/rt</a>.”</em></p>
<p><em><span class="dquo">“</span>If you are using the Yocto Project, there is an <code>rt</code> version
of the kernel already.”</em></p>
<h2 id="high-resolution-timers">High-resolution timers</h2>
<p><em><span class="dquo">“</span>Timer resolution is important if you have precise timing
requirements, which is typical for real-time applications. The
default timer in Linux is a clock that runs at a configurable
rate, typically 100 Hz for embedded systems and 250 Hz for servers
and desktops. The interval between two timer ticks is known as a
</em><em>jiffy</em><em> and [is for example] 10 milliseconds on an embedded
SoC and four milliseconds on a server.”</em></p>
<h2 id="avoiding-page-faults">Avoiding page faults</h2>
<p><em><span class="dquo">“</span>A page fault occurs when an application reads or writes to
memory that is not committed to physical memory. It is impossible
(or very hard) to predict when a page fault will happen, so they
are another source of non-determinism in computers.
Fortunately, there is a function that allows you to commit all the
memory used by the process and lock it down so that it cannot
cause a page fault. It is <code>mlockall(2)</code><span class="dquo">“</span></em></p>
<h2 id="interrupt-shielding">Interrupt shielding</h2>
<p><em><span class="dquo">“</span>Using a multi-core processor, you can take a different approach
and shield one or more cores from processing interrupts
completely, allowing them to be dedicated to real-time tasks
instead. This works either with a normal Linux kernel or a
<code>PREEMPT_RT</code> kernel.”</em></p>
<p><em><span class="dquo">“</span>You can set the <span class="caps">CPU</span> affinity of a thread or process using the
command-line tool <code>taskset</code>, or you can use the
<code>sched_setaffinity(2)</code> and <code>pthread_setaffinity_np(3)</code> functions.”</em></p>
<p><em><span class="dquo">“</span>To set the affinity of an interrupt, first note that there is a
subdirectory for each interrupt number in
<code>/proc/irq/&lt;IRQ number&gt;</code>. The control files for the interrupt
are in there.”</em></p>
<h2 id="measuring-scheduling-latencies">Measuring scheduling latencies</h2>
<h3 id="cyclictest">cyclictest</h3>
<p><em><span class="dquo">“</span><code>cyclictest</code> measures scheduling latencies by comparing the
actual time taken for a sleep to the requested time. If there was
no latency, they would be the same, and the reported latency would
be zero. <code>cyclictest</code> assumes a timer resolution of less than one microsecond.”</em></p>
<p><em><span class="dquo">“</span>To be of real use, you would run tests over a 24-hour period
or longer while running a load representative of the maximum you expect.”</em></p>
<p><em><span class="dquo">“</span>Of the numbers produced by <code>cyclictest</code>, the maximum latency is
the most interesting, but it would be nice to get an idea of the
spread of the values. You can get that by adding <code>-h &lt;N&gt;</code> to
obtain a histogram of samples that are up to <code>N</code>
microseconds late.”</em></p>
<h3 id="using-ftrace">Using Ftrace</h3>
<p><em><span class="dquo">“</span>The kernel function tracer has tracers to help track down
kernel latencies.”</em></p>
<p><em><span class="dquo">“</span>Be aware that running Ftrace adds a lot of latency, in the order
of tens of milliseconds, every time it captures a new maximum,
which Ftrace itself can ignore. However, it skews the results of
user space tracers such as cyclictest. […] ignore the results of
<code>cyclictest</code> if you run it while capturing traces.”</em></p>
<h3 id="combining-cyclictest-and-ftrace">Combining cyclictest and Ftrace</h3>
<p><em><span class="dquo">“</span>If <code>cyclictest</code> reports unexpectedly long latencies, you can use
the <code>breaktrace</code> option to abort the program and trigger <code>ftrace</code>
to obtain more information.”</em></p>
<h2 id="summary_6">Summary</h2>
<p><em><span class="dquo">“</span>Tuning Linux and your application to handle real-time events
means making it more deterministic so that the real-time threads
can meet their deadlines reliably.”</em></p>
<p><em><span class="dquo">“</span>To improve determinism, you need to consider both the
application and the kernel.”</em></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            <!--             <div>
            <span class="author_blurb"><a href=""><span class="author_name">Lukas Woodtli</span></a> -
                </span><br />
</div>
 -->
            
            
            <hr/>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="./language_implementation_patterns.html" title="Previous: Language Implementation Patterns">Language Implementation Patterns</a></li>
                <li class="next-article"><a href="./gcc,_binutils_and_other_developer_tools.html" title="Next: GCC, binutils and other developer tools">GCC, binutils and other developer tools</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2018-01-20T21:39:58+01:00">Jan 20, 2018</time>

<h4>Last Updated</h4>
<time datetime="2019-02-12T21:00:00+01:00">Feb 12, 2019</time>

            <h4>Category</h4>
            <a class="category-link" href="./categories.html#programming-ref">Programming</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="./tags#embedded_systems-ref">Embedded Systems
                    <span>8</span>
</a></li>
                <li><a href="./tags#linux-ref">Linux
                    <span>13</span>
</a></li>
                <li><a href="./tags#os-ref">OS
                    <span>13</span>
</a></li>
                <li><a href="./tags#unix-ref">Unix
                    <span>10</span>
</a></li>
            </ul>
<h4>Contact</h4>
    <a href="https://www.linkedin.com/in/lukaswoodtli" title="My LinkedIn Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-linkedin sidebar-social-links"></i></a>
    <a href="https://github.com/LukasWoodtli" title="My github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
    <a href="https://stackoverflow.com/cv/lukaswoodtli" title="My stack-overflow Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-stack-overflow sidebar-social-links"></i></a>
    <a href="https://www.xing.com/profile/Lukas_Woodtli" title="My XING Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-xing sidebar-social-links"></i></a>
    <a href="/pages/contact.html" title="My email Address" class="sidebar-social-links" target="_blank">
    <i class="fa fa-envelope sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="https://github.com/Pelican-Elegant/elegant/" title="Theme Elegant Home Page">Elegant</a></li>
    </ul>
</div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    
    </body>
    <!-- Theme: Elegant built for Pelican
    License : MIT -->
</html>