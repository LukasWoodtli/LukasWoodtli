<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Lukas Woodtli" />
        <meta name="copyright" content="Lukas Woodtli" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="Embedded Systems, OS, Linux, Unix, Programming, " />

<meta property="og:title" content="Mastering Embedded Linux Programming "/>
<meta property="og:url" content="./mastering_embedded_linux_programming.html" />
<meta property="og:description" content="Notes to the book Mastering Embedded Linux Programming My code examples can be found here: GitHub “The versions of the main packages […] are U-Boot 2015.07, Linux 4.1, Yocto Project 1.8 “Fido”, and Buildroot 2015.08” Chapter 1. Starting Out “At the heart of most embedded devices is …" />
<meta property="og:site_name" content="Lukas Woodtli" />
<meta property="og:article:author" content="Lukas Woodtli" />
<meta property="og:article:published_time" content="2018-01-20T21:39:58+01:00" />
<meta property="" content="2018-11-10T21:07:05+01:00" />
<meta name="twitter:title" content="Mastering Embedded Linux Programming ">
<meta name="twitter:description" content="Notes to the book Mastering Embedded Linux Programming My code examples can be found here: GitHub “The versions of the main packages […] are U-Boot 2015.07, Linux 4.1, Yocto Project 1.8 “Fido”, and Buildroot 2015.08” Chapter 1. Starting Out “At the heart of most embedded devices is …">

        <title>Mastering Embedded Linux Programming  · Lukas Woodtli
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/custom.css" media="screen">
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="./"><span class=site-name>Lukas Woodtli</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href=".">Home</a></li>
                            <li><a href="./pages/resume.html">Resume</a></li>
                            <li><a href="./pages/skills.html">Skills</a></li>
                            <li><a href="./pages/books.html">Books</a></li>
                            <li><a href="./pages/courses.html">Courses</a></li>
                            <li><a href="./pages/projects.html">Projects</a></li>
                            <li><a href="./pages/blog.html">Blog</a></li>
                            <li><a href="./pages/contact.html">Contact</a></li>
                            <!-- <li ><a href="./categories.html">Categories</a></li> -->
                            <!-- <li ><a href="./tags.html">Tags</a></li> -->
                            <!-- <li ><a href="./archives.html">Archives</a></li> -->
                            <li><form class="navbar-search" action="./search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="./mastering_embedded_linux_programming.html"> Mastering Embedded Linux&nbsp;Programming  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#chapter-1-starting-out">Chapter 1. Starting Out</a><ul>
<li><a href="#selecting-the-right-operating-system">Selecting the right operating system</a></li>
<li><a href="#project-lifecycle">Project lifecycle</a></li>
<li><a href="#the-four-elements-of-embedded-linux">The four elements of embedded Linux</a></li>
<li><a href="#hardware-for-embedded-linux">Hardware for embedded Linux</a></li>
</ul>
</li>
<li><a href="#chapter-2-learning-about-toolchains">Chapter 2. Learning About Toolchains</a><ul>
<li><a href="#what-is-a-toolchain">What is a toolchain?</a></li>
<li><a href="#types-of-toolchain-native-versus-cross-toolchain">Types of toolchain - native versus cross toolchain</a></li>
<li><a href="#cpu-architectures"><span class="caps">CPU</span> architectures</a><ul>
<li><a href="#arm-oabi-eabi-and-eabihf"><span class="caps">ARM</span> <span class="caps">OABI</span>, <span class="caps">EABI</span> and <span class="caps">EABIHF</span></a></li>
<li><a href="#gnu-prefix-tuple"><span class="caps">GNU</span> prefix tuple</a></li>
</ul>
</li>
<li><a href="#choosing-the-c-library">Choosing the C library</a></li>
<li><a href="#finding-a-toolchain">Finding a toolchain</a></li>
<li><a href="#finding-out-about-your-cross-compiler">Finding out about your cross compiler</a></li>
<li><a href="#the-sysroot-library-and-header-files">The sysroot, library, and header files</a></li>
<li><a href="#other-tools-in-the-toolchain">Other tools in the toolchain</a></li>
<li><a href="#looking-at-the-components-of-the-c-library">Looking at the components of the C library</a></li>
<li><a href="#linking-with-libraries-static-and-dynamic-linking">Linking with libraries: static and dynamic linking</a><ul>
<li><a href="#static-libraries">Static libraries</a></li>
<li><a href="#shared-libraries">Shared libraries</a></li>
<li><a href="#understanding-shared-library-version-numbers">Understanding shared library version numbers</a></li>
</ul>
</li>
<li><a href="#the-art-of-cross-compiling">The art of cross compiling</a><ul>
<li><a href="#simple-makefiles">Simple makefiles</a></li>
<li><a href="#autotools">Autotools</a></li>
</ul>
</li>
<li><a href="#package-configuration">Package configuration</a></li>
<li><a href="#problems-with-cross-compiling">Problems with cross compiling</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
</li>
<li><a href="#chapter-3-all-about-bootloaders">Chapter 3. All About Bootloaders</a><ul>
<li><a href="#what-does-a-bootloader-do">What does a bootloader do?</a></li>
<li><a href="#the-boot-sequence">The boot sequence</a><ul>
<li><a href="#phase-1-rom-code">Phase 1: <span class="caps">ROM</span> code</a></li>
<li><a href="#phase-2-spl">Phase 2: <span class="caps">SPL</span></a></li>
<li><a href="#phase-3-tpl">Phase 3: <span class="caps">TPL</span></a></li>
</ul>
</li>
<li><a href="#booting-with-uefi-firmware">Booting with <span class="caps">UEFI</span> firmware</a><ul>
<li><a href="#phase-1">Phase 1:</a></li>
<li><a href="#phase-2">Phase 2:</a></li>
<li><a href="#phase-3">Phase 3:</a></li>
</ul>
</li>
<li><a href="#moving-from-bootloader-to-kernel">Moving from bootloader to kernel</a></li>
<li><a href="#introducing-device-trees">Introducing device trees</a><ul>
<li><a href="#device-tree-basics">Device tree basics</a></li>
<li><a href="#phandles-and-interrupts">Phandles and interrupts</a></li>
<li><a href="#compiling-a-device-tree">Compiling a device tree</a></li>
</ul>
</li>
<li><a href="#u-boot">U-Boot</a><ul>
<li><a href="#building-u-boot">Building U-Boot</a></li>
<li><a href="#installing-u-boot">Installing U-Boot</a></li>
<li><a href="#boot-image-format">Boot image format</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-4-configuring-and-building-the-kernel">Chapter 4. Configuring and Building the Kernel</a><ul>
<li><a href="#what-does-the-kernel-do">What does the kernel do?</a></li>
<li><a href="#stable-and-long-term-support-releases">Stable and long term support releases</a></li>
<li><a href="#vendor-support">Vendor support</a></li>
<li><a href="#licensing">Licensing</a></li>
<li><a href="#getting-the-source">Getting the source</a></li>
<li><a href="#understanding-kernel-configuration-kconfig">Understanding kernel configuration - Kconfig</a></li>
<li><a href="#using-localversion-to-identify-your-kernel">Using <span class="caps">LOCALVERSION</span> to identify your kernel</a></li>
<li><a href="#kernel-modules">Kernel modules</a></li>
<li><a href="#finding-out-which-kernel-target-to-build">Finding out which kernel target to build</a></li>
<li><a href="#build-artifacts">Build artifacts</a></li>
<li><a href="#compiling-device-trees">Compiling device trees</a></li>
<li><a href="#compiling-modules">Compiling modules</a></li>
<li><a href="#cleaning-kernel-sources">Cleaning kernel sources</a></li>
</ul>
</li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
            <p>Notes to the book <a href="https://www.packtpub.com/networking-and-servers/mastering-embedded-linux-programming">Mastering Embedded Linux Programming</a></p>
<p>My code examples can be found here: <a href="https://github.com/LukasWoodtli/MasteringEmbeddedLinuxProgramming">GitHub</a></p>
<p><em><span class="dquo">“</span>The versions of the main packages […] are U-Boot 2015.07, Linux 4.1, Yocto Project 1.8 “Fido”, and Buildroot 2015.08”</em></p>

<h1 id="chapter-1-starting-out">Chapter 1. Starting Out</h1>
<p><em><span class="dquo">“</span>At the heart of most embedded devices is a highly integrated chip that contains one or more processor cores and interfaces with main memory, mass storage, and peripherals of many types. This is referred to as a System on Chip, or SoC”</em></p>
<h2 id="selecting-the-right-operating-system">Selecting the right operating system</h2>
<p><em><span class="dquo">“</span>Some things to consider</em></p>
<ul>
<li><em>Is your hardware up to the job? Compared to a traditional <span class="caps">RTOS</span> […], Linux requires a lot more resources. It needs at least a 32-bit processor, and lots more memory.</em></li>
<li><em>Do you have the right skill set? […] detailed knowledge of Linux and how it relates to your hardware.</em></li>
<li><em>Is your system real-time? Linux can handle many real-time activities so long as you pay attention to certain details”</em></li>
</ul>
<h2 id="project-lifecycle">Project lifecycle</h2>
<p><em><span class="dquo">“</span>Four sections that reflect the phases of a project. The phases are not necessarily sequential.”</em></p>
<ul>
<li><em><span class="dquo">“</span>set up the development environment and create a working platform for the later phases. “board bring-up” phase.”</em></li>
<li><em><span class="dquo">“</span>System architecture and design choices […] storage of programs and data, how to divide work between kernel device drivers and applications, and how to initialize the system.”</em></li>
<li><em><span class="dquo">“</span>Writing embedded applications […] Linux process and threads model and how to manage memory in a resource-constrained device.”</em></li>
<li><em><span class="dquo">“</span>Debugging and optimizing performance […] trace, profile, and debug your code in both the applications and the kernel.”</em></li>
</ul>
<p><em><span class="dquo">“</span>Debugging and optimizing performance (chapters 12 and 13) describe how to trace, profile, and debug your code in both the applications and the kernel.”</em></p>
<h2 id="the-four-elements-of-embedded-linux">The four elements of embedded Linux</h2>
<ul>
<li><em><span class="dquo">“</span>Toolchain: This consists of the compiler and other tools needed to create code for your target device. Everything else depends on the toolchain.”</em></li>
<li><em><span class="dquo">“</span>Bootloader: This is necessary to initialize the board and to load and boot the Linux kernel.”</em></li>
<li><em><span class="dquo">“</span>Kernel: This is the heart of the system, managing system resources and interfacing with hardware.”</em></li>
<li><em><span class="dquo">“</span>Root filesystem: This contains the libraries and programs”</em></li>
</ul>
<h2 id="hardware-for-embedded-linux">Hardware for embedded Linux</h2>
<p><em><span class="dquo">“</span>[In] source code for Linux 4.1, there are 30 architectures, each represented by a sub-directory in the <code>arch/</code> directory. They are all 32- or 64-bit architectures, most with a <strong>memory management unit (<span class="caps">MMU</span>)</strong>, but some without.”</em></p>
<p><em><span class="dquo">“</span>There is another group that doesn’t have an <span class="caps">MMU</span> that runs a subset of Linux known as micro controller Linux or uClinux.”</em></p>
<p><em><span class="dquo">“</span>[Linux needs] a reasonable amount of <span class="caps">RAM</span>. 16 MiB is a good minimum”</em></p>
<p><em><span class="dquo">“</span>[We need] non-volatile storage, usually flash memory. 8 MiB is enough for a simple device”</em></p>
<p><em><span class="dquo">“</span>Linux has extensive support for flash storage devices, including raw <span class="caps">NOR</span> and <span class="caps">NAND</span> flash chips and managed flash in the form of <span class="caps">SD</span> cards, eMMC chips, <span class="caps">USB</span> flash memory”</em></p>
<p><em><span class="dquo">“</span>A debug port is very useful, most commonly an <span class="caps">RS</span>-232 serial port. It does not have to be fitted on production boards, but makes board bring-up, debugging, and development much easier.”</em></p>
<p><em><span class="dquo">“</span>[We] need some means of loading software when starting from scratch. [For example <span class="caps">JTAG</span>] but modern SoCs have the ability to load boot code directly from removable media, especially <span class="caps">SD</span> and micro <span class="caps">SD</span> cards, or serial interfaces such as <span class="caps">RS</span>-232 or <span class="caps">USB</span>.”</em></p>
<h1 id="chapter-2-learning-about-toolchains">Chapter 2. Learning About Toolchains</h1>
<h2 id="what-is-a-toolchain">What is a toolchain?</h2>
<p><em><span class="dquo">“</span>A standard <span class="caps">GNU</span> toolchain consists of three main components:”</em></p>
<ul>
<li><a href="http://www.gnu.org/software/binutils/">Binutils</a>: Assembler, linker, (ld) and other tools</li>
<li><a href="http://gcc.gnu.org/"><span class="caps">GCC</span></a>: Compilers for C, C++, Objective-C, Objective-C++, Java, Fortran, Ada, and Go. They all use a common back-end which produces assembler code for the <span class="caps">GNU</span> assembler (<span class="caps">GAS</span>)</li>
<li><strong>C library</strong>: Standardized <span class="caps">API</span> based on <span class="caps">POSIX</span> (interface to the operating system kernel from applications)</li>
</ul>
<p><em><span class="dquo">“</span>As well as these, you will need a copy of the Linux kernel headers,”</em></p>
<p><em><span class="dquo">“</span>of the header files in the include directory of your kernel source code. Those headers are intended for use in the kernel only and contain definitions that will cause conflicts if used in their raw state to compile regular Linux applications. Instead, you will need to generate a set of sanitized kernel headers”</em></p>
<h2 id="types-of-toolchain-native-versus-cross-toolchain">Types of toolchain - native versus cross toolchain</h2>
<p><em><span class="dquo">“</span>here are two types of toolchain:</em></p>
<ul>
<li><em>Native: This toolchain runs on the same type of system […] This is the usual case for desktops and servers, and it is becoming popular on certain classes of embedded devices. […]</em></li>
<li><em>Cross: This toolchain runs on a different type of system than the target, allowing the development to be done on a fast desktop <span class="caps">PC</span> and then loaded onto the embedded target for testing.”</em></li>
</ul>
<p><em><span class="dquo">“</span>Almost all embedded Linux development is done using a cross development toolchain, partly because most embedded devices are not well suited to program development since they lack computing power, memory, and storage, but also because it keeps the host and target environments separate.”</em></p>
<p><em><span class="dquo">“</span>there is a counter argument in favor of native development. Cross development creates the burden of cross-compiling all the libraries and tools that you need for your target.”</em></p>
<h2 id="cpu-architectures"><span class="caps">CPU</span> architectures</h2>
<p><em><span class="dquo">“</span>toolchain has to be built according to the capabilities of the target <span class="caps">CPU</span>:</em></p>
<ul>
<li><em><span class="caps">CPU</span> architecture: arm, mips, x86_64, and so on</em></li>
<li><em>Big- or little-endian operation: Some CPUs can operate in both modes, but the machine code is different for each</em></li>
<li><em>Floating point support: Not all versions of embedded processors implement a hardware floating point unit, in which case, the toolchain can be configured to call a software floating point library instead</em></li>
<li><em>Application Binary Interface (<span class="caps">ABI</span>): The calling convention used for passing parameters between function calls”</em></li>
</ul>
<h3 id="arm-oabi-eabi-and-eabihf"><span class="caps">ARM</span> <span class="caps">OABI</span>, <span class="caps">EABI</span> and <span class="caps">EABIHF</span></h3>
<p><em><span class="dquo">“</span>With many architectures, the <span class="caps">ABI</span> is constant across the family of processors. One notable exception is <span class="caps">ARM</span>. The <span class="caps">ARM</span> architecture transitioned to the </em>Extended Application Binary Interface<em> (<strong><span class="caps">EABI</span></strong>) in the late 2000’s, resulting in the previous <span class="caps">ABI</span> being named the </em>Old Application Binary Interface<em> (<strong><span class="caps">OABI</span></strong>). While the <span class="caps">OABI</span> is now obsolete, you continue to see references to <span class="caps">EABI</span>. Since then, the </em><span class="caps">EABI</span> has split into two<em>, based on the way that floating point parameters are passed. The </em>original <span class="caps">EABI</span> uses general purpose (integer)<em> registers</em> while the <em>newer <strong><span class="caps">EABIHF</span></strong> uses floating point registers. The <span class="caps">EABIHF</span> is significantly faster at floating point operations since it removes the need for copying between integer and floating point registers, but it is not compatible with CPUs that do not have a floating point unit. The choice, then, is between two incompatible ABIs: </em>you cannot mix and match the two<em> and so you have to decide at this stage.”</em></p>
<h3 id="gnu-prefix-tuple"><span class="caps">GNU</span> prefix tuple</h3>
<p><em><span class="dquo">“</span><span class="caps">GNU</span> uses a prefix to the tools to identify the various combinations that can be generated, consisting of a tuple of three or four components separated by dashes:</em></p>
<ul>
<li><em><span class="caps">CPU</span>: The <span class="caps">CPU</span> architecture, such as arm, mips, or x86_64. If the <span class="caps">CPU</span> has both endian modes, they may be differentiated by adding <strong>el for little-endian</strong>, or <strong>eb for big-endian</strong>. Good examples are little-endian <span class="caps">MIPS</span>, mipsel and big-endian <span class="caps">ARM</span>, armeb.</em></li>
<li><em>Vendor: This identifies the provider of the toolchain. Examples include buildroot, poky, or just unknown. Sometimes it is left out altogether.</em></li>
<li><em>Kernel: For our purposes, it is always ‘linux’.</em></li>
<li><em>Operating system: A name for the user space component, which might be <code>gnu</code> or <code>uclibcgnu</code>. The <span class="caps">ABI</span> may be appended here as well so, for <span class="caps">ARM</span> toolchains, you may see <code>gnueabi</code>, <code>gnueabihf</code>, <code>uclibcgnueabi</code>, or <code>uclibcgnueabihf</code>.”</em></li>
</ul>
<p><em><span class="dquo">“</span>You can find the tuple used when building the toolchain by using the <code>-dumpmachine</code> option of <code>gcc</code><span class="dquo">“</span></em></p>
<h2 id="choosing-the-c-library">Choosing the C library</h2>
<p><em><span class="dquo">“</span>The programming interface to the Unix operating system is defined in the C language, which is now defined by the <strong><span class="caps">POSIX</span></strong> standards. The C library is the implementation of that interface”</em></p>
<p><em><span class="dquo">“</span>There are several C libraries:</em></p>
<ul>
<li><em>glibc: is the standard <span class="caps">GNU</span> C library. It is big and, until recently, not very configurable, but it is the most complete implementation</em></li>
<li><em>eglibc: This is the embedded <span class="caps">GLIBC</span>. […] the code base from eglibc has been merged back into glibc. eglibc is no longer maintained.</em></li>
<li><em>uClibc: was first developed to work with uClinux. There is a configuration utility which allows you to fine-tune its features to your needs. […] smaller than glibc</em></li>
<li><em>musl libc: is a new C library designed for embedded systems.</em>”</li>
</ul>
<p><em><span class="dquo">“</span>So, which to choose?</em></p>
<ul>
<li><em>uClibc only if you are using uClinux or if you have very limited amounts of storage or <span class="caps">RAM</span></em></li>
<li><em>Otherwise, I prefer to use an up-to-date glibc, or eglibc”</em></li>
</ul>
<h2 id="finding-a-toolchain">Finding a toolchain</h2>
<p><em><span class="dquo">“</span>three choices for your cross development toolchain:</em></p>
<ul>
<li><em>a ready built toolchain that matches your needs</em> (i.e. <a href="https://www.linaro.org/">Linaro</a> for <span class="caps">ARM</span>)</li>
<li><em>generated by an embedded build tool</em> (i.e. Yocto)</li>
<li><em>create one yourself”</em> (crosstool-ng)</li>
</ul>
<h2 id="finding-out-about-your-cross-compiler">Finding out about your cross compiler</h2>
<p><em><span class="dquo">“</span>To find the version [of gcc], you use <code>--version</code>:”</em></p>
<p><code>arm-cortex_a8-linux-gnueabi-gcc --version</code></p>
<p><em><span class="dquo">“</span>To find how [gcc] was configured, use <code>-v</code>:”</em></p>
<p><code>arm-cortex_a8-linux-gnueabi-gcc -v</code></p>
<p>The output contains (among other information):</p>
<ul>
<li><code>--with-sysroot=/home/luki/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot</code>: the default sysroot directory</li>
<li><code>--enable-languages=c,c++</code>: C and C++ languages are enabled</li>
<li><code>--with-arch=armv7-a</code>: code is generated using the <span class="caps">ARM</span> v7a instruction set</li>
<li><code>--with-cpu=cortex-a8</code> and <code>--with-tune=cortex-a8</code>: code is tweaked for Cortex A8</li>
<li><code>--with-float=hard</code>: Generate opcodes for the floating point unit and uses the <span class="caps">VFP</span> registers for parameters</li>
<li><code>--enable-threads=posix</code>: Enable <span class="caps">POSIX</span> threads</li>
</ul>
<p><em><span class="dquo">“</span>you can override the configured setting, <code>–-with-cpu</code>, by adding <code>-mcpu</code> to the command line`:”</em></p>
<p><code>arm-cortex_a8-linux-gnueabihf-gcc -mcpu=cortex-a5 helloworld.c -o helloworld</code></p>
<p><em><span class="dquo">“</span>You can print out the the range of architecture-specific options available using:”</em></p>
<p>`arm-cortex_a8-linux-gnueabihf-gcc —target-help“</p>
<h2 id="the-sysroot-library-and-header-files">The sysroot, library, and header files</h2>
<p><em><span class="dquo">“</span>The toolchain sysroot is a directory which contains subdirectories for libraries, header files, and other configuration files.”</em></p>
<p><em><span class="dquo">“</span>It can be set when the toolchain is configured through <code>--with-sysroot=</code> or it can be set on the command line, using <code>--sysroot=</code>. You can see the location of the default sysroot by using <code>-print-sysroot</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span>You will find the following in the sysroot:</em>
- <em><code>lib</code>: Contains the shared objects for the C library and the dynamic linker/loader, <code>ld-linux</code></em>
- <em><code>usr/lib</code>: the static library archives for the C library and any other libraries that may be installed subsequently</em>
- <em><code>usr/include</code>: Contains the headers for all the libraries</em>
- <em><code>usr/bin</code>: Contains the utility programs that run on the target, such as the <code>ldd</code> command</em>
- <em><code>/usr/share</code>: Used for localization and internationalization</em>
- <em><code>sbin</code>: Provides the ldconfig utility, used to optimize library loading paths</em>”</p>
<p><em><span class="dquo">“</span>some of these are needed on the development host to compile programs, and others - for example the shared libraries and <code>ld-linux</code> - are needed on the target at runtime.”</em></p>
<h2 id="other-tools-in-the-toolchain">Other tools in the toolchain</h2>
<ul>
<li><code>addr2line</code>: Converts program addresses into filenames and numbers. Useful for decoding addresses from a crash report</li>
<li><code>ar</code>: used to create static libraries</li>
<li><code>as</code>: <span class="caps">GNU</span> assembler</li>
<li><code>c++filt</code>: demangle C++ and Java symbols</li>
<li><code>cpp</code>: Standalone C preprocessor</li>
<li><code>elfedit</code>: update the <span class="caps">ELF</span> header</li>
<li><code>gcov</code>: coverage tool</li>
<li><code>gdb</code>: <span class="caps">GNU</span> debugger</li>
<li><code>gprof</code>: profiling tool</li>
<li><code>ld</code>: the <span class="caps">GNU</span> linker</li>
<li><code>nm</code>: list symbols from object files</li>
<li><code>objcopy</code>: copy and translate object files</li>
<li><code>objdump</code>: display information from object files</li>
<li><code>ranlib</code>: creates or modifies an index in a static library, making the linking stage faster</li>
<li><code>readelf</code>: display information in <span class="caps">ELF</span> object files</li>
<li><code>size</code>: list section sizes</li>
<li><code>strings</code>: display printable characters in files</li>
<li><code>strip</code>: strip the debug symbols of object file</li>
</ul>
<h2 id="looking-at-the-components-of-the-c-library">Looking at the components of the C library</h2>
<p><em><span class="dquo">“</span>The C library […] is composed of four main parts”</em>:</p>
<ul>
<li><code>libc</code>: the main C library</li>
<li><code>libm</code>: matn functions</li>
<li><code>libpthread</code>: <span class="caps">POSIX</span> threads</li>
<li><code>librt</code>: real-time extensions to <span class="caps">POSIX</span></li>
</ul>
<p><em><span class="dquo">“</span><code>libc</code>, is always linked in but the others have to be explicitly linked”</em></p>
<p><em><span class="dquo">“</span>You can verify which libraries have been linked […] by using the readelf command:”</em></p>
<p>`arm-cortex_a8-linux-gnueabihf-readelf -a myprog | grep “Shared library”“</p>
<p><em><span class="dquo">“</span>Shared libraries need a run-time linker […]:”</em></p>
<p><code>arm-cortex_a8-linux-gnu eabihf-readelf -a myprog | grep "program interpreter"</code></p>
<h2 id="linking-with-libraries-static-and-dynamic-linking">Linking with libraries: static and dynamic linking</h2>
<p><em><span class="dquo">“</span>Any application […] will be linked with the C library, libc. […] Other libraries […] have to be explicitly named through the <code>-l</code> option.”</em></p>
<h3 id="static-libraries">Static libraries</h3>
<p>*”Static linking is useful in a few circumstances.</p>
<ul>
<li>building a small system which consists of only BusyBox</li>
<li>if you need to run a program before the filesystem that holds the runtime libraries is available”*</li>
</ul>
<p><em><span class="dquo">“</span>[Tell] <code>gcc</code> to link all libraries statically by adding <code>-static</code>:”</em></p>
<p><code>arm-cortex_a8-linux-gnueabihf-gcc -static helloworld.c -o helloworld-static</code></p>
<p><em><span class="dquo">“</span>the size of the binary increases dramatically”</em></p>
<h3 id="shared-libraries">Shared libraries</h3>
<p><em><span class="dquo">“</span>The object code for a shared library must be position-independent so that the runtime linker is free to locate it in memory at the next free address. To do this, add the <code>-fPIC</code> parameter to gcc, and then link it using the <code>-shared</code> option”</em></p>
<h3 id="understanding-shared-library-version-numbers">Understanding shared library version numbers</h3>
<p><em><span class="dquo">“</span>Each library has a release version and an interface number. The release version is simply a string that is appended to the library name”</em></p>
<p><em><span class="dquo">“</span>The <code>soname</code> encodes the interface number when the library was built and is used by the runtime linker when it loads the library. It is formatted as <code>&lt;library name&gt;.so.&lt;interface number&gt;</code><span class="dquo">“</span></em></p>
<p>Find the <code>soname</code>:</p>
<p><code>readelf -a &lt;path_to_so&gt; | grep SONAME</code></p>
<p>Libraries and symbolic links in a library directory (example <code>libjpeg</code>):</p>
<table class="table table-striped">
<thead>
<tr>
<th>File</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>libjpeg.a</code></td>
<td>library archive used for static linking</td>
</tr>
<tr>
<td><code>libjpeg.so -&gt; libjpeg.so.8.0.2</code></td>
<td>symbolic link, used for dynamic linking</td>
</tr>
<tr>
<td><code>libjpeg.so.8 -&gt; libjpeg.so.8.0.2</code></td>
<td>symbolic link used when loading the library at runtime</td>
</tr>
<tr>
<td><code>libjpeg.so.8.0.2</code></td>
<td>This is the actual shared library, used at both compile time and runtime</td>
</tr>
</tbody>
</table>
<p><em><span class="dquo">“</span>The first two are only needed on the host computer for building, the last two are needed on the target at runtime.”</em></p>
<p>See also: <a href="http://man7.org/linux/man-pages/man8/ldconfig.8.html"><code>ldconfig</code></a></p>
<h2 id="the-art-of-cross-compiling">The art of cross compiling</h2>
<h3 id="simple-makefiles">Simple makefiles</h3>
<p><em><span class="dquo">“</span>[For] the Linux kernel, the U-Boot bootloader, and Busybox [and others] you only need to put the toolchain prefix in the make variable <code>CROSS_COMPILE</code>, for example <code>arm-cortex_a8-linux-gnueabi-</code>. Note the trailing dash <code>-</code>.”</em></p>
<p><em><span class="dquo">“</span>In the case of U-Boot and Linux, you also have to set the <code>make</code> variable <code>ARCH</code> to one of the machine architectures they support”</em></p>
<h3 id="autotools">Autotools</h3>
<p><em><span class="dquo">“</span>Autotools, refers to a group of tools that are used as the build system in many open source projects.”</em></p>
<ul>
<li><a href="http://www.gnu.org/software/autoconf/autoconf.html"><span class="caps">GNU</span> Autoconf</a> </li>
<li><a href="http://www.gnu.org/savannah-checkouts/gnu/automake"><span class="caps">GNU</span> Automake</a></li>
<li><a href="http://www.gnu.org/software/libtool/libtool.html"><span class="caps">GNU</span> Libtool</a></li>
<li><a href="https://www.gnu.org/software/gnulib">Gnulib</a></li>
</ul>
<p><em><span class="dquo">“</span>The role of Autotools is to smooth over the differences between the many different types of system that the package may be compiled for, accounting for different versions of compilers, different versions of libraries, different locations of header files, and dependencies with other packages.”</em></p>
<p><em><span class="dquo">“</span>Packages that use Autotools come with a script named <code>configure</code> that checks dependencies and generates makefiles according to what it finds.”</em></p>
<p><em><span class="dquo">“</span>Find the options […] by running <code>./configure --help</code>.”</em></p>
<p><em><span class="dquo">“</span>Autotools is able to handle cross development as well. You can influence the behavior of the configure script by setting these shell variables:</em></p>
<ul>
<li><em><code>CC</code>: The C compiler command</em></li>
<li><em><code>CFLAGS</code>: Additional C compiler flags</em></li>
<li><em><code>LDFLAGS</code>: Additional linker flags, for example if you have libraries in a non-standard directory <code>&lt;lib dir&gt;</code> you would add it to the library search</em> path by adding <code>-L&lt;lib dir&gt;</code>*</li>
<li><em><code>LIBS</code>: Contains a list of additional libraries to pass to the linker, for instance <code>-lm</code> for the math library</em></li>
<li><em><code>CPPFLAGS</code>: Contains C/C++ preprocessor flags, for example you would add <code>-I&lt;include dir&gt;</code> to search for headers in a non-standard directory <code>&lt;include dir&gt;</code></em></li>
<li><em><code>CPP</code>: The C preprocessor to use</em>”</li>
</ul>
<p><em><span class="dquo">“</span>Autotools understands three different types of machine that may be involved when compiling a package:</em></p>
<ul>
<li><em><code>Build</code>: This is the computer that is to build the package, which defaults to the current machine.</em></li>
<li><em><code>Host</code>: This is the computer the program will run on: for a native compile this is left blank and it defaults to be the same computer as build. For a <strong>cross compile</strong> you set it to be the <strong>tuple of your toolchain</strong>.</em></li>
<li><em><code>Target</code>: This is the computer the program will generate code for: you would set this when building a cross compiler, for example.</em>”</li>
</ul>
<h2 id="package-configuration">Package configuration</h2>
<p><em><span class="dquo">“</span>Tracking package dependencies is quite complex. The package configuration utility, <a href="http://www.freedesktop.org/wiki/Software/pkg-config"><code>pkg-config</code></a> helps track which packages are installed and which compile flags each needs by keeping a database of Autotools packages in <code>[sysroot]/usr/lib/pkgconfig</code>.”</em></p>
<p><em><span class="dquo">“</span>You can use the utility pkg-config to extract information in a form that you can feed straight to gcc. In the case of a library […], you want to know the library name (<code>--libs</code>) and any special C flags (<code>--cflags</code>).”</em></p>
<p><em><span class="dquo">“</span>You need to point it at the sysroot of the target toolchain by setting the shell variable <code>PKG_CONFIG_LIBDIR</code><span class="dquo">“</span></em></p>
<p><code>PKG_CONFIG_LIBDIR=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)/usr/lib/pkgconfig pkg-config sqlite3 --libs --cflags</code></p>
<h2 id="problems-with-cross-compiling">Problems with cross compiling</h2>
<p><em><span class="dquo">“</span>Typical pain points include:</em></p>
<ul>
<li><em>Home-grown build systems, zlib, for example, has a configure script but it does not behave like the Autotools configure</em></li>
<li><em>Configure scripts that read <code>pkg-config</code> information, headers, and other files from the host, disregarding the <code>--host</code> override</em></li>
<li><em>Scripts that insist on trying to run cross compiled code</em>”</li>
</ul>
<h2 id="summary">Summary</h2>
<p><em><span class="dquo">“</span>Beware of toolchains or distributions that are offered to you for free as part of a hardware package: they are often poorly configured and not maintained. In any case, you should make the choice according to your situation, and then be consistent in its use throughout the project.”</em></p>
<h1 id="chapter-3-all-about-bootloaders">Chapter 3. All About Bootloaders</h1>
<p><em><span class="dquo">“</span>The bootloader […] starts the system up and loads the operating system kernel. […] it passes control from itself to the kernel using […] a device tree (flattened device tree or <span class="caps">FDT</span>)”</em></p>
<h2 id="what-does-a-bootloader-do">What does a bootloader do?</h2>
<p><em><span class="dquo">“</span>the bootloader has two main jobs:</em></p>
<ul>
<li><em>basic system initialization and</em></li>
<li><em>the loading of the kernel”</em></li>
</ul>
<p><em><span class="dquo">“</span>Typically, the only resources operational at the beginning [after booting] are a single <span class="caps">CPU</span> core and some on-chip static memory.”</em></p>
<h2 id="the-boot-sequence">The boot sequence</h2>
<h3 id="phase-1-rom-code">Phase 1: <span class="caps">ROM</span> code</h3>
<p><em><span class="dquo">“</span>the code that runs immediately after a reset or power-on has to be stored on-chip in the SoC; this is known as <span class="caps">ROM</span> code.
It is programmed into the chip when it is manufactured, hence <span class="caps">ROM</span> code is proprietary and cannot be replaced by an open source equivalent.”</em></p>
<p><em><span class="dquo">“</span>the only <span class="caps">RAM</span> that the <span class="caps">ROM</span> code has access to is the small amount of static <span class="caps">RAM</span> (<span class="caps">SRAM</span>) found in most SoC designs. The size of the <span class="caps">SRAM</span> varies from as little as 4 KiB up to a few hundred KiB”</em></p>
<p><em><span class="dquo">“</span>In SoCs where the <span class="caps">SRAM</span> is not large enough to load a full bootloader like U-Boot, there has to be an intermediate loader called the secondary program loader, or <span class="caps">SPL</span>”</em></p>
<p><em><span class="dquo">“</span>At the end of this phase, the next stage bootloader is present in on-chip memory and the <span class="caps">ROM</span> code jumps to the beginning of that code.”</em></p>
<h3 id="phase-2-spl">Phase 2: <span class="caps">SPL</span></h3>
<p><em><span class="dquo">“</span><span class="caps">SPL</span> must set up the memory controller and other essential parts of the system preparatory to loading the <strong>third stage program loader (<span class="caps">TPL</span>)</strong> into main memory, the <span class="caps">DRAM</span>”</em></p>
<p><em><span class="dquo">“</span>The <span class="caps">SPL</span> may be open source […] but it is quite common for it to contain proprietary code”</em></p>
<h3 id="phase-3-tpl">Phase 3: <span class="caps">TPL</span></h3>
<p><em><span class="dquo">“</span>At last, we are running a full bootloader like U-Boot or Barebox.”</em></p>
<p><em><span class="dquo">“</span>At the end of the third phase, there is a kernel in memory”</em></p>
<p><em><span class="dquo">“</span>Embedded bootloaders usually disappear from memory once the kernel is running”</em></p>
<h2 id="booting-with-uefi-firmware">Booting with <span class="caps">UEFI</span> firmware</h2>
<p>See also: <a href="http://www.uefi.org">Universal Extensible Firmware Interface (<span class="caps">UEFI</span>)</a></p>
<h3 id="phase-1">Phase 1:</h3>
<p><em><span class="dquo">“</span>The processor loads the <span class="caps">UEFI</span> boot manager firmware from flash memory. In some designs, it is loaded directly from <span class="caps">NOR</span> flash memory, in others there is <span class="caps">ROM</span> code on-chip which loads the boot manager from <span class="caps">SPI</span> flash memory. The boot manager is roughly equivalent to the <span class="caps">SPL</span>, but may allow user interaction through a text-based or graphical interface.”</em></p>
<h3 id="phase-2">Phase 2:</h3>
<p><em><span class="dquo">“</span>The boot manager loads the boot firmware from the <strong><span class="caps">EFI</span> System Partition (<span class="caps">ESP</span>)</strong> or a hard disk or <span class="caps">SSD</span>, or from a network server via <span class="caps">PXE</span> boot.”</em></p>
<p><em><span class="dquo">“</span>[…] the <span class="caps">EXP</span> is identified by a well-known <span class="caps">GUID</span> value of <strong><span class="caps">C12A7328</span>-<span class="caps">F81F</span>-11D2-<span class="caps">BA4B</span>-<span class="caps">00A0C93EC93B</span></strong>.”</em></p>
<p>Partition: <span class="caps">FAT32</span></p>
<p>Third stage bootloader file: <code>&lt;efi_system_partition&gt;/boot/boot&lt;machine_type_short_name&gt;.efi</code></p>
<h3 id="phase-3">Phase 3:</h3>
<p><em><span class="dquo">“</span>The <span class="caps">TPL</span> in this case has to be a bootloader that is capable of loading a Linux kernel and an optional <span class="caps">RAM</span> disk into memory. Common choices are:</em></p>
<ul>
<li><em><span class="caps">GRUB</span> 2</em></li>
<li><em>gummiboot”</em></li>
</ul>
<h2 id="moving-from-bootloader-to-kernel">Moving from bootloader to kernel</h2>
<p><em><span class="dquo">“</span>When the bootloader passes control to the kernel it has to pass some basic information to the kernel:</em></p>
<ul>
<li><em>a number unique to the type of the SoC</em></li>
<li><em>Basic details of the hardware detected so far, […] size and location of the physical <span class="caps">RAM</span>, and the <span class="caps">CPU</span> clock speed</em></li>
<li><em>The kernel command line (plain <span class="caps">ASCII</span> string)</em></li>
<li><em>Optionally, the location and size of a device tree binary</em></li>
<li><em>Optionally, the location and size of an initial <span class="caps">RAM</span> disk”</em></li>
</ul>
<p><em><span class="dquo">“</span>It is common to provide the root filesystem as a <span class="caps">RAM</span> disk, in which case it is the responsibility of the bootloader to load the <span class="caps">RAM</span> disk image into memory.”</em></p>
<p><em><span class="dquo">“</span>There is a good description of the format of the kernel source in <code>Documentation/arm/Booting</code><span class="dquo">“</span></em></p>
<h2 id="introducing-device-trees">Introducing device trees</h2>
<p>See also: <a href="https://www.devicetree.org/">www.devicetree.org</a></p>
<p><em><span class="dquo">“</span>A device tree is a flexible way to define the hardware components of a computer system. Usually, the device tree is loaded by the bootloader and passed to the kernel, although it is possible to bundle the device tree with the kernel image itself […] for bootloaders that are not capable of handling them separately.”</em></p>
<p><em><span class="dquo">“</span>The format is derived from a Sun Microsystems bootloader known as OpenBoot”</em></p>
<p><em><span class="dquo">“</span>[It] has been adapted on a large scale by the many <span class="caps">ARM</span> Linux implementations”</em></p>
<h3 id="device-tree-basics">Device tree basics</h3>
<p>There are a large number of device tree source files:</p>
<ul>
<li>Linux kernel: <code>arch/$ARCH/boot/dts</code></li>
<li>U-boot: <code>arch/$ARCH/dts</code></li>
</ul>
<p><em><span class="dquo">“</span>The device tree represents a computer system as a collection of components joined together in a hierarchy […] begins with a root node, represented by a […] <code>/</code>, which contains subsequent nodes representing the hardware of the system. Each node has a name and contains a number of properties in the form <code>name = "value"</code><span class="dquo">“</span></em></p>
<h3 id="phandles-and-interrupts">Phandles and interrupts</h3>
<p>Phandels are used to connect devices in a way that doesn’t correspond to the main tree structure.</p>
<p><em><span class="dquo">“</span>As well as the obvious data connection between a component and other parts of the system, it might also be connected to an interrupt controller, to a clock source and to a voltage regulator. To express these connections, we have phandles.”</em></p>
<p><em><span class="dquo">“</span>[The] bindings can be found in the Linux kernel source, in directory <code>Documentation/devicetree/bindings/</code>.”</em></p>
<h3 id="compiling-a-device-tree">Compiling a device tree</h3>
<p><em><span class="dquo">“</span>The bootloader and kernel require a binary representation of the device tree, so it has to be compiled using the device tree compiler, <code>dtc</code>. The result is a file ending with <code>.dtb</code>, which is referred to as a device tree binary or a device tree blob.”</em></p>
<p><em><span class="dquo">“</span><code>dtc</code> does not give helpful error messages and it makes no checks other than on the basic syntax of the language”</em></p>
<h2 id="u-boot">U-Boot</h2>
<h3 id="building-u-boot">Building U-Boot</h3>
<p><em><span class="dquo">“</span>[…] the way U-Boot is configured has undergone a lot of changes since the 2014.10 release. Double-check that the instructions you are following are appropriate.”</em></p>
<div class="highlight"><pre><span></span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf- am335x_boneblack_defconfig
make <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf-
</pre></div>
<p><em><span class="dquo">“</span>The results of the compilation are:</em></p>
<ul>
<li><em><code>u-boot</code>: This is U-Boot in <span class="caps">ELF</span> object format, suitable for use with a debugger</em></li>
<li><em><code>u-boot.map</code>: This is the symbol table</em></li>
<li><em><code>u-boot.bin</code>: This is U-Boot in raw binary format, suitable for running on your device</em></li>
<li><em><code>u-boot.img</code>: This is <code>u-boot.bin</code> with a U-Boot header added, suitable for uploading to a running copy of U-Boot</em></li>
<li><em><code>u-boot.srec</code>: This is U-Boot in Motorola <code>srec</code> format, suitable for transferring over a serial connection”</em></li>
</ul>
<p><em><span class="dquo">“</span>a Secondary Program Loader (<span class="caps">SPL</span>) […] is built at the same time and is named <code>MLO</code><span class="dquo">“</span></em></p>
<h3 id="installing-u-boot">Installing U-Boot</h3>
<p><em><span class="dquo">“</span>[With] <span class="caps">JTAG</span>, it is usually possible to load a copy of U-Boot directly into <span class="caps">RAM</span> and set it running. From that point, you can use U-Boot commands to copy it into flash memory.”</em></p>
<p><em><span class="dquo">“</span>Some SoC designs have a boot <span class="caps">ROM</span> built in which can be used to read boot code from various external sources such as <span class="caps">SD</span> cards, serial interfaces, or USBs”</em></p>
<p>For BeagleBone Black:</p>
<p><em><span class="dquo">“</span>two partitions: the first is 64 MiB, formatted as <span class="caps">FAT32</span> [(bootable)], and will contain the bootloader, and the second is 1 GiB, formatted as ext4”</em></p>
<p>List block devices with: <a href="http://man7.org/linux/man-pages/man8/lsblk.8.html">lsblk</a></p>
<p><em><span class="dquo">“</span>copy U-Boot and the <span class="caps">SPL</span> to [first partition of <span class="caps">SD</span> card]:”</em></p>
<div class="highlight"><pre><span></span>cp MLO u-boot.img /media/<span class="nv">$USER</span>/boot
</pre></div>
<h3 id="boot-image-format">Boot image format</h3>
<p><em><span class="dquo">“</span>Prepare files [(like the Linux kernel)] for U-Boot using the <code>mkimage</code> command.”</em></p>
<p>Example:</p>
<div class="highlight"><pre><span></span>mkimage -A arm -O linux -T kernel -C gzip -a 0x80008000 <span class="se">\</span>
-e 0x80008000 -n <span class="s1">'Linux'</span> -d zImage uImage
</pre></div>
<h1 id="chapter-4-configuring-and-building-the-kernel">Chapter 4. Configuring and Building the Kernel</h1>
<h2 id="what-does-the-kernel-do">What does the kernel do?</h2>
<p><em><span class="dquo">“</span>The system call interface uses an architecture-specific method, such as a trap or a software interrupt, to switch the <span class="caps">CPU</span> from low privilege user mode to high privilege kernel mode, which allows access to all memory addresses and <span class="caps">CPU</span> registers.”</em></p>
<p><em><span class="dquo">“</span>Interrupts can only be handled in a device driver, never by a user space application.”</em></p>
<h2 id="stable-and-long-term-support-releases">Stable and long term support releases</h2>
<p><em><span class="dquo">“</span>[…] stable releases and long term releases. After the release of a mainline kernel (maintained by Linus Torvalds) it is moved to the stable tree (maintained by Greg Kroah-Hartman).”</em></p>
<p><em><span class="dquo">“</span>some kernels are labeled <strong>long term</strong> and maintained for two or more years. There is at least one long term kernel release each year.”</em></p>
<p><a href="www.kernel.org">https://www.kernel.org/</a></p>
<p><a href="kernelnewbies.org">http://kernelnewbies.org/LinuxVersions</a></p>
<h2 id="vendor-support">Vendor support</h2>
<p><em><span class="dquo">“</span>You may find support for your board or SoC from independent open source projects, Linaro or the Yocto Project, for example, or from companies providing third party support for embedded Linux, but in many cases you will be obliged to look to the vendor of your SoC or board for a working kernel.”</em></p>
<h2 id="licensing">Licensing</h2>
<p><em><span class="dquo">“</span>The Linux source code is licensed under <span class="caps">GPL</span> v2”</em></p>
<p><em><span class="dquo">“</span>it is now accepted practice that the <span class="caps">GPL</span> does not <strong>necessarily</strong> apply to kernel modules. This is codified by the kernel <code>MODULE_LICENSE</code> macro, which may take the value <code>Proprietary</code> to indicate that it is not released under the <span class="caps">GPL</span>.”</em></p>
<p>*”[…] an oft-quoted e-mail thread titled “Linux <span class="caps">GPL</span> and binary module exception clause?” which is archived at <a href="http://yarchive.net">http://yarchive.net/comp/linux/gpl_modules.html</a></p>
<h2 id="getting-the-source">Getting the source</h2>
<p><em><span class="dquo">“</span>The main directories of interest are:</em></p>
<ul>
<li><code>arch</code>: <em>architecture-specific files, one subdirectory per architecture.</em></li>
<li><code>Documentation</code>: *kernel documentation. Always look here first *</li>
<li><code>drivers</code>: <em>device drivers, a subdirectory for each type of driver.</em></li>
<li><code>fs</code>: <em>filesystem code.</em></li>
<li><code>include</code>: <em>kernel header files, including those required when building the toolchain.</em></li>
<li><code>init</code>: <em>the kernel start-up code.</em></li>
<li><code>kernel</code>: <em>core functions, including scheduling, locking, timers, power management, and debug/trace code.</em></li>
<li><code>mm</code>: <em>memory management.</em></li>
<li><code>net</code>: <em>network protocols.</em></li>
<li><code>scripts</code>: <em>many useful scripts, including the device tree compiler, <span class="caps">DTC</span>.</em></li>
<li><code>tools</code>: <em>many useful tools.”</em></li>
</ul>
<h2 id="understanding-kernel-configuration-kconfig">Understanding kernel configuration - Kconfig</h2>
<p>*”The value you put into <code>ARCH</code> is one of the subdirectories you find in directory arch, with the oddity that <code>ARCH=i386</code> and <code>ARCH=x86_64</code> both source <code>arch/x86/Kconfig</code>.</p>
<p>*”[search function] in <code>menuconfig</code> by pressing the forward slash key, <code>/</code><span class="dquo">“</span>.</p>
<p><em><span class="dquo">“</span>There are a set of known working configuration files in <code>arch/$ARCH/configs</code>, each containing suitable configuration values for a single SoC or a group of SoCs.”</em></p>
<p><em><span class="dquo">“</span>[There is a] target named <code>oldconfig</code>. This takes an existing <code>.config</code> file and asks you to supply configuration values for any options that don’t have them. You would use it when moving a configuration to a newer kernel version; copy <code>.config</code> from the old kernel to the new source directory and run the <code>make ARCH=arm oldconfig</code> command to bring it up to date. It can also be used to validate a <code>.config</code> file that you have edited manually”</em></p>
<h2 id="using-localversion-to-identify-your-kernel">Using <span class="caps">LOCALVERSION</span> to identify your kernel</h2>
<div class="highlight"><pre><span></span>make <span class="nv">ARCH</span><span class="o">=</span>arm kernelversion
</pre></div>
<p><em><span class="dquo">“</span>If you change the configuration from the default, it is advisable to append your own version information, which you can configure by setting <code>CONFIG_LOCALVERSION</code><span class="dquo">“</span></em></p>
<h2 id="kernel-modules">Kernel modules</h2>
<p><em><span class="dquo">“</span>[A] few cases where kernel modules are a good idea in embedded systems:</em></p>
<ul>
<li><em>proprietary modules</em></li>
<li><em>reduce boot time by deferring the loading of non-essential drivers</em></li>
<li><em>[it] would take up too much memory to compile [all drivers] statically</em></li>
</ul>
<h2 id="finding-out-which-kernel-target-to-build">Finding out which kernel target to build</h2>
<p><em><span class="dquo">“</span>To build a kernel image, you need to know what your bootloader expects.</em></p>
<ul>
<li><strong>U-Boot</strong>: <em>Traditionally, U-Boot has required <code>uImage</code>, but newer versions can load a <code>zImage</code> file using the <code>bootz</code> command</em></li>
<li><strong>x86 targets</strong>: <em>Requires a <code>bzImage</code>file</em></li>
<li><strong>Most other bootloaders</strong>: <em>Require a <code>zImage</code> file”</em></li>
</ul>
<p><em><span class="dquo">“</span>There is a small issue with building a uImage file for <span class="caps">ARM</span> with multi-platform support […]. It allows a single kernel binary to run on multiple platforms and is a step on the road toward having a small number of kernels for all <span class="caps">ARM</span> devices. The kernel selects the correct platform by reading the machine number or the device tree passed to it by the bootloader.
The problem occurs because the location of physical memory might be different for each platform, and so the relocation address for the kernel (usually <code>0x8000</code> bytes from the start of physical <span class="caps">RAM</span>) might also be different.”</em></p>
<p><em><span class="dquo">“</span>The <code>uImage</code> format is not compatible with multi-platform images.”</em></p>
<p><em><span class="dquo">“</span>You can still create a uImage binary from a multi-platform build, so long as you give the <code>LOADADDR</code> of the particular SoC you are hoping to boot this kernel on. You can find the load address by looking in <code>mach -[your SoC]/Makefile.boot</code> and noting the value of <code>zreladdr-y</code>:”</em></p>
<div class="highlight"><pre><span></span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf- <span class="nv">LOADADDR</span><span class="o">=</span>0x80008000 uImage
</pre></div>
<h2 id="build-artifacts">Build artifacts</h2>
<p><em><span class="dquo">“</span>If you have compiled your kernel with debug enabled (<code>CONFIG_DEBUG_INFO=y</code>), it will contain debug symbols which can be used with debuggers like <code>kgdb</code><span class="dquo">“</span></em></p>
<p><em><span class="dquo">“</span><code>System.map</code> contains the symbol table in a human readable form.”</em></p>
<p><em><span class="dquo">“</span>Most bootloaders cannot handle <span class="caps">ELF</span> code directly. There is a further stage of processing which takes vmlinux and places those binaries in `arch/$<span class="caps">ARCH</span>/boot that are suitable for the various bootloaders:</em></p>
<ul>
<li><code>Image</code>: <em><code>vmlinux</code> converted to raw binary format.</em></li>
<li><code>zImage</code>: <em>For the PowerPC architecture, this is just a compressed version of <code>Image</code> […] the bootloader must do the decompression. For all other architectures, [<code>Image</code> contains] a stub of code that decompresses and relocates it.</em></li>
<li><code>uImage</code>: <em><code>zImage</code> plus a 64-byte U-Boot header.</em>”</li>
</ul>
<h2 id="compiling-device-trees">Compiling device trees</h2>
<p><em><span class="dquo">“</span>The <code>dtbs</code> target builds device trees according to the rules in <code>arch/$ARCH/boot/dts/Makefile</code><span class="dquo">“</span></em> , using the device tree source files in that directory.”*</p>
<div class="highlight"><pre><span></span>make <span class="nv">ARCH</span><span class="o">=</span>arm dtbs
</pre></div>
<p><em><span class="dquo">“</span>The compiled <code>.dtb</code> files are generated in the same directory as the sources.”</em></p>
<h2 id="compiling-modules">Compiling modules</h2>
<p><em><span class="dquo">“</span>Build [modules] separately using the <code>modules</code> target:”</em></p>
<div class="highlight"><pre><span></span>make -j <span class="m">4</span> <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf- modules
</pre></div>
<p><em><span class="dquo">“</span>The compiled modules have a <code>.ko</code> suffix and are generated in the same directory as the source code”</em></p>
<p><em><span class="dquo">“</span>Use the <code>modules_install</code> <code>make</code> target to install them in the right place.”</em></p>
<p><em><span class="dquo">“</span>To install them into the staging area of your root filesystem […], provide the path using <code>INSTALL_MOD_PATH</code>:”</em></p>
<div class="highlight"><pre><span></span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-cortex_a8-linux-gnueabihf- <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span><span class="nv">$HOME</span>/rootfs modules_install
</pre></div>
<h2 id="cleaning-kernel-sources">Cleaning kernel sources</h2>
<p>Make targets:</p>
<ul>
<li><span class="dquo">“</span><code>clean</code>: <em>Removes object files and most intermediates.</em></li>
<li><code>mrproper</code>: <em>Removes all intermediate files, including the <code>.config</code> file. [Return] the source tree to the state it was in immediately after cloning</em></li>
<li><code>distclean</code>: <em>This is the same as <code>mrproper</code>, but also deletes editor backup files, patch files, and other artifacts of software development.</em>”</li>
</ul>
            
            
            <hr/>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="./language_implementation_patterns.html" title="Previous: Language Implementation Patterns">Language Implementation Patterns</a></li>
                <li class="next-article"><a href="./gcc_binutils_and_other_developer_tools.html" title="Next: GCC, binutils and other developer tools">GCC, binutils and other developer tools</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2018-01-20T21:39:58+01:00">Jan 20, 2018</time>

<h4>Last Updated</h4>
<time datetime="2018-11-10T21:07:05+01:00">Nov 10, 2018</time>

            <h4>Category</h4>
            <a class="category-link" href="./categories.html#programming-ref">Programming</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="./tags.html#embedded_systems-ref">Embedded Systems
                    <span>8</span>
</a></li>
                <li><a href="./tags.html#linux-ref">Linux
                    <span>12</span>
</a></li>
                <li><a href="./tags.html#os-ref">OS
                    <span>13</span>
</a></li>
                <li><a href="./tags.html#unix-ref">Unix
                    <span>8</span>
</a></li>
            </ul>
<h4>Contact</h4>
    <a href="https://www.linkedin.com/in/lukaswoodtli" title="My LinkedIn Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-linkedin sidebar-social-links"></i></a>
    <a href="https://github.com/LukasWoodtli" title="My github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
    <a href="https://stackoverflow.com/cv/lukaswoodtli" title="My stack-overflow Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-stack-overflow sidebar-social-links"></i></a>
    <a href="https://www.xing.com/profile/Lukas_Woodtli" title="My XING Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-xing sidebar-social-links"></i></a>
    <a href="/pages/contact.html" title="My email Address" class="sidebar-social-links" target="_blank">
    <i class="fa fa-envelope sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    
    </body>
    <!-- Theme: Elegant built for Pelican
    License : http://oncrashreboot.com/pelican-elegant -->
</html>