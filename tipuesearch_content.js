var tipuesearch = {"pages":[{"title":"Logik","text":"Notizen zur Vorlesung: Einführung in die Logik Übersicht Aussagelogik Prädikatenlogik Zeichensystem der Aussagelogik Wahrheitsfunkt. Verknüpfungen Aussagelogische Form Interpretation von Aussagelogischen Formeln Zeichensystem der Prädiketenlogik Klassifikation von Aussagen Prädikatenlogische Form Interpretation von Prädikatenlogischen Formeln Metalogik der Aussagelogik Objektebene vs. Metaebene Logische Wahrheit Falschheit Folgerung Äquivalenz Widerspruch Konsistenz Abhängigkeit Metalogik der Prädikatenlogik Parallele zur Metalogik der Aussagelogik Logische Wahrheit Falschheit Folgerung Äquivalenz Weitere metalogische Begriffe Mathematischer Zugang zur Aussagelogik Formale Logik Logische Folgerung Beispiel: Prämissen (Voraussetzung): Alle Logiker sind Menschen. Alle Menschen sind schlafbedürftig. Konklusion (Schlusssatz): Alle Logiker sind schlafbedürftig. Das Gesamte ist ein *Schluss* . 2 Fragen Korrektheit des Schlusses Ist die Konklusion wahr? Merkmale Wenn die Prämissen wahr sind, dann ist auch die Konklusion wahr (‘Wahrheitstransfer') Ob die Prämissen wahr sind, spielt für die Beurteilung der Korrektheit des Schlusses keine Rolle. Aus einem korrektem Schluss lassen sich viele weitere korrekte Schlüsse (mechanisch) erzeugen. Für die Korrektheit eines Schlusses sind die Bedeutungen der in ihm vorkommenden Begriffe unwesentlich. Die Gültigkeit von korrekten Schlüssen hängt von Wörtern wie alle und einige ab Prämissen können auch (manifest) falsch sein, der Schluss bleibt trotzdem korrekt! Beispiel: Prämissen (Voraussetzung): Alle Logiker sind Menschen. Alle Menschen haben Eigenschaft S . Konklusion (Schlusssatz): Alle Logiker haben Eigenschaft S . Setze Eigenschaft S = Reptil sein Allgemeine Formulierung Prämissen (Voraussetzung): Alle A sind B . Alle B sind C . Konklusion (Schlusssatz): Alle A sind C . Der Schluss ist korrekt auch wenn man nicht weiss, was A , B und C bedeuten. Logische Form Form: Elemente isolieren, von denen die Korrektheit eines Schlusses abhängt Inhalt: Elemente die übrig bleiben Verschiedene Logiken (z.B. Aussagelogik, Prädikatenlogik) können anhand ihrer unterschidlichen logischen Form differenziert werden.","tags":"Mathematics","url":"logik.html","loc":"logik.html"},{"title":"Scheme (Lisp)","text":"This page collects notes about Scheme (an Lisp in general). Sources Most information is taken from: Structure and Interpretation of Computer Programs See also my notes on Structure and Interpretation of Computer Programs My Github repository with examples Evaluation Rules If self-evaluating : return value If name : return value of associated name in environment If special form : do something special If combination : evaluate all subexpressions (in any order) apply operator on arguments and return result Application Rules If primitive procedure , just do it If compound procedure , then evaluate body of procedure with each formal parameter replaced with corresponding actual argument value. Linear Recursion and Iteration See SICP section 1.2.1 and stack overflow It's confusing that both the recursive and the iterative implementation call themselves. There is a distinction between Recursive process and Recursive function A recursive function calls itself. But it can be implemented as recursive or iterative process. Recursive Process Iterative Process Function calls itself Function calls itself Itermediate result is kept on caller side Intermedia result is passed to the called function additinal argument needed initial value needed Each recursive call needs a new stack frame Stack frame can be reused (tail call) Recursive function call part of bigger expression Recursive function call not part of bigger expression Easier to understand More difficult to understand and to implement Needs stack Can be implemented in register machine (without stack) Recursive Process ( define ( factorial n ) ( if ( = n 1 ) 1 ( * n ( factorial ( - n 1 ))))) ;; 'factorial' is part of bigger expression Iterative Process ( define ( factorial n ) ( fact-iter 1 1 n )) ;; inital values need to be provided ( define ( fact-iter product counter max-count ) ;; max-cout: intermediate result ( if ( > counter max-count ) product ( fact-iter ( * counter product ) ( + counter 1 ) max-count ))) ;; max-cout: supply intermediate result to next call Iterative algorithms have constant space Develop iterative algorithm: figure out a way to accumulate partial answers write out table to analyze precisely initialization of first row update rules for other rows how to know when to stop Iterative algorithms have no pending operations when the procedure calls itself Expressions In Scheme everything is an expression Expressions can be nested arbritarly Sequences as Conventional Interfaces \" The key to organizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the \"signals\" that flow from one stage in the process to the next. If we represent these signals as lists, then we can use list operations to implement the processing at each of the stages. \" \" The value of expressing programs as sequence operations is that this helps us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces. We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.\" SICP section 2.2.3 Sequences as Conventional Interfaces Quotation \" Allowing quotation in a language wreaks havoc with the ability to reason about the language in simple terms, because it destroys the notion that equals can be substituted for equals. For example, three is one plus two, but the word \"three\" is not the phrase \"one plus two\". Quotation is powerful because it gives us a way to build expressions that manipulate other expressions\" SICP section 2.3.1 Quotation Backquote Preceding a list with a backquote symbol (`) is much like quoting it, except that anything in the list that is flagged with a comma is evaluated. SICP section 5.5.2 Compiling Expressions","tags":"Programming","url":"scheme_(lisp).html","loc":"scheme_(lisp).html"},{"title":"Evaluation strategy","text":"See also: Wikipedia: Evaluation strategy Applicative order evaluation (eager evaluation) All arguments to procedures are evaluated when provided to procedure (when procedure is applied) for example Scheme uses this evaluation strategy Normal order evaluation (lazy evaluation) Delay the evaluation of procedure arguments until they are needed","tags":"Programming","url":"evaluation_strategy.html","loc":"evaluation_strategy.html"}]};