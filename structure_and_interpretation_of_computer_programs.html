<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Structure and Interpretation of Computer Programs</title>
        <link rel="stylesheet" href="http://lukaswoodtli.github.io/theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://lukaswoodtli.github.io/">Lukas Woodtli </a></h1>
                <nav><ul>
                    <li><a href="/index.html">Home</a></li>
                    <li><a href="/pages/resume.html">Resume</a></li>
                    <li><a href="[(u'Hard Skills', u'/pages/skills.html'), (u'Courses', u'/pages/courses.html'), (u'Books', u'/pages/books.html'), (u'Projects', u'/pages/projects.html')]">Skills</a></li>
                    <li><a href="[(u'Blog Index', u'/pages/blog.html'), (u'Categories', u'/categories.html'), (u'Tags', u'/tags.html'), (u'Chronological', u'/archives.html')]">Blog</a></li>
                    <li><a href="/pages/contact.html">Contact</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/pages/blog.html">Blog</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/pages/books.html">Books</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/pages/contact.html">Contact</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/pages/courses.html">Courses</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/pages/note_to_recruiters_and_headhunters.html">Note to Recruiters and&nbsp;Headhunters</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/pages/projects.html">Projects</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/pages/resume.html">Resume</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/pages/skills.html">Skills</a></li>
    
                        <li><a href="http://lukaswoodtli.github.io/">Welcome to my&nbsp;Site</a></li>
                    <li><a href="http://lukaswoodtli.github.io/category/emacs.html">Emacs</a></li>
                    <li><a href="http://lukaswoodtli.github.io/category/finance.html">Finance</a></li>
                    <li><a href="http://lukaswoodtli.github.io/category/mathematics.html">Mathematics</a></li>
                    <li><a href="http://lukaswoodtli.github.io/category/misc.html">Misc</a></li>
                    <li class="active"><a href="http://lukaswoodtli.github.io/category/programming.html">Programming</a></li>
                    <li><a href="http://lukaswoodtli.github.io/category/version_control.html">Version Control</a></li>
                </ul>
                </nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://lukaswoodtli.github.io/structure_and_interpretation_of_computer_programs.html" rel="bookmark"
           title="Permalink to Structure and Interpretation of Computer Programs">Structure and Interpretation of Computer&nbsp;Programs</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>Thu 10 November 2016</span>
<span>| tags: <a href="http://lukaswoodtli.github.io/tag/lisp.html">Lisp</a></span>
</footer><!-- /.post-info -->      <p>Notes to the book</p>
<blockquote>
<p>Structure and Interpretation of Computer Programs, Second Edition
Harold Abelson, Gerald Jay Sussman, Julie Sussman
<span class="caps">MIT</span> Press</p>
</blockquote>
<div class="toc">
<ul>
<li><a href="#building-abstractions-with-procedures">Building Abstractions with Procedures</a><ul>
<li><a href="#the-elements-of-programming">The Elements of Programming</a><ul>
<li><a href="#evaluating-combinations">Evaluating Combinations</a></li>
<li><a href="#the-substitution-model-for-procedure-application">The Substitution Model for Procedure Application</a><ul>
<li><a href="#applicative-order-versus-normal-order">Applicative order versus normal order</a></li>
</ul>
</li>
<li><a href="#the-substitution-model-for-procedure-application_1">The Substitution Model for Procedure Application</a></li>
</ul>
</li>
<li><a href="#formulating-abstractions-with-higher-order-procedures">Formulating Abstractions with Higher-Order Procedures</a><ul>
<li><a href="#constructing-procedures-using-lambda">Constructing Procedures Using lambda</a><ul>
<li><a href="#using-let-to-create-local-variables">Using let to create local variables</a></li>
<li><a href="#abstractions-and-first-class-procedures">Abstractions and first-class procedures</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#building-abstractions-with-data">Building Abstractions with Data</a><ul>
<li><a href="#what-is-meant-by-data">What Is Meant by Data?</a></li>
<li><a href="#hierarchical-data-and-the-closure-property">Hierarchical Data and the Closure Property</a><ul>
<li><a href="#sequences-as-conventional-interfaces">Sequences as Conventional Interfaces</a><ul>
<li><a href="#sequence-operations">Sequence Operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="building-abstractions-with-procedures">Building Abstractions with Procedures</h1>
<h2 id="the-elements-of-programming">The Elements of Programming</h2>
<p><em><span class="dquo">“</span>[The] language provides for combining simple ideas to form more complex ideas.  Every powerful language has three mechanisms for accomplishing this:</em></p>
<ul>
<li><em><strong>primitive expressions</strong>, which represent the simplest entities the language is concerned with,</em></li>
<li><em><strong>means of combination</strong>, by which compound elements are built from simpler ones, and</em></li>
<li><em><strong>means of abstraction</strong>, by which compound elements can be named and manipulated as units.”</em></li>
</ul>
<h3 id="evaluating-combinations">Evaluating Combinations</h3>
<p><em><span class="dquo">“</span>To evaluate a combination, do the following:</em>
- <em>Evaluate the subexpressions of the combination.</em>
- <em>Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (the operands).</em>”</p>
<p><em><span class="dquo">“</span>[…] first perform the evaluation process on each element of the combination. Thus, the evaluation rule is<strong>recursive</strong> in nature”</em></p>
<h3 id="the-substitution-model-for-procedure-application">The Substitution Model for Procedure Application</h3>
<h4 id="applicative-order-versus-normal-order">Applicative order versus normal order</h4>
<p><em><span class="dquo">“</span>interpreter first evaluates the operator and operands and then applies the resulting procedure to the resulting arguments”</em></p>
<p><em><span class="dquo">“</span>[An] alternative evaluation model would not evaluate the operands until their values were needed. Instead it would first substitute operand expressions for parameters until it obtained an expression involving only primitive operators, and would then perform the evaluation”</em></p>
<p><em><span class="dquo">“</span>This alternative ‘fully expand and then reduce’ evaluation method is known as <strong>normal-order evaluation</strong>, in contrast to the ‘evaluate the arguments and then apply’ method that the interpreter actually uses, which is called <strong>applicative-order evaluation</strong>”</em></p>
<p><em><span class="dquo">“</span>normal-order and applicative-order evaluation produce the same value”</em></p>
<p><em><span class="dquo">“</span>Lisp uses applicative-order evaluation”</em></p>
<p><em><span class="dquo">“</span>Lisp obeys the convention that every expression has a value”</em></p>
<h3 id="the-substitution-model-for-procedure-application_1">The Substitution Model for Procedure Application</h3>
<p><em><span class="dquo">“</span>In the iterative case, the program variables provide a complete description of the state of the process at any point.”</em></p>
<p><em><span class="dquo">“</span>In contrasting iteration and recursion, we must be careful not to confuse the notion of a recursive <strong>process</strong> with the notion of a recursive <strong>procedure</strong> . When we describe a procedure as recursive, we are referring to the syntactic fact that the procedure definition refers (either directly or indirectly) to the procedure itself. But when we describe a process as following a pattern that is, say, linearly recursive, we are speaking about how the process evolves, not about the syntax of how a procedure is written.”</em></p>
<p><em><span class="dquo">“</span>One reason that the distinction between process and procedure may be confusing is that most implementations of common languages (including Ada, Pascal, and C) are designed in such a way that the interpretation of any recursive procedure consumes an amount of memory that grows with the number of procedure calls, even when the process described is, in principle, iterative. As a consequence, these languages can describe iterative processes only by resorting to special-purpose ‘looping constructs’ such as <code>do</code>, <code>repeat</code>, <code>until</code>, <code>for</code>, and <code>while</code>.”</em></p>
<p><em><span class="dquo">“</span>any iterative process can be realized ‘in hardware’ as a machine that has a fixed set of registers and no auxiliary memory. In contrast, realizing a recursive process requires a machine that uses an auxiliary data structure known as a <strong>stack</strong>.”</em></p>
<h2 id="formulating-abstractions-with-higher-order-procedures">Formulating Abstractions with Higher-Order Procedures</h2>
<h3 id="constructing-procedures-using-lambda">Constructing Procedures Using <code>lambda</code></h3>
<h4 id="using-let-to-create-local-variables">Using <code>let</code> to create local variables</h4>
<p><em><span class="dquo">“</span>we could use a lambda expression to specify an anonymous procedure for binding our local variables</em></p>
<p><em>The general form of a <code>let</code> expression is</em></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">let</span>
   <span class="p">((</span><span class="nf">&lt;var</span> <span class="mi">1</span><span class="nv">&gt;</span> <span class="nv">&lt;exp</span> <span class="mi">1</span><span class="nv">&gt;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">&lt;var</span> <span class="mi">2</span><span class="nv">&gt;</span> <span class="nv">&lt;exp</span> <span class="mi">2</span><span class="nv">&gt;</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="p">(</span><span class="nf">&lt;var</span> <span class="nv">n&gt;</span> <span class="nv">&lt;exp</span> <span class="nv">n&gt;</span><span class="p">))</span>
  <span class="nv">&lt;body&gt;</span><span class="p">)</span>
</pre></div>
<p><em>the <code>let</code> expression is interpreted as an alternate syntax for</em></p>
<div class="highlight"><pre><span></span><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">&lt;var</span> <span class="mi">1</span><span class="nv">&gt;</span> <span class="o">...</span> <span class="nv">&lt;var</span> <span class="nv">n&gt;</span><span class="p">)</span>
  <span class="nv">&lt;body&gt;</span><span class="p">)</span>
    <span class="nv">&lt;exp</span> <span class="mi">1</span><span class="nv">&gt;</span>
    <span class="o">...</span>
    <span class="nv">&lt;exp</span> <span class="nv">n&gt;</span><span class="p">)</span>
</pre></div>
<p><em>No new mechanism is required in the interpreter in order to provide local variables. A <code>let</code> expression is simply syntactic sugar for the underlying lambda application.”</em></p>
<p><em><span class="dquo">“</span><code>Let</code> allows one to bind variables as locally as possible to where they are to be used.”</em></p>
<h4 id="abstractions-and-first-class-procedures">Abstractions and first-class procedures</h4>
<p><em><span class="dquo">“</span>programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status.”</em></p>
<p><em><span class="dquo">“</span>Some of the ‘rights and privileges’ of first-class elements are:</em>
- <em>They may be named by variables.</em>
- <em>They may be passed as arguments to procedures.</em>
- <em>They may be returned as the results of procedures.</em>
- <em>They may be included in data structures.”</em></p>
<h1 id="building-abstractions-with-data">Building Abstractions with Data</h1>
<h3 id="what-is-meant-by-data">What Is Meant by Data?</h3>
<p><em><span class="dquo">“</span>In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.”</em></p>
<p><em><span class="dquo">“</span>we could implement <code>cons</code>, <code>car</code>, and <code>cdr</code> without using any data structures at all but only using procedures. Here are the definitions:</em></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">m</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
          <span class="p">((</span><span class="nb">= </span><span class="nv">m</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
              <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Argument not 0 or 1: CONS"</span> <span class="nv">m</span><span class="p">))))</span>
   <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">car </span><span class="nv">z</span><span class="p">)(</span><span class="nf">z</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">z</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
<h2 id="hierarchical-data-and-the-closure-property">Hierarchical Data and the Closure Property</h2>
<p><em><span class="dquo">“</span>The ability to create pairs whose elements are pairs is the essence of list structure’s importance as a representational tool. We refer to this ability as the <strong>closure property</strong> of cons. In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.”</em></p>
<h3 id="sequences-as-conventional-interfaces">Sequences as Conventional Interfaces</h3>
<h4 id="sequence-operations">Sequence Operations</h4>
<p><em><span class="dquo">“</span>The key to organizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the ‘signals’ that flow from one stage in the process to the next. If we represent these signals as lists, then we can use list operations to implement the processing at each of the stages.”</em></p>
<p><em><span class="dquo">“</span>The value of expressing programs as sequence operations is that this helps us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces. We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways.”</em></p>
<p><em><span class="dquo">“</span>The Lisp community also (unfortunately) uses the word “closure” to describe a totally unrelated concept: A closure is an implementation technique for representing procedures with free variables.”</em></p>
<p><em><span class="dquo">“</span>Unlike Lisp with its pairs, these languages have no built-in general-purpose glue that makes it easy to manipulate compound data in a uniform way.”</em></p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, inspired by the default theme.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>